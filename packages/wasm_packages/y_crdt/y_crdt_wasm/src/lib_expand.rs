#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub type YEvent<'a> = y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent<'a>;
#[allow(clippy::all)]
pub fn event_callback(function_id: u32, event: YEvent<'_>) {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    unsafe {
        let mut cleanup_list = Vec::new();
        let (
            result142_0,
            result142_1,
            result142_2,
            result142_3,
            result142_4,
            result142_5,
        ) = match event {
            y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YArrayEvent(e) => {
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayEvent {
                    target: target0,
                    delta: delta0,
                    path: path0,
                } = e;
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                    ref_: ref_1,
                } = target0;
                let vec32 = delta0;
                let len32 = vec32.len() as i32;
                let layout32 = alloc::Layout::from_size_align_unchecked(
                    vec32.len() * 12,
                    4,
                );
                let result32 = if layout32.size() != 0 {
                    let ptr = alloc::alloc(layout32);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout32);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec32.into_iter().enumerate() {
                    let base = result32 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaInsert(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaInsert {
                                    insert: insert2,
                                } = e;
                                let vec29 = insert2;
                                let len29 = vec29.len() as i32;
                                let layout29 = alloc::Layout::from_size_align_unchecked(
                                    vec29.len() * 40,
                                    8,
                                );
                                let result29 = if layout29.size() != 0 {
                                    let ptr = alloc::alloc(layout29);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout29);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec29.into_iter().enumerate() {
                                    let base = result29 as i32 + (i as i32) * 40;
                                    {
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item3,
                                                    array_references: array_references3,
                                                    map_references: map_references3,
                                                } = e;
                                                match item3 {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                        *((base + 16)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                        let vec4 = e;
                                                        let ptr4 = vec4.as_ptr() as i32;
                                                        let len4 = vec4.len() as i32;
                                                        *((base + 20) as *mut i32) = len4;
                                                        *((base + 16) as *mut i32) = ptr4;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                        let vec5 = e;
                                                        let ptr5 = vec5.as_ptr() as i32;
                                                        let len5 = vec5.len() as i32;
                                                        *((base + 20) as *mut i32) = len5;
                                                        *((base + 16) as *mut i32) = ptr5;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index6,
                                                        } = e;
                                                        *((base + 16)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index7,
                                                        } = e;
                                                        *((base + 16)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                                    }
                                                };
                                                let vec13 = array_references3;
                                                let len13 = vec13.len() as i32;
                                                let layout13 = alloc::Layout::from_size_align_unchecked(
                                                    vec13.len() * 8,
                                                    4,
                                                );
                                                let result13 = if layout13.size() != 0 {
                                                    let ptr = alloc::alloc(layout13);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout13);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec13.into_iter().enumerate() {
                                                    let base = result13 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec12 = e;
                                                        let len12 = vec12.len() as i32;
                                                        let layout12 = alloc::Layout::from_size_align_unchecked(
                                                            vec12.len() * 16,
                                                            8,
                                                        );
                                                        let result12 = if layout12.size() != 0 {
                                                            let ptr = alloc::alloc(layout12);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout12);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec12.into_iter().enumerate() {
                                                            let base = result12 as i32 + (i as i32) * 16;
                                                            {
                                                                match e {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec8 = e;
                                                                        let ptr8 = vec8.as_ptr() as i32;
                                                                        let len8 = vec8.len() as i32;
                                                                        *((base + 12) as *mut i32) = len8;
                                                                        *((base + 8) as *mut i32) = ptr8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec9 = e;
                                                                        let ptr9 = vec9.as_ptr() as i32;
                                                                        let len9 = vec9.len() as i32;
                                                                        *((base + 12) as *mut i32) = len9;
                                                                        *((base + 8) as *mut i32) = ptr9;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index10,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index11,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len12;
                                                        *((base + 0) as *mut i32) = result12 as i32;
                                                        cleanup_list.extend_from_slice(&[(result12, layout12)]);
                                                    }
                                                }
                                                *((base + 28) as *mut i32) = len13;
                                                *((base + 24) as *mut i32) = result13 as i32;
                                                let vec21 = map_references3;
                                                let len21 = vec21.len() as i32;
                                                let layout21 = alloc::Layout::from_size_align_unchecked(
                                                    vec21.len() * 8,
                                                    4,
                                                );
                                                let result21 = if layout21.size() != 0 {
                                                    let ptr = alloc::alloc(layout21);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout21);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec21.into_iter().enumerate() {
                                                    let base = result21 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec20 = e;
                                                        let len20 = vec20.len() as i32;
                                                        let layout20 = alloc::Layout::from_size_align_unchecked(
                                                            vec20.len() * 24,
                                                            8,
                                                        );
                                                        let result20 = if layout20.size() != 0 {
                                                            let ptr = alloc::alloc(layout20);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout20);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec20.into_iter().enumerate() {
                                                            let base = result20 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t14_0, t14_1) = e;
                                                                let vec15 = t14_0;
                                                                let ptr15 = vec15.as_ptr() as i32;
                                                                let len15 = vec15.len() as i32;
                                                                *((base + 4) as *mut i32) = len15;
                                                                *((base + 0) as *mut i32) = ptr15;
                                                                match t14_1 {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec16 = e;
                                                                        let ptr16 = vec16.as_ptr() as i32;
                                                                        let len16 = vec16.len() as i32;
                                                                        *((base + 20) as *mut i32) = len16;
                                                                        *((base + 16) as *mut i32) = ptr16;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec17 = e;
                                                                        let ptr17 = vec17.as_ptr() as i32;
                                                                        let len17 = vec17.len() as i32;
                                                                        *((base + 20) as *mut i32) = len17;
                                                                        *((base + 16) as *mut i32) = ptr17;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index18,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index19,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index19);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len20;
                                                        *((base + 0) as *mut i32) = result20 as i32;
                                                        cleanup_list.extend_from_slice(&[(result20, layout20)]);
                                                    }
                                                }
                                                *((base + 36) as *mut i32) = len21;
                                                *((base + 32) as *mut i32) = result21 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result13, layout13), (result21, layout21)],
                                                    );
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_22,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_22);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_23,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_23);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_24,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_24);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_25,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_26,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_27,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                    ref_: ref_28,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                            }
                                        };
                                    }
                                }
                                *((base + 8) as *mut i32) = len29;
                                *((base + 4) as *mut i32) = result29 as i32;
                                cleanup_list.extend_from_slice(&[(result29, layout29)]);
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaDelete(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaDelete {
                                    delete: delete30,
                                } = e;
                                *((base + 4)
                                    as *mut i32) = wit_bindgen::rt::as_i32(delete30);
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaRetain(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (2i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaRetain {
                                    retain: retain31,
                                } = e;
                                *((base + 4)
                                    as *mut i32) = wit_bindgen::rt::as_i32(retain31);
                            }
                        };
                    }
                }
                let vec34 = path0;
                let len34 = vec34.len() as i32;
                let layout34 = alloc::Layout::from_size_align_unchecked(
                    vec34.len() * 12,
                    4,
                );
                let result34 = if layout34.size() != 0 {
                    let ptr = alloc::alloc(layout34);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout34);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec34.into_iter().enumerate() {
                    let base = result34 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let vec33 = e;
                                let ptr33 = vec33.as_ptr() as i32;
                                let len33 = vec33.len() as i32;
                                *((base + 8) as *mut i32) = len33;
                                *((base + 4) as *mut i32) = ptr33;
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            }
                        };
                    }
                }
                cleanup_list
                    .extend_from_slice(&[(result32, layout32), (result34, layout34)]);
                (
                    0i32,
                    wit_bindgen::rt::as_i32(ref_1),
                    result32 as i32,
                    len32,
                    result34 as i32,
                    len34,
                )
            }
            y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YMapEvent(e) => {
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapEvent {
                    target: target35,
                    keys: keys35,
                    path: path35,
                } = e;
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                    ref_: ref_36,
                } = target35;
                let vec92 = keys35;
                let len92 = vec92.len() as i32;
                let layout92 = alloc::Layout::from_size_align_unchecked(
                    vec92.len() * 112,
                    8,
                );
                let result92 = if layout92.size() != 0 {
                    let ptr = alloc::alloc(layout92);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout92);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec92.into_iter().enumerate() {
                    let base = result92 as i32 + (i as i32) * 112;
                    {
                        let (t37_0, t37_1) = e;
                        let vec38 = t37_0;
                        let ptr38 = vec38.as_ptr() as i32;
                        let len38 = vec38.len() as i32;
                        *((base + 4) as *mut i32) = len38;
                        *((base + 0) as *mut i32) = ptr38;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDelta {
                            action: action39,
                            old_value: old_value39,
                            new_value: new_value39,
                        } = t37_1;
                        *((base + 8)
                            as *mut u8) = (match action39 {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDeltaAction::Insert => {
                                0
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDeltaAction::Update => {
                                1
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDeltaAction::Delete => {
                                2
                            }
                        }) as u8;
                        match old_value39 {
                            Some(e) => {
                                *((base + 16) as *mut u8) = (1i32) as u8;
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item40,
                                            array_references: array_references40,
                                            map_references: map_references40,
                                        } = e;
                                        match item40 {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                *((base + 32) as *mut u8) = (0i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                *((base + 32) as *mut u8) = (1i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (2i32) as u8;
                                                *((base + 40)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (3i32) as u8;
                                                *((base + 40) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (4i32) as u8;
                                                *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (5i32) as u8;
                                                let vec41 = e;
                                                let ptr41 = vec41.as_ptr() as i32;
                                                let len41 = vec41.len() as i32;
                                                *((base + 44) as *mut i32) = len41;
                                                *((base + 40) as *mut i32) = ptr41;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (6i32) as u8;
                                                let vec42 = e;
                                                let ptr42 = vec42.as_ptr() as i32;
                                                let len42 = vec42.len() as i32;
                                                *((base + 44) as *mut i32) = len42;
                                                *((base + 40) as *mut i32) = ptr42;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index43,
                                                } = e;
                                                *((base + 40)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index43);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index44,
                                                } = e;
                                                *((base + 40)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index44);
                                            }
                                        };
                                        let vec50 = array_references40;
                                        let len50 = vec50.len() as i32;
                                        let layout50 = alloc::Layout::from_size_align_unchecked(
                                            vec50.len() * 8,
                                            4,
                                        );
                                        let result50 = if layout50.size() != 0 {
                                            let ptr = alloc::alloc(layout50);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout50);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec50.into_iter().enumerate() {
                                            let base = result50 as i32 + (i as i32) * 8;
                                            {
                                                let vec49 = e;
                                                let len49 = vec49.len() as i32;
                                                let layout49 = alloc::Layout::from_size_align_unchecked(
                                                    vec49.len() * 16,
                                                    8,
                                                );
                                                let result49 = if layout49.size() != 0 {
                                                    let ptr = alloc::alloc(layout49);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout49);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec49.into_iter().enumerate() {
                                                    let base = result49 as i32 + (i as i32) * 16;
                                                    {
                                                        match e {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec45 = e;
                                                                let ptr45 = vec45.as_ptr() as i32;
                                                                let len45 = vec45.len() as i32;
                                                                *((base + 12) as *mut i32) = len45;
                                                                *((base + 8) as *mut i32) = ptr45;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec46 = e;
                                                                let ptr46 = vec46.as_ptr() as i32;
                                                                let len46 = vec46.len() as i32;
                                                                *((base + 12) as *mut i32) = len46;
                                                                *((base + 8) as *mut i32) = ptr46;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index47,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index47);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index48,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index48);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len49;
                                                *((base + 0) as *mut i32) = result49 as i32;
                                                cleanup_list.extend_from_slice(&[(result49, layout49)]);
                                            }
                                        }
                                        *((base + 52) as *mut i32) = len50;
                                        *((base + 48) as *mut i32) = result50 as i32;
                                        let vec58 = map_references40;
                                        let len58 = vec58.len() as i32;
                                        let layout58 = alloc::Layout::from_size_align_unchecked(
                                            vec58.len() * 8,
                                            4,
                                        );
                                        let result58 = if layout58.size() != 0 {
                                            let ptr = alloc::alloc(layout58);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout58);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec58.into_iter().enumerate() {
                                            let base = result58 as i32 + (i as i32) * 8;
                                            {
                                                let vec57 = e;
                                                let len57 = vec57.len() as i32;
                                                let layout57 = alloc::Layout::from_size_align_unchecked(
                                                    vec57.len() * 24,
                                                    8,
                                                );
                                                let result57 = if layout57.size() != 0 {
                                                    let ptr = alloc::alloc(layout57);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout57);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec57.into_iter().enumerate() {
                                                    let base = result57 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t51_0, t51_1) = e;
                                                        let vec52 = t51_0;
                                                        let ptr52 = vec52.as_ptr() as i32;
                                                        let len52 = vec52.len() as i32;
                                                        *((base + 4) as *mut i32) = len52;
                                                        *((base + 0) as *mut i32) = ptr52;
                                                        match t51_1 {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec53 = e;
                                                                let ptr53 = vec53.as_ptr() as i32;
                                                                let len53 = vec53.len() as i32;
                                                                *((base + 20) as *mut i32) = len53;
                                                                *((base + 16) as *mut i32) = ptr53;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec54 = e;
                                                                let ptr54 = vec54.as_ptr() as i32;
                                                                let len54 = vec54.len() as i32;
                                                                *((base + 20) as *mut i32) = len54;
                                                                *((base + 16) as *mut i32) = ptr54;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index55,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index55);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index56,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index56);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len57;
                                                *((base + 0) as *mut i32) = result57 as i32;
                                                cleanup_list.extend_from_slice(&[(result57, layout57)]);
                                            }
                                        }
                                        *((base + 60) as *mut i32) = len58;
                                        *((base + 56) as *mut i32) = result58 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result50, layout50), (result58, layout58)],
                                            );
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                            ref_: ref_59,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_59);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                            ref_: ref_60,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_60);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                            ref_: ref_61,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_61);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                            ref_: ref_62,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_62);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                            ref_: ref_63,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_63);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                            ref_: ref_64,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_64);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_65,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_65);
                                    }
                                };
                            }
                            None => {
                                *((base + 16) as *mut u8) = (0i32) as u8;
                            }
                        };
                        match new_value39 {
                            Some(e) => {
                                *((base + 64) as *mut u8) = (1i32) as u8;
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item66,
                                            array_references: array_references66,
                                            map_references: map_references66,
                                        } = e;
                                        match item66 {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                *((base + 80) as *mut u8) = (0i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                *((base + 80) as *mut u8) = (1i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (2i32) as u8;
                                                *((base + 88)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (3i32) as u8;
                                                *((base + 88) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (4i32) as u8;
                                                *((base + 88) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (5i32) as u8;
                                                let vec67 = e;
                                                let ptr67 = vec67.as_ptr() as i32;
                                                let len67 = vec67.len() as i32;
                                                *((base + 92) as *mut i32) = len67;
                                                *((base + 88) as *mut i32) = ptr67;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (6i32) as u8;
                                                let vec68 = e;
                                                let ptr68 = vec68.as_ptr() as i32;
                                                let len68 = vec68.len() as i32;
                                                *((base + 92) as *mut i32) = len68;
                                                *((base + 88) as *mut i32) = ptr68;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index69,
                                                } = e;
                                                *((base + 88)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index69);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index70,
                                                } = e;
                                                *((base + 88)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index70);
                                            }
                                        };
                                        let vec76 = array_references66;
                                        let len76 = vec76.len() as i32;
                                        let layout76 = alloc::Layout::from_size_align_unchecked(
                                            vec76.len() * 8,
                                            4,
                                        );
                                        let result76 = if layout76.size() != 0 {
                                            let ptr = alloc::alloc(layout76);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout76);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec76.into_iter().enumerate() {
                                            let base = result76 as i32 + (i as i32) * 8;
                                            {
                                                let vec75 = e;
                                                let len75 = vec75.len() as i32;
                                                let layout75 = alloc::Layout::from_size_align_unchecked(
                                                    vec75.len() * 16,
                                                    8,
                                                );
                                                let result75 = if layout75.size() != 0 {
                                                    let ptr = alloc::alloc(layout75);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout75);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec75.into_iter().enumerate() {
                                                    let base = result75 as i32 + (i as i32) * 16;
                                                    {
                                                        match e {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec71 = e;
                                                                let ptr71 = vec71.as_ptr() as i32;
                                                                let len71 = vec71.len() as i32;
                                                                *((base + 12) as *mut i32) = len71;
                                                                *((base + 8) as *mut i32) = ptr71;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec72 = e;
                                                                let ptr72 = vec72.as_ptr() as i32;
                                                                let len72 = vec72.len() as i32;
                                                                *((base + 12) as *mut i32) = len72;
                                                                *((base + 8) as *mut i32) = ptr72;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index73,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index73);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index74,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index74);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len75;
                                                *((base + 0) as *mut i32) = result75 as i32;
                                                cleanup_list.extend_from_slice(&[(result75, layout75)]);
                                            }
                                        }
                                        *((base + 100) as *mut i32) = len76;
                                        *((base + 96) as *mut i32) = result76 as i32;
                                        let vec84 = map_references66;
                                        let len84 = vec84.len() as i32;
                                        let layout84 = alloc::Layout::from_size_align_unchecked(
                                            vec84.len() * 8,
                                            4,
                                        );
                                        let result84 = if layout84.size() != 0 {
                                            let ptr = alloc::alloc(layout84);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout84);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec84.into_iter().enumerate() {
                                            let base = result84 as i32 + (i as i32) * 8;
                                            {
                                                let vec83 = e;
                                                let len83 = vec83.len() as i32;
                                                let layout83 = alloc::Layout::from_size_align_unchecked(
                                                    vec83.len() * 24,
                                                    8,
                                                );
                                                let result83 = if layout83.size() != 0 {
                                                    let ptr = alloc::alloc(layout83);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout83);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec83.into_iter().enumerate() {
                                                    let base = result83 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t77_0, t77_1) = e;
                                                        let vec78 = t77_0;
                                                        let ptr78 = vec78.as_ptr() as i32;
                                                        let len78 = vec78.len() as i32;
                                                        *((base + 4) as *mut i32) = len78;
                                                        *((base + 0) as *mut i32) = ptr78;
                                                        match t77_1 {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec79 = e;
                                                                let ptr79 = vec79.as_ptr() as i32;
                                                                let len79 = vec79.len() as i32;
                                                                *((base + 20) as *mut i32) = len79;
                                                                *((base + 16) as *mut i32) = ptr79;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec80 = e;
                                                                let ptr80 = vec80.as_ptr() as i32;
                                                                let len80 = vec80.len() as i32;
                                                                *((base + 20) as *mut i32) = len80;
                                                                *((base + 16) as *mut i32) = ptr80;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index81,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index81);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index82,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index82);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len83;
                                                *((base + 0) as *mut i32) = result83 as i32;
                                                cleanup_list.extend_from_slice(&[(result83, layout83)]);
                                            }
                                        }
                                        *((base + 108) as *mut i32) = len84;
                                        *((base + 104) as *mut i32) = result84 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result76, layout76), (result84, layout84)],
                                            );
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                            ref_: ref_85,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_85);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (2i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                            ref_: ref_86,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_86);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (3i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                            ref_: ref_87,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_87);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (4i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                            ref_: ref_88,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_88);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (5i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                            ref_: ref_89,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_89);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (6i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                            ref_: ref_90,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_90);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (7i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_91,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_91);
                                    }
                                };
                            }
                            None => {
                                *((base + 64) as *mut u8) = (0i32) as u8;
                            }
                        };
                    }
                }
                let vec94 = path35;
                let len94 = vec94.len() as i32;
                let layout94 = alloc::Layout::from_size_align_unchecked(
                    vec94.len() * 12,
                    4,
                );
                let result94 = if layout94.size() != 0 {
                    let ptr = alloc::alloc(layout94);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout94);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec94.into_iter().enumerate() {
                    let base = result94 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let vec93 = e;
                                let ptr93 = vec93.as_ptr() as i32;
                                let len93 = vec93.len() as i32;
                                *((base + 8) as *mut i32) = len93;
                                *((base + 4) as *mut i32) = ptr93;
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            }
                        };
                    }
                }
                cleanup_list
                    .extend_from_slice(&[(result92, layout92), (result94, layout94)]);
                (
                    1i32,
                    wit_bindgen::rt::as_i32(ref_36),
                    result92 as i32,
                    len92,
                    result94 as i32,
                    len94,
                )
            }
            y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YTextEvent(e) => {
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextEvent {
                    target: target95,
                    delta: delta95,
                    path: path95,
                } = e;
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                    ref_: ref_96,
                } = target95;
                let vec139 = delta95;
                let len139 = vec139.len() as i32;
                let layout139 = alloc::Layout::from_size_align_unchecked(
                    vec139.len() * 56,
                    8,
                );
                let result139 = if layout139.size() != 0 {
                    let ptr = alloc::alloc(layout139);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout139);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec139.into_iter().enumerate() {
                    let base = result139 as i32 + (i as i32) * 56;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaInsert(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaInsert {
                                    insert: insert97,
                                    attributes: attributes97,
                                } = e;
                                let vec98 = insert97;
                                let ptr98 = vec98.as_ptr() as i32;
                                let len98 = vec98.len() as i32;
                                *((base + 12) as *mut i32) = len98;
                                *((base + 8) as *mut i32) = ptr98;
                                match attributes97 {
                                    Some(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item99,
                                            array_references: array_references99,
                                            map_references: map_references99,
                                        } = e;
                                        match item99 {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                *((base + 24) as *mut u8) = (1i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (2i32) as u8;
                                                *((base + 32)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (3i32) as u8;
                                                *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (4i32) as u8;
                                                *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (5i32) as u8;
                                                let vec100 = e;
                                                let ptr100 = vec100.as_ptr() as i32;
                                                let len100 = vec100.len() as i32;
                                                *((base + 36) as *mut i32) = len100;
                                                *((base + 32) as *mut i32) = ptr100;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (6i32) as u8;
                                                let vec101 = e;
                                                let ptr101 = vec101.as_ptr() as i32;
                                                let len101 = vec101.len() as i32;
                                                *((base + 36) as *mut i32) = len101;
                                                *((base + 32) as *mut i32) = ptr101;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index102,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index102);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index103,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index103);
                                            }
                                        };
                                        let vec109 = array_references99;
                                        let len109 = vec109.len() as i32;
                                        let layout109 = alloc::Layout::from_size_align_unchecked(
                                            vec109.len() * 8,
                                            4,
                                        );
                                        let result109 = if layout109.size() != 0 {
                                            let ptr = alloc::alloc(layout109);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout109);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec109.into_iter().enumerate() {
                                            let base = result109 as i32 + (i as i32) * 8;
                                            {
                                                let vec108 = e;
                                                let len108 = vec108.len() as i32;
                                                let layout108 = alloc::Layout::from_size_align_unchecked(
                                                    vec108.len() * 16,
                                                    8,
                                                );
                                                let result108 = if layout108.size() != 0 {
                                                    let ptr = alloc::alloc(layout108);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout108);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec108.into_iter().enumerate() {
                                                    let base = result108 as i32 + (i as i32) * 16;
                                                    {
                                                        match e {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec104 = e;
                                                                let ptr104 = vec104.as_ptr() as i32;
                                                                let len104 = vec104.len() as i32;
                                                                *((base + 12) as *mut i32) = len104;
                                                                *((base + 8) as *mut i32) = ptr104;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec105 = e;
                                                                let ptr105 = vec105.as_ptr() as i32;
                                                                let len105 = vec105.len() as i32;
                                                                *((base + 12) as *mut i32) = len105;
                                                                *((base + 8) as *mut i32) = ptr105;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index106,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index106);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index107,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index107);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len108;
                                                *((base + 0) as *mut i32) = result108 as i32;
                                                cleanup_list.extend_from_slice(&[(result108, layout108)]);
                                            }
                                        }
                                        *((base + 44) as *mut i32) = len109;
                                        *((base + 40) as *mut i32) = result109 as i32;
                                        let vec117 = map_references99;
                                        let len117 = vec117.len() as i32;
                                        let layout117 = alloc::Layout::from_size_align_unchecked(
                                            vec117.len() * 8,
                                            4,
                                        );
                                        let result117 = if layout117.size() != 0 {
                                            let ptr = alloc::alloc(layout117);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout117);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec117.into_iter().enumerate() {
                                            let base = result117 as i32 + (i as i32) * 8;
                                            {
                                                let vec116 = e;
                                                let len116 = vec116.len() as i32;
                                                let layout116 = alloc::Layout::from_size_align_unchecked(
                                                    vec116.len() * 24,
                                                    8,
                                                );
                                                let result116 = if layout116.size() != 0 {
                                                    let ptr = alloc::alloc(layout116);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout116);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec116.into_iter().enumerate() {
                                                    let base = result116 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t110_0, t110_1) = e;
                                                        let vec111 = t110_0;
                                                        let ptr111 = vec111.as_ptr() as i32;
                                                        let len111 = vec111.len() as i32;
                                                        *((base + 4) as *mut i32) = len111;
                                                        *((base + 0) as *mut i32) = ptr111;
                                                        match t110_1 {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec112 = e;
                                                                let ptr112 = vec112.as_ptr() as i32;
                                                                let len112 = vec112.len() as i32;
                                                                *((base + 20) as *mut i32) = len112;
                                                                *((base + 16) as *mut i32) = ptr112;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec113 = e;
                                                                let ptr113 = vec113.as_ptr() as i32;
                                                                let len113 = vec113.len() as i32;
                                                                *((base + 20) as *mut i32) = len113;
                                                                *((base + 16) as *mut i32) = ptr113;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index114,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index114);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index115,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index115);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len116;
                                                *((base + 0) as *mut i32) = result116 as i32;
                                                cleanup_list.extend_from_slice(&[(result116, layout116)]);
                                            }
                                        }
                                        *((base + 52) as *mut i32) = len117;
                                        *((base + 48) as *mut i32) = result117 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result109, layout109), (result117, layout117)],
                                            );
                                    }
                                    None => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                    }
                                };
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaDelete(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaDelete {
                                    delete: delete118,
                                } = e;
                                *((base + 8)
                                    as *mut i32) = wit_bindgen::rt::as_i32(delete118);
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaRetain(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (2i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaRetain {
                                    retain: retain119,
                                    attributes: attributes119,
                                } = e;
                                *((base + 8)
                                    as *mut i32) = wit_bindgen::rt::as_i32(retain119);
                                match attributes119 {
                                    Some(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item120,
                                            array_references: array_references120,
                                            map_references: map_references120,
                                        } = e;
                                        match item120 {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                *((base + 24) as *mut u8) = (1i32) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (2i32) as u8;
                                                *((base + 32)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (3i32) as u8;
                                                *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (4i32) as u8;
                                                *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (5i32) as u8;
                                                let vec121 = e;
                                                let ptr121 = vec121.as_ptr() as i32;
                                                let len121 = vec121.len() as i32;
                                                *((base + 36) as *mut i32) = len121;
                                                *((base + 32) as *mut i32) = ptr121;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (6i32) as u8;
                                                let vec122 = e;
                                                let ptr122 = vec122.as_ptr() as i32;
                                                let len122 = vec122.len() as i32;
                                                *((base + 36) as *mut i32) = len122;
                                                *((base + 32) as *mut i32) = ptr122;
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index123,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index123);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index124,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index124);
                                            }
                                        };
                                        let vec130 = array_references120;
                                        let len130 = vec130.len() as i32;
                                        let layout130 = alloc::Layout::from_size_align_unchecked(
                                            vec130.len() * 8,
                                            4,
                                        );
                                        let result130 = if layout130.size() != 0 {
                                            let ptr = alloc::alloc(layout130);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout130);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec130.into_iter().enumerate() {
                                            let base = result130 as i32 + (i as i32) * 8;
                                            {
                                                let vec129 = e;
                                                let len129 = vec129.len() as i32;
                                                let layout129 = alloc::Layout::from_size_align_unchecked(
                                                    vec129.len() * 16,
                                                    8,
                                                );
                                                let result129 = if layout129.size() != 0 {
                                                    let ptr = alloc::alloc(layout129);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout129);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec129.into_iter().enumerate() {
                                                    let base = result129 as i32 + (i as i32) * 16;
                                                    {
                                                        match e {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec125 = e;
                                                                let ptr125 = vec125.as_ptr() as i32;
                                                                let len125 = vec125.len() as i32;
                                                                *((base + 12) as *mut i32) = len125;
                                                                *((base + 8) as *mut i32) = ptr125;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec126 = e;
                                                                let ptr126 = vec126.as_ptr() as i32;
                                                                let len126 = vec126.len() as i32;
                                                                *((base + 12) as *mut i32) = len126;
                                                                *((base + 8) as *mut i32) = ptr126;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index127,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index127);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index128,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index128);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len129;
                                                *((base + 0) as *mut i32) = result129 as i32;
                                                cleanup_list.extend_from_slice(&[(result129, layout129)]);
                                            }
                                        }
                                        *((base + 44) as *mut i32) = len130;
                                        *((base + 40) as *mut i32) = result130 as i32;
                                        let vec138 = map_references120;
                                        let len138 = vec138.len() as i32;
                                        let layout138 = alloc::Layout::from_size_align_unchecked(
                                            vec138.len() * 8,
                                            4,
                                        );
                                        let result138 = if layout138.size() != 0 {
                                            let ptr = alloc::alloc(layout138);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout138);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec138.into_iter().enumerate() {
                                            let base = result138 as i32 + (i as i32) * 8;
                                            {
                                                let vec137 = e;
                                                let len137 = vec137.len() as i32;
                                                let layout137 = alloc::Layout::from_size_align_unchecked(
                                                    vec137.len() * 24,
                                                    8,
                                                );
                                                let result137 = if layout137.size() != 0 {
                                                    let ptr = alloc::alloc(layout137);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout137);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec137.into_iter().enumerate() {
                                                    let base = result137 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t131_0, t131_1) = e;
                                                        let vec132 = t131_0;
                                                        let ptr132 = vec132.as_ptr() as i32;
                                                        let len132 = vec132.len() as i32;
                                                        *((base + 4) as *mut i32) = len132;
                                                        *((base + 0) as *mut i32) = ptr132;
                                                        match t131_1 {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec133 = e;
                                                                let ptr133 = vec133.as_ptr() as i32;
                                                                let len133 = vec133.len() as i32;
                                                                *((base + 20) as *mut i32) = len133;
                                                                *((base + 16) as *mut i32) = ptr133;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec134 = e;
                                                                let ptr134 = vec134.as_ptr() as i32;
                                                                let len134 = vec134.len() as i32;
                                                                *((base + 20) as *mut i32) = len134;
                                                                *((base + 16) as *mut i32) = ptr134;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index135,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index135);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index136,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index136);
                                                            }
                                                        };
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len137;
                                                *((base + 0) as *mut i32) = result137 as i32;
                                                cleanup_list.extend_from_slice(&[(result137, layout137)]);
                                            }
                                        }
                                        *((base + 52) as *mut i32) = len138;
                                        *((base + 48) as *mut i32) = result138 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result130, layout130), (result138, layout138)],
                                            );
                                    }
                                    None => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                    }
                                };
                            }
                        };
                    }
                }
                let vec141 = path95;
                let len141 = vec141.len() as i32;
                let layout141 = alloc::Layout::from_size_align_unchecked(
                    vec141.len() * 12,
                    4,
                );
                let result141 = if layout141.size() != 0 {
                    let ptr = alloc::alloc(layout141);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout141);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec141.into_iter().enumerate() {
                    let base = result141 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let vec140 = e;
                                let ptr140 = vec140.as_ptr() as i32;
                                let len140 = vec140.len() as i32;
                                *((base + 8) as *mut i32) = len140;
                                *((base + 4) as *mut i32) = ptr140;
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            }
                        };
                    }
                }
                cleanup_list
                    .extend_from_slice(
                        &[(result139, layout139), (result141, layout141)],
                    );
                (
                    2i32,
                    wit_bindgen::rt::as_i32(ref_96),
                    result139 as i32,
                    len139,
                    result141 as i32,
                    len141,
                )
            }
        };
        #[link(wasm_import_module = "$root")]
        extern "C" {
            #[link_name = "$root_event-callback"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
        }
        wit_import(
            wit_bindgen::rt::as_i32(function_id),
            result142_0,
            result142_1,
            result142_2,
            result142_3,
            result142_4,
            result142_5,
        );
        for (ptr, layout) in cleanup_list {
            if layout.size() != 0 {
                alloc::dealloc(ptr, layout);
            }
        }
    }
}
#[allow(clippy::all)]
pub fn event_deep_callback(function_id: u32, event: &[YEvent<'_>]) {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    unsafe {
        let mut cleanup_list = Vec::new();
        let vec142 = event;
        let len142 = vec142.len() as i32;
        let layout142 = alloc::Layout::from_size_align_unchecked(vec142.len() * 24, 4);
        let result142 = if layout142.size() != 0 {
            let ptr = alloc::alloc(layout142);
            if ptr.is_null() {
                alloc::handle_alloc_error(layout142);
            }
            ptr
        } else {
            ::core::ptr::null_mut()
        };
        for (i, e) in vec142.into_iter().enumerate() {
            let base = result142 as i32 + (i as i32) * 24;
            {
                match e {
                    y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YArrayEvent(
                        e,
                    ) => {
                        *((base + 0) as *mut u8) = (0i32) as u8;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayEvent {
                            target: target0,
                            delta: delta0,
                            path: path0,
                        } = e;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: ref_1,
                        } = target0;
                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_1);
                        let vec32 = delta0;
                        let len32 = vec32.len() as i32;
                        let layout32 = alloc::Layout::from_size_align_unchecked(
                            vec32.len() * 12,
                            4,
                        );
                        let result32 = if layout32.size() != 0 {
                            let ptr = alloc::alloc(layout32);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout32);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec32.into_iter().enumerate() {
                            let base = result32 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaInsert(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaInsert {
                                            insert: insert2,
                                        } = e;
                                        let vec29 = insert2;
                                        let len29 = vec29.len() as i32;
                                        let layout29 = alloc::Layout::from_size_align_unchecked(
                                            vec29.len() * 40,
                                            8,
                                        );
                                        let result29 = if layout29.size() != 0 {
                                            let ptr = alloc::alloc(layout29);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout29);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec29.into_iter().enumerate() {
                                            let base = result29 as i32 + (i as i32) * 40;
                                            {
                                                match e {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                            item: item3,
                                                            array_references: array_references3,
                                                            map_references: map_references3,
                                                        } = e;
                                                        match item3 {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec4 = e;
                                                                let ptr4 = vec4.as_ptr() as i32;
                                                                let len4 = vec4.len() as i32;
                                                                *((base + 20) as *mut i32) = len4;
                                                                *((base + 16) as *mut i32) = ptr4;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec5 = e;
                                                                let ptr5 = vec5.as_ptr() as i32;
                                                                let len5 = vec5.len() as i32;
                                                                *((base + 20) as *mut i32) = len5;
                                                                *((base + 16) as *mut i32) = ptr5;
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index6,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index7,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                                            }
                                                        };
                                                        let vec13 = array_references3;
                                                        let len13 = vec13.len() as i32;
                                                        let layout13 = alloc::Layout::from_size_align_unchecked(
                                                            vec13.len() * 8,
                                                            4,
                                                        );
                                                        let result13 = if layout13.size() != 0 {
                                                            let ptr = alloc::alloc(layout13);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout13);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec13.into_iter().enumerate() {
                                                            let base = result13 as i32 + (i as i32) * 8;
                                                            {
                                                                let vec12 = e;
                                                                let len12 = vec12.len() as i32;
                                                                let layout12 = alloc::Layout::from_size_align_unchecked(
                                                                    vec12.len() * 16,
                                                                    8,
                                                                );
                                                                let result12 = if layout12.size() != 0 {
                                                                    let ptr = alloc::alloc(layout12);
                                                                    if ptr.is_null() {
                                                                        alloc::handle_alloc_error(layout12);
                                                                    }
                                                                    ptr
                                                                } else {
                                                                    ::core::ptr::null_mut()
                                                                };
                                                                for (i, e) in vec12.into_iter().enumerate() {
                                                                    let base = result12 as i32 + (i as i32) * 16;
                                                                    {
                                                                        match e {
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                                *((base + 8)
                                                                                    as *mut u8) = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                                let vec8 = e;
                                                                                let ptr8 = vec8.as_ptr() as i32;
                                                                                let len8 = vec8.len() as i32;
                                                                                *((base + 12) as *mut i32) = len8;
                                                                                *((base + 8) as *mut i32) = ptr8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                                let vec9 = e;
                                                                                let ptr9 = vec9.as_ptr() as i32;
                                                                                let len9 = vec9.len() as i32;
                                                                                *((base + 12) as *mut i32) = len9;
                                                                                *((base + 8) as *mut i32) = ptr9;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: index10,
                                                                                } = e;
                                                                                *((base + 8)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: index11,
                                                                                } = e;
                                                                                *((base + 8)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                                            }
                                                                        };
                                                                    }
                                                                }
                                                                *((base + 4) as *mut i32) = len12;
                                                                *((base + 0) as *mut i32) = result12 as i32;
                                                                cleanup_list.extend_from_slice(&[(result12, layout12)]);
                                                            }
                                                        }
                                                        *((base + 28) as *mut i32) = len13;
                                                        *((base + 24) as *mut i32) = result13 as i32;
                                                        let vec21 = map_references3;
                                                        let len21 = vec21.len() as i32;
                                                        let layout21 = alloc::Layout::from_size_align_unchecked(
                                                            vec21.len() * 8,
                                                            4,
                                                        );
                                                        let result21 = if layout21.size() != 0 {
                                                            let ptr = alloc::alloc(layout21);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout21);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec21.into_iter().enumerate() {
                                                            let base = result21 as i32 + (i as i32) * 8;
                                                            {
                                                                let vec20 = e;
                                                                let len20 = vec20.len() as i32;
                                                                let layout20 = alloc::Layout::from_size_align_unchecked(
                                                                    vec20.len() * 24,
                                                                    8,
                                                                );
                                                                let result20 = if layout20.size() != 0 {
                                                                    let ptr = alloc::alloc(layout20);
                                                                    if ptr.is_null() {
                                                                        alloc::handle_alloc_error(layout20);
                                                                    }
                                                                    ptr
                                                                } else {
                                                                    ::core::ptr::null_mut()
                                                                };
                                                                for (i, e) in vec20.into_iter().enumerate() {
                                                                    let base = result20 as i32 + (i as i32) * 24;
                                                                    {
                                                                        let (t14_0, t14_1) = e;
                                                                        let vec15 = t14_0;
                                                                        let ptr15 = vec15.as_ptr() as i32;
                                                                        let len15 = vec15.len() as i32;
                                                                        *((base + 4) as *mut i32) = len15;
                                                                        *((base + 0) as *mut i32) = ptr15;
                                                                        match t14_1 {
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                                *((base + 16)
                                                                                    as *mut u8) = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                                let vec16 = e;
                                                                                let ptr16 = vec16.as_ptr() as i32;
                                                                                let len16 = vec16.len() as i32;
                                                                                *((base + 20) as *mut i32) = len16;
                                                                                *((base + 16) as *mut i32) = ptr16;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                                let vec17 = e;
                                                                                let ptr17 = vec17.as_ptr() as i32;
                                                                                let len17 = vec17.len() as i32;
                                                                                *((base + 20) as *mut i32) = len17;
                                                                                *((base + 16) as *mut i32) = ptr17;
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: index18,
                                                                                } = e;
                                                                                *((base + 16)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                                                            }
                                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                                e,
                                                                            ) => {
                                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: index19,
                                                                                } = e;
                                                                                *((base + 16)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index19);
                                                                            }
                                                                        };
                                                                    }
                                                                }
                                                                *((base + 4) as *mut i32) = len20;
                                                                *((base + 0) as *mut i32) = result20 as i32;
                                                                cleanup_list.extend_from_slice(&[(result20, layout20)]);
                                                            }
                                                        }
                                                        *((base + 36) as *mut i32) = len21;
                                                        *((base + 32) as *mut i32) = result21 as i32;
                                                        cleanup_list
                                                            .extend_from_slice(
                                                                &[(result13, layout13), (result21, layout21)],
                                                            );
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                            ref_: ref_22,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_22);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                            ref_: ref_23,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_23);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                            ref_: ref_24,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_24);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                            ref_: ref_25,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                            ref_: ref_26,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                            ref_: ref_27,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                            ref_: ref_28,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                                    }
                                                };
                                            }
                                        }
                                        *((base + 8) as *mut i32) = len29;
                                        *((base + 4) as *mut i32) = result29 as i32;
                                        cleanup_list.extend_from_slice(&[(result29, layout29)]);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaDelete(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaDelete {
                                            delete: delete30,
                                        } = e;
                                        *((base + 4)
                                            as *mut i32) = wit_bindgen::rt::as_i32(delete30);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaRetain(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaRetain {
                                            retain: retain31,
                                        } = e;
                                        *((base + 4)
                                            as *mut i32) = wit_bindgen::rt::as_i32(retain31);
                                    }
                                };
                            }
                        }
                        *((base + 12) as *mut i32) = len32;
                        *((base + 8) as *mut i32) = result32 as i32;
                        let vec34 = path0;
                        let len34 = vec34.len() as i32;
                        let layout34 = alloc::Layout::from_size_align_unchecked(
                            vec34.len() * 12,
                            4,
                        );
                        let result34 = if layout34.size() != 0 {
                            let ptr = alloc::alloc(layout34);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout34);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec34.into_iter().enumerate() {
                            let base = result34 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let vec33 = e;
                                        let ptr33 = vec33.as_ptr() as i32;
                                        let len33 = vec33.len() as i32;
                                        *((base + 8) as *mut i32) = len33;
                                        *((base + 4) as *mut i32) = ptr33;
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    }
                                };
                            }
                        }
                        *((base + 20) as *mut i32) = len34;
                        *((base + 16) as *mut i32) = result34 as i32;
                        cleanup_list
                            .extend_from_slice(
                                &[(result32, layout32), (result34, layout34)],
                            );
                    }
                    y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YMapEvent(
                        e,
                    ) => {
                        *((base + 0) as *mut u8) = (1i32) as u8;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapEvent {
                            target: target35,
                            keys: keys35,
                            path: path35,
                        } = e;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: ref_36,
                        } = target35;
                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_36);
                        let vec92 = keys35;
                        let len92 = vec92.len() as i32;
                        let layout92 = alloc::Layout::from_size_align_unchecked(
                            vec92.len() * 112,
                            8,
                        );
                        let result92 = if layout92.size() != 0 {
                            let ptr = alloc::alloc(layout92);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout92);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec92.into_iter().enumerate() {
                            let base = result92 as i32 + (i as i32) * 112;
                            {
                                let (t37_0, t37_1) = e;
                                let vec38 = t37_0;
                                let ptr38 = vec38.as_ptr() as i32;
                                let len38 = vec38.len() as i32;
                                *((base + 4) as *mut i32) = len38;
                                *((base + 0) as *mut i32) = ptr38;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDelta {
                                    action: action39,
                                    old_value: old_value39,
                                    new_value: new_value39,
                                } = t37_1;
                                *((base + 8)
                                    as *mut u8) = (match action39 {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDeltaAction::Insert => {
                                        0
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDeltaAction::Update => {
                                        1
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDeltaAction::Delete => {
                                        2
                                    }
                                }) as u8;
                                match old_value39 {
                                    Some(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item40,
                                                    array_references: array_references40,
                                                    map_references: map_references40,
                                                } = e;
                                                match item40 {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                        *((base + 32) as *mut u8) = (0i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                        *((base + 32) as *mut u8) = (1i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (2i32) as u8;
                                                        *((base + 40)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (3i32) as u8;
                                                        *((base + 40) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (4i32) as u8;
                                                        *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (5i32) as u8;
                                                        let vec41 = e;
                                                        let ptr41 = vec41.as_ptr() as i32;
                                                        let len41 = vec41.len() as i32;
                                                        *((base + 44) as *mut i32) = len41;
                                                        *((base + 40) as *mut i32) = ptr41;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (6i32) as u8;
                                                        let vec42 = e;
                                                        let ptr42 = vec42.as_ptr() as i32;
                                                        let len42 = vec42.len() as i32;
                                                        *((base + 44) as *mut i32) = len42;
                                                        *((base + 40) as *mut i32) = ptr42;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index43,
                                                        } = e;
                                                        *((base + 40)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index43);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index44,
                                                        } = e;
                                                        *((base + 40)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index44);
                                                    }
                                                };
                                                let vec50 = array_references40;
                                                let len50 = vec50.len() as i32;
                                                let layout50 = alloc::Layout::from_size_align_unchecked(
                                                    vec50.len() * 8,
                                                    4,
                                                );
                                                let result50 = if layout50.size() != 0 {
                                                    let ptr = alloc::alloc(layout50);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout50);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec50.into_iter().enumerate() {
                                                    let base = result50 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec49 = e;
                                                        let len49 = vec49.len() as i32;
                                                        let layout49 = alloc::Layout::from_size_align_unchecked(
                                                            vec49.len() * 16,
                                                            8,
                                                        );
                                                        let result49 = if layout49.size() != 0 {
                                                            let ptr = alloc::alloc(layout49);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout49);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec49.into_iter().enumerate() {
                                                            let base = result49 as i32 + (i as i32) * 16;
                                                            {
                                                                match e {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec45 = e;
                                                                        let ptr45 = vec45.as_ptr() as i32;
                                                                        let len45 = vec45.len() as i32;
                                                                        *((base + 12) as *mut i32) = len45;
                                                                        *((base + 8) as *mut i32) = ptr45;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec46 = e;
                                                                        let ptr46 = vec46.as_ptr() as i32;
                                                                        let len46 = vec46.len() as i32;
                                                                        *((base + 12) as *mut i32) = len46;
                                                                        *((base + 8) as *mut i32) = ptr46;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index47,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index47);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index48,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index48);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len49;
                                                        *((base + 0) as *mut i32) = result49 as i32;
                                                        cleanup_list.extend_from_slice(&[(result49, layout49)]);
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len50;
                                                *((base + 48) as *mut i32) = result50 as i32;
                                                let vec58 = map_references40;
                                                let len58 = vec58.len() as i32;
                                                let layout58 = alloc::Layout::from_size_align_unchecked(
                                                    vec58.len() * 8,
                                                    4,
                                                );
                                                let result58 = if layout58.size() != 0 {
                                                    let ptr = alloc::alloc(layout58);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout58);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec58.into_iter().enumerate() {
                                                    let base = result58 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec57 = e;
                                                        let len57 = vec57.len() as i32;
                                                        let layout57 = alloc::Layout::from_size_align_unchecked(
                                                            vec57.len() * 24,
                                                            8,
                                                        );
                                                        let result57 = if layout57.size() != 0 {
                                                            let ptr = alloc::alloc(layout57);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout57);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec57.into_iter().enumerate() {
                                                            let base = result57 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t51_0, t51_1) = e;
                                                                let vec52 = t51_0;
                                                                let ptr52 = vec52.as_ptr() as i32;
                                                                let len52 = vec52.len() as i32;
                                                                *((base + 4) as *mut i32) = len52;
                                                                *((base + 0) as *mut i32) = ptr52;
                                                                match t51_1 {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec53 = e;
                                                                        let ptr53 = vec53.as_ptr() as i32;
                                                                        let len53 = vec53.len() as i32;
                                                                        *((base + 20) as *mut i32) = len53;
                                                                        *((base + 16) as *mut i32) = ptr53;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec54 = e;
                                                                        let ptr54 = vec54.as_ptr() as i32;
                                                                        let len54 = vec54.len() as i32;
                                                                        *((base + 20) as *mut i32) = len54;
                                                                        *((base + 16) as *mut i32) = ptr54;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index55,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index55);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index56,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index56);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len57;
                                                        *((base + 0) as *mut i32) = result57 as i32;
                                                        cleanup_list.extend_from_slice(&[(result57, layout57)]);
                                                    }
                                                }
                                                *((base + 60) as *mut i32) = len58;
                                                *((base + 56) as *mut i32) = result58 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result50, layout50), (result58, layout58)],
                                                    );
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_59,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_59);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (2i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_60,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_60);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (3i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_61,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_61);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (4i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_62,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_62);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (5i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_63,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_63);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (6i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_64,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_64);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                    ref_: ref_65,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_65);
                                            }
                                        };
                                    }
                                    None => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                    }
                                };
                                match new_value39 {
                                    Some(e) => {
                                        *((base + 64) as *mut u8) = (1i32) as u8;
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item66,
                                                    array_references: array_references66,
                                                    map_references: map_references66,
                                                } = e;
                                                match item66 {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                        *((base + 80) as *mut u8) = (0i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                        *((base + 80) as *mut u8) = (1i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (2i32) as u8;
                                                        *((base + 88)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (3i32) as u8;
                                                        *((base + 88) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (4i32) as u8;
                                                        *((base + 88) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (5i32) as u8;
                                                        let vec67 = e;
                                                        let ptr67 = vec67.as_ptr() as i32;
                                                        let len67 = vec67.len() as i32;
                                                        *((base + 92) as *mut i32) = len67;
                                                        *((base + 88) as *mut i32) = ptr67;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (6i32) as u8;
                                                        let vec68 = e;
                                                        let ptr68 = vec68.as_ptr() as i32;
                                                        let len68 = vec68.len() as i32;
                                                        *((base + 92) as *mut i32) = len68;
                                                        *((base + 88) as *mut i32) = ptr68;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index69,
                                                        } = e;
                                                        *((base + 88)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index69);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index70,
                                                        } = e;
                                                        *((base + 88)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index70);
                                                    }
                                                };
                                                let vec76 = array_references66;
                                                let len76 = vec76.len() as i32;
                                                let layout76 = alloc::Layout::from_size_align_unchecked(
                                                    vec76.len() * 8,
                                                    4,
                                                );
                                                let result76 = if layout76.size() != 0 {
                                                    let ptr = alloc::alloc(layout76);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout76);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec76.into_iter().enumerate() {
                                                    let base = result76 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec75 = e;
                                                        let len75 = vec75.len() as i32;
                                                        let layout75 = alloc::Layout::from_size_align_unchecked(
                                                            vec75.len() * 16,
                                                            8,
                                                        );
                                                        let result75 = if layout75.size() != 0 {
                                                            let ptr = alloc::alloc(layout75);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout75);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec75.into_iter().enumerate() {
                                                            let base = result75 as i32 + (i as i32) * 16;
                                                            {
                                                                match e {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec71 = e;
                                                                        let ptr71 = vec71.as_ptr() as i32;
                                                                        let len71 = vec71.len() as i32;
                                                                        *((base + 12) as *mut i32) = len71;
                                                                        *((base + 8) as *mut i32) = ptr71;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec72 = e;
                                                                        let ptr72 = vec72.as_ptr() as i32;
                                                                        let len72 = vec72.len() as i32;
                                                                        *((base + 12) as *mut i32) = len72;
                                                                        *((base + 8) as *mut i32) = ptr72;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index73,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index73);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index74,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index74);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len75;
                                                        *((base + 0) as *mut i32) = result75 as i32;
                                                        cleanup_list.extend_from_slice(&[(result75, layout75)]);
                                                    }
                                                }
                                                *((base + 100) as *mut i32) = len76;
                                                *((base + 96) as *mut i32) = result76 as i32;
                                                let vec84 = map_references66;
                                                let len84 = vec84.len() as i32;
                                                let layout84 = alloc::Layout::from_size_align_unchecked(
                                                    vec84.len() * 8,
                                                    4,
                                                );
                                                let result84 = if layout84.size() != 0 {
                                                    let ptr = alloc::alloc(layout84);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout84);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec84.into_iter().enumerate() {
                                                    let base = result84 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec83 = e;
                                                        let len83 = vec83.len() as i32;
                                                        let layout83 = alloc::Layout::from_size_align_unchecked(
                                                            vec83.len() * 24,
                                                            8,
                                                        );
                                                        let result83 = if layout83.size() != 0 {
                                                            let ptr = alloc::alloc(layout83);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout83);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec83.into_iter().enumerate() {
                                                            let base = result83 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t77_0, t77_1) = e;
                                                                let vec78 = t77_0;
                                                                let ptr78 = vec78.as_ptr() as i32;
                                                                let len78 = vec78.len() as i32;
                                                                *((base + 4) as *mut i32) = len78;
                                                                *((base + 0) as *mut i32) = ptr78;
                                                                match t77_1 {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec79 = e;
                                                                        let ptr79 = vec79.as_ptr() as i32;
                                                                        let len79 = vec79.len() as i32;
                                                                        *((base + 20) as *mut i32) = len79;
                                                                        *((base + 16) as *mut i32) = ptr79;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec80 = e;
                                                                        let ptr80 = vec80.as_ptr() as i32;
                                                                        let len80 = vec80.len() as i32;
                                                                        *((base + 20) as *mut i32) = len80;
                                                                        *((base + 16) as *mut i32) = ptr80;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index81,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index81);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index82,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index82);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len83;
                                                        *((base + 0) as *mut i32) = result83 as i32;
                                                        cleanup_list.extend_from_slice(&[(result83, layout83)]);
                                                    }
                                                }
                                                *((base + 108) as *mut i32) = len84;
                                                *((base + 104) as *mut i32) = result84 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result76, layout76), (result84, layout84)],
                                                    );
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_85,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_85);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (2i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_86,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_86);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (3i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_87,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_87);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (4i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_88,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_88);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (5i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_89,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_89);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (6i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_90,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_90);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                    ref_: ref_91,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_91);
                                            }
                                        };
                                    }
                                    None => {
                                        *((base + 64) as *mut u8) = (0i32) as u8;
                                    }
                                };
                            }
                        }
                        *((base + 12) as *mut i32) = len92;
                        *((base + 8) as *mut i32) = result92 as i32;
                        let vec94 = path35;
                        let len94 = vec94.len() as i32;
                        let layout94 = alloc::Layout::from_size_align_unchecked(
                            vec94.len() * 12,
                            4,
                        );
                        let result94 = if layout94.size() != 0 {
                            let ptr = alloc::alloc(layout94);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout94);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec94.into_iter().enumerate() {
                            let base = result94 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let vec93 = e;
                                        let ptr93 = vec93.as_ptr() as i32;
                                        let len93 = vec93.len() as i32;
                                        *((base + 8) as *mut i32) = len93;
                                        *((base + 4) as *mut i32) = ptr93;
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    }
                                };
                            }
                        }
                        *((base + 20) as *mut i32) = len94;
                        *((base + 16) as *mut i32) = result94 as i32;
                        cleanup_list
                            .extend_from_slice(
                                &[(result92, layout92), (result94, layout94)],
                            );
                    }
                    y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YTextEvent(
                        e,
                    ) => {
                        *((base + 0) as *mut u8) = (2i32) as u8;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextEvent {
                            target: target95,
                            delta: delta95,
                            path: path95,
                        } = e;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: ref_96,
                        } = target95;
                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_96);
                        let vec139 = delta95;
                        let len139 = vec139.len() as i32;
                        let layout139 = alloc::Layout::from_size_align_unchecked(
                            vec139.len() * 56,
                            8,
                        );
                        let result139 = if layout139.size() != 0 {
                            let ptr = alloc::alloc(layout139);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout139);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec139.into_iter().enumerate() {
                            let base = result139 as i32 + (i as i32) * 56;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaInsert(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaInsert {
                                            insert: insert97,
                                            attributes: attributes97,
                                        } = e;
                                        let vec98 = insert97;
                                        let ptr98 = vec98.as_ptr() as i32;
                                        let len98 = vec98.len() as i32;
                                        *((base + 12) as *mut i32) = len98;
                                        *((base + 8) as *mut i32) = ptr98;
                                        match attributes97 {
                                            Some(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item99,
                                                    array_references: array_references99,
                                                    map_references: map_references99,
                                                } = e;
                                                match item99 {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                                        *((base + 32)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                                        let vec100 = e;
                                                        let ptr100 = vec100.as_ptr() as i32;
                                                        let len100 = vec100.len() as i32;
                                                        *((base + 36) as *mut i32) = len100;
                                                        *((base + 32) as *mut i32) = ptr100;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                                        let vec101 = e;
                                                        let ptr101 = vec101.as_ptr() as i32;
                                                        let len101 = vec101.len() as i32;
                                                        *((base + 36) as *mut i32) = len101;
                                                        *((base + 32) as *mut i32) = ptr101;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index102,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index102);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index103,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index103);
                                                    }
                                                };
                                                let vec109 = array_references99;
                                                let len109 = vec109.len() as i32;
                                                let layout109 = alloc::Layout::from_size_align_unchecked(
                                                    vec109.len() * 8,
                                                    4,
                                                );
                                                let result109 = if layout109.size() != 0 {
                                                    let ptr = alloc::alloc(layout109);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout109);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec109.into_iter().enumerate() {
                                                    let base = result109 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec108 = e;
                                                        let len108 = vec108.len() as i32;
                                                        let layout108 = alloc::Layout::from_size_align_unchecked(
                                                            vec108.len() * 16,
                                                            8,
                                                        );
                                                        let result108 = if layout108.size() != 0 {
                                                            let ptr = alloc::alloc(layout108);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout108);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec108.into_iter().enumerate() {
                                                            let base = result108 as i32 + (i as i32) * 16;
                                                            {
                                                                match e {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec104 = e;
                                                                        let ptr104 = vec104.as_ptr() as i32;
                                                                        let len104 = vec104.len() as i32;
                                                                        *((base + 12) as *mut i32) = len104;
                                                                        *((base + 8) as *mut i32) = ptr104;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec105 = e;
                                                                        let ptr105 = vec105.as_ptr() as i32;
                                                                        let len105 = vec105.len() as i32;
                                                                        *((base + 12) as *mut i32) = len105;
                                                                        *((base + 8) as *mut i32) = ptr105;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index106,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index106);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index107,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index107);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len108;
                                                        *((base + 0) as *mut i32) = result108 as i32;
                                                        cleanup_list.extend_from_slice(&[(result108, layout108)]);
                                                    }
                                                }
                                                *((base + 44) as *mut i32) = len109;
                                                *((base + 40) as *mut i32) = result109 as i32;
                                                let vec117 = map_references99;
                                                let len117 = vec117.len() as i32;
                                                let layout117 = alloc::Layout::from_size_align_unchecked(
                                                    vec117.len() * 8,
                                                    4,
                                                );
                                                let result117 = if layout117.size() != 0 {
                                                    let ptr = alloc::alloc(layout117);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout117);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec117.into_iter().enumerate() {
                                                    let base = result117 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec116 = e;
                                                        let len116 = vec116.len() as i32;
                                                        let layout116 = alloc::Layout::from_size_align_unchecked(
                                                            vec116.len() * 24,
                                                            8,
                                                        );
                                                        let result116 = if layout116.size() != 0 {
                                                            let ptr = alloc::alloc(layout116);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout116);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec116.into_iter().enumerate() {
                                                            let base = result116 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t110_0, t110_1) = e;
                                                                let vec111 = t110_0;
                                                                let ptr111 = vec111.as_ptr() as i32;
                                                                let len111 = vec111.len() as i32;
                                                                *((base + 4) as *mut i32) = len111;
                                                                *((base + 0) as *mut i32) = ptr111;
                                                                match t110_1 {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec112 = e;
                                                                        let ptr112 = vec112.as_ptr() as i32;
                                                                        let len112 = vec112.len() as i32;
                                                                        *((base + 20) as *mut i32) = len112;
                                                                        *((base + 16) as *mut i32) = ptr112;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec113 = e;
                                                                        let ptr113 = vec113.as_ptr() as i32;
                                                                        let len113 = vec113.len() as i32;
                                                                        *((base + 20) as *mut i32) = len113;
                                                                        *((base + 16) as *mut i32) = ptr113;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index114,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index114);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index115,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index115);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len116;
                                                        *((base + 0) as *mut i32) = result116 as i32;
                                                        cleanup_list.extend_from_slice(&[(result116, layout116)]);
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len117;
                                                *((base + 48) as *mut i32) = result117 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result109, layout109), (result117, layout117)],
                                                    );
                                            }
                                            None => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                        };
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaDelete(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaDelete {
                                            delete: delete118,
                                        } = e;
                                        *((base + 8)
                                            as *mut i32) = wit_bindgen::rt::as_i32(delete118);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaRetain(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaRetain {
                                            retain: retain119,
                                            attributes: attributes119,
                                        } = e;
                                        *((base + 8)
                                            as *mut i32) = wit_bindgen::rt::as_i32(retain119);
                                        match attributes119 {
                                            Some(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item120,
                                                    array_references: array_references120,
                                                    map_references: map_references120,
                                                } = e;
                                                match item120 {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                                        *((base + 32)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                                        let vec121 = e;
                                                        let ptr121 = vec121.as_ptr() as i32;
                                                        let len121 = vec121.len() as i32;
                                                        *((base + 36) as *mut i32) = len121;
                                                        *((base + 32) as *mut i32) = ptr121;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                                        let vec122 = e;
                                                        let ptr122 = vec122.as_ptr() as i32;
                                                        let len122 = vec122.len() as i32;
                                                        *((base + 36) as *mut i32) = len122;
                                                        *((base + 32) as *mut i32) = ptr122;
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index123,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index123);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                        e,
                                                    ) => {
                                                        *((base + 24) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index124,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index124);
                                                    }
                                                };
                                                let vec130 = array_references120;
                                                let len130 = vec130.len() as i32;
                                                let layout130 = alloc::Layout::from_size_align_unchecked(
                                                    vec130.len() * 8,
                                                    4,
                                                );
                                                let result130 = if layout130.size() != 0 {
                                                    let ptr = alloc::alloc(layout130);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout130);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec130.into_iter().enumerate() {
                                                    let base = result130 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec129 = e;
                                                        let len129 = vec129.len() as i32;
                                                        let layout129 = alloc::Layout::from_size_align_unchecked(
                                                            vec129.len() * 16,
                                                            8,
                                                        );
                                                        let result129 = if layout129.size() != 0 {
                                                            let ptr = alloc::alloc(layout129);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout129);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec129.into_iter().enumerate() {
                                                            let base = result129 as i32 + (i as i32) * 16;
                                                            {
                                                                match e {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec125 = e;
                                                                        let ptr125 = vec125.as_ptr() as i32;
                                                                        let len125 = vec125.len() as i32;
                                                                        *((base + 12) as *mut i32) = len125;
                                                                        *((base + 8) as *mut i32) = ptr125;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec126 = e;
                                                                        let ptr126 = vec126.as_ptr() as i32;
                                                                        let len126 = vec126.len() as i32;
                                                                        *((base + 12) as *mut i32) = len126;
                                                                        *((base + 8) as *mut i32) = ptr126;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index127,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index127);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index128,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index128);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len129;
                                                        *((base + 0) as *mut i32) = result129 as i32;
                                                        cleanup_list.extend_from_slice(&[(result129, layout129)]);
                                                    }
                                                }
                                                *((base + 44) as *mut i32) = len130;
                                                *((base + 40) as *mut i32) = result130 as i32;
                                                let vec138 = map_references120;
                                                let len138 = vec138.len() as i32;
                                                let layout138 = alloc::Layout::from_size_align_unchecked(
                                                    vec138.len() * 8,
                                                    4,
                                                );
                                                let result138 = if layout138.size() != 0 {
                                                    let ptr = alloc::alloc(layout138);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout138);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec138.into_iter().enumerate() {
                                                    let base = result138 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec137 = e;
                                                        let len137 = vec137.len() as i32;
                                                        let layout137 = alloc::Layout::from_size_align_unchecked(
                                                            vec137.len() * 24,
                                                            8,
                                                        );
                                                        let result137 = if layout137.size() != 0 {
                                                            let ptr = alloc::alloc(layout137);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout137);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec137.into_iter().enumerate() {
                                                            let base = result137 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t131_0, t131_1) = e;
                                                                let vec132 = t131_0;
                                                                let ptr132 = vec132.as_ptr() as i32;
                                                                let len132 = vec132.len() as i32;
                                                                *((base + 4) as *mut i32) = len132;
                                                                *((base + 0) as *mut i32) = ptr132;
                                                                match t131_1 {
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec133 = e;
                                                                        let ptr133 = vec133.as_ptr() as i32;
                                                                        let len133 = vec133.len() as i32;
                                                                        *((base + 20) as *mut i32) = len133;
                                                                        *((base + 16) as *mut i32) = ptr133;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec134 = e;
                                                                        let ptr134 = vec134.as_ptr() as i32;
                                                                        let len134 = vec134.len() as i32;
                                                                        *((base + 20) as *mut i32) = len134;
                                                                        *((base + 16) as *mut i32) = ptr134;
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index135,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index135);
                                                                    }
                                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                        e,
                                                                    ) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index136,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index136);
                                                                    }
                                                                };
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len137;
                                                        *((base + 0) as *mut i32) = result137 as i32;
                                                        cleanup_list.extend_from_slice(&[(result137, layout137)]);
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len138;
                                                *((base + 48) as *mut i32) = result138 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result130, layout130), (result138, layout138)],
                                                    );
                                            }
                                            None => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                        };
                                    }
                                };
                            }
                        }
                        *((base + 12) as *mut i32) = len139;
                        *((base + 8) as *mut i32) = result139 as i32;
                        let vec141 = path95;
                        let len141 = vec141.len() as i32;
                        let layout141 = alloc::Layout::from_size_align_unchecked(
                            vec141.len() * 12,
                            4,
                        );
                        let result141 = if layout141.size() != 0 {
                            let ptr = alloc::alloc(layout141);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout141);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec141.into_iter().enumerate() {
                            let base = result141 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let vec140 = e;
                                        let ptr140 = vec140.as_ptr() as i32;
                                        let len140 = vec140.len() as i32;
                                        *((base + 8) as *mut i32) = len140;
                                        *((base + 4) as *mut i32) = ptr140;
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    }
                                };
                            }
                        }
                        *((base + 20) as *mut i32) = len141;
                        *((base + 16) as *mut i32) = result141 as i32;
                        cleanup_list
                            .extend_from_slice(
                                &[(result139, layout139), (result141, layout141)],
                            );
                    }
                };
            }
        }
        #[link(wasm_import_module = "$root")]
        extern "C" {
            #[link_name = "$root_event-deep-callback"]
            fn wit_import(_: i32, _: i32, _: i32);
        }
        wit_import(wit_bindgen::rt::as_i32(function_id), result142 as i32, len142);
        if layout142.size() != 0 {
            alloc::dealloc(result142, layout142);
        }
        for (ptr, layout) in cleanup_list {
            if layout.size() != 0 {
                alloc::dealloc(ptr, layout);
            }
        }
    }
}
pub mod y_crdt_namespace {
    pub mod y_crdt {
        #[allow(clippy::all)]
        pub mod y_doc_methods_types {
            #[repr(C)]
            pub struct YXmlText {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YXmlText {}
            #[automatically_derived]
            impl ::core::clone::Clone for YXmlText {
                #[inline]
                fn clone(&self) -> YXmlText {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YXmlText {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YXmlText").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YXmlFragment {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YXmlFragment {}
            #[automatically_derived]
            impl ::core::clone::Clone for YXmlFragment {
                #[inline]
                fn clone(&self) -> YXmlFragment {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YXmlFragment {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YXmlFragment").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YXmlElement {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YXmlElement {}
            #[automatically_derived]
            impl ::core::clone::Clone for YXmlElement {
                #[inline]
                fn clone(&self) -> YXmlElement {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YXmlElement {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YXmlElement").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YTextDeltaDelete {
                pub delete: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YTextDeltaDelete {}
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDeltaDelete {
                #[inline]
                fn clone(&self) -> YTextDeltaDelete {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YTextDeltaDelete {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextDeltaDelete")
                        .field("delete", &self.delete)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct YText {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YText {}
            #[automatically_derived]
            impl ::core::clone::Clone for YText {
                #[inline]
                fn clone(&self) -> YText {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YText {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YText").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YSnapshot {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YSnapshot {}
            #[automatically_derived]
            impl ::core::clone::Clone for YSnapshot {
                #[inline]
                fn clone(&self) -> YSnapshot {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YSnapshot {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YSnapshot").field("ref", &self.ref_).finish()
                }
            }
            #[repr(u8)]
            pub enum YMapDeltaAction {
                Insert,
                Update,
                Delete,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YMapDeltaAction {
                #[inline]
                fn clone(&self) -> YMapDeltaAction {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YMapDeltaAction {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for YMapDeltaAction {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for YMapDeltaAction {
                #[inline]
                fn eq(&self, other: &YMapDeltaAction) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for YMapDeltaAction {}
            #[automatically_derived]
            impl ::core::cmp::Eq for YMapDeltaAction {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            impl ::core::fmt::Debug for YMapDeltaAction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YMapDeltaAction::Insert => {
                            f.debug_tuple("YMapDeltaAction::Insert").finish()
                        }
                        YMapDeltaAction::Update => {
                            f.debug_tuple("YMapDeltaAction::Update").finish()
                        }
                        YMapDeltaAction::Delete => {
                            f.debug_tuple("YMapDeltaAction::Delete").finish()
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct YMap {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YMap {}
            #[automatically_derived]
            impl ::core::clone::Clone for YMap {
                #[inline]
                fn clone(&self) -> YMap {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YMap {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YMap").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YDoc {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YDoc {}
            #[automatically_derived]
            impl ::core::clone::Clone for YDoc {
                #[inline]
                fn clone(&self) -> YDoc {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YDoc {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YDoc").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YArrayDeltaRetain {
                pub retain: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YArrayDeltaRetain {}
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayDeltaRetain {
                #[inline]
                fn clone(&self) -> YArrayDeltaRetain {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YArrayDeltaRetain {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayDeltaRetain")
                        .field("retain", &self.retain)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct YArrayDeltaDelete {
                pub delete: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YArrayDeltaDelete {}
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayDeltaDelete {
                #[inline]
                fn clone(&self) -> YArrayDeltaDelete {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YArrayDeltaDelete {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayDeltaDelete")
                        .field("delete", &self.delete)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct YArray {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YArray {}
            #[automatically_derived]
            impl ::core::clone::Clone for YArray {
                #[inline]
                fn clone(&self) -> YArray {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YArray {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArray").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct WriteTransaction {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for WriteTransaction {}
            #[automatically_derived]
            impl ::core::clone::Clone for WriteTransaction {
                #[inline]
                fn clone(&self) -> WriteTransaction {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for WriteTransaction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WriteTransaction").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct ReadTransaction {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ReadTransaction {}
            #[automatically_derived]
            impl ::core::clone::Clone for ReadTransaction {
                #[inline]
                fn clone(&self) -> ReadTransaction {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for ReadTransaction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ReadTransaction").field("ref", &self.ref_).finish()
                }
            }
            pub enum YTransaction {
                ReadTransaction(ReadTransaction),
                WriteTransaction(WriteTransaction),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTransaction {
                #[inline]
                fn clone(&self) -> YTransaction {
                    let _: ::core::clone::AssertParamIsClone<ReadTransaction>;
                    let _: ::core::clone::AssertParamIsClone<WriteTransaction>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YTransaction {}
            impl ::core::fmt::Debug for YTransaction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YTransaction::ReadTransaction(e) => {
                            f.debug_tuple("YTransaction::ReadTransaction")
                                .field(e)
                                .finish()
                        }
                        YTransaction::WriteTransaction(e) => {
                            f.debug_tuple("YTransaction::WriteTransaction")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct JsonMapRef {
                pub index: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for JsonMapRef {}
            #[automatically_derived]
            impl ::core::clone::Clone for JsonMapRef {
                #[inline]
                fn clone(&self) -> JsonMapRef {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for JsonMapRef {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JsonMapRef").field("index", &self.index).finish()
                }
            }
            #[repr(C)]
            pub struct JsonArrayRef {
                pub index: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for JsonArrayRef {}
            #[automatically_derived]
            impl ::core::clone::Clone for JsonArrayRef {
                #[inline]
                fn clone(&self) -> JsonArrayRef {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for JsonArrayRef {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JsonArrayRef").field("index", &self.index).finish()
                }
            }
            pub enum JsonValue {
                Null,
                Undefined,
                Boolean(bool),
                Number(f64),
                BigInt(i64),
                Str(wit_bindgen::rt::string::String),
                Buffer(wit_bindgen::rt::vec::Vec<u8>),
                Array(JsonArrayRef),
                Map(JsonMapRef),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JsonValue {
                #[inline]
                fn clone(&self) -> JsonValue {
                    match self {
                        JsonValue::Null => JsonValue::Null,
                        JsonValue::Undefined => JsonValue::Undefined,
                        JsonValue::Boolean(__self_0) => {
                            JsonValue::Boolean(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Number(__self_0) => {
                            JsonValue::Number(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::BigInt(__self_0) => {
                            JsonValue::BigInt(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Str(__self_0) => {
                            JsonValue::Str(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Buffer(__self_0) => {
                            JsonValue::Buffer(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Array(__self_0) => {
                            JsonValue::Array(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Map(__self_0) => {
                            JsonValue::Map(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for JsonValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        JsonValue::Null => f.debug_tuple("JsonValue::Null").finish(),
                        JsonValue::Undefined => {
                            f.debug_tuple("JsonValue::Undefined").finish()
                        }
                        JsonValue::Boolean(e) => {
                            f.debug_tuple("JsonValue::Boolean").field(e).finish()
                        }
                        JsonValue::Number(e) => {
                            f.debug_tuple("JsonValue::Number").field(e).finish()
                        }
                        JsonValue::BigInt(e) => {
                            f.debug_tuple("JsonValue::BigInt").field(e).finish()
                        }
                        JsonValue::Str(e) => {
                            f.debug_tuple("JsonValue::Str").field(e).finish()
                        }
                        JsonValue::Buffer(e) => {
                            f.debug_tuple("JsonValue::Buffer").field(e).finish()
                        }
                        JsonValue::Array(e) => {
                            f.debug_tuple("JsonValue::Array").field(e).finish()
                        }
                        JsonValue::Map(e) => {
                            f.debug_tuple("JsonValue::Map").field(e).finish()
                        }
                    }
                }
            }
            pub struct JsonValueItem {
                pub item: JsonValue,
                pub array_references: wit_bindgen::rt::vec::Vec<
                    wit_bindgen::rt::vec::Vec<JsonValue>,
                >,
                pub map_references: wit_bindgen::rt::vec::Vec<
                    wit_bindgen::rt::vec::Vec<
                        (wit_bindgen::rt::string::String, JsonValue),
                    >,
                >,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JsonValueItem {
                #[inline]
                fn clone(&self) -> JsonValueItem {
                    JsonValueItem {
                        item: ::core::clone::Clone::clone(&self.item),
                        array_references: ::core::clone::Clone::clone(
                            &self.array_references,
                        ),
                        map_references: ::core::clone::Clone::clone(&self.map_references),
                    }
                }
            }
            impl ::core::fmt::Debug for JsonValueItem {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JsonValueItem")
                        .field("item", &self.item)
                        .field("array-references", &self.array_references)
                        .field("map-references", &self.map_references)
                        .finish()
                }
            }
            pub enum YValue {
                JsonValueItem(JsonValueItem),
                YText(YText),
                YArray(YArray),
                YMap(YMap),
                YXmlFragment(YXmlFragment),
                YXmlElement(YXmlElement),
                YXmlText(YXmlText),
                YDoc(YDoc),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YValue {
                #[inline]
                fn clone(&self) -> YValue {
                    match self {
                        YValue::JsonValueItem(__self_0) => {
                            YValue::JsonValueItem(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YText(__self_0) => {
                            YValue::YText(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YArray(__self_0) => {
                            YValue::YArray(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YMap(__self_0) => {
                            YValue::YMap(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YXmlFragment(__self_0) => {
                            YValue::YXmlFragment(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YXmlElement(__self_0) => {
                            YValue::YXmlElement(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YXmlText(__self_0) => {
                            YValue::YXmlText(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YDoc(__self_0) => {
                            YValue::YDoc(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for YValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YValue::JsonValueItem(e) => {
                            f.debug_tuple("YValue::JsonValueItem").field(e).finish()
                        }
                        YValue::YText(e) => {
                            f.debug_tuple("YValue::YText").field(e).finish()
                        }
                        YValue::YArray(e) => {
                            f.debug_tuple("YValue::YArray").field(e).finish()
                        }
                        YValue::YMap(e) => {
                            f.debug_tuple("YValue::YMap").field(e).finish()
                        }
                        YValue::YXmlFragment(e) => {
                            f.debug_tuple("YValue::YXmlFragment").field(e).finish()
                        }
                        YValue::YXmlElement(e) => {
                            f.debug_tuple("YValue::YXmlElement").field(e).finish()
                        }
                        YValue::YXmlText(e) => {
                            f.debug_tuple("YValue::YXmlText").field(e).finish()
                        }
                        YValue::YDoc(e) => {
                            f.debug_tuple("YValue::YDoc").field(e).finish()
                        }
                    }
                }
            }
            pub struct YMapDelta<'a> {
                pub action: YMapDeltaAction,
                pub old_value: Option<&'a YValue>,
                pub new_value: Option<&'a YValue>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YMapDelta<'a> {
                #[inline]
                fn clone(&self) -> YMapDelta<'a> {
                    YMapDelta {
                        action: ::core::clone::Clone::clone(&self.action),
                        old_value: ::core::clone::Clone::clone(&self.old_value),
                        new_value: ::core::clone::Clone::clone(&self.new_value),
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YMapDelta<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YMapDelta")
                        .field("action", &self.action)
                        .field("old-value", &self.old_value)
                        .field("new-value", &self.new_value)
                        .finish()
                }
            }
            pub struct YArrayDeltaInsert<'a> {
                pub insert: &'a [&'a YValue],
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YArrayDeltaInsert<'a> {
                #[inline]
                fn clone(&self) -> YArrayDeltaInsert<'a> {
                    YArrayDeltaInsert {
                        insert: ::core::clone::Clone::clone(&self.insert),
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YArrayDeltaInsert<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayDeltaInsert")
                        .field("insert", &self.insert)
                        .finish()
                }
            }
            pub enum YArrayDelta<'a> {
                YArrayDeltaInsert(YArrayDeltaInsert<'a>),
                YArrayDeltaDelete(YArrayDeltaDelete),
                YArrayDeltaRetain(YArrayDeltaRetain),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YArrayDelta<'a> {
                #[inline]
                fn clone(&self) -> YArrayDelta<'a> {
                    match self {
                        YArrayDelta::YArrayDeltaInsert(__self_0) => {
                            YArrayDelta::YArrayDeltaInsert(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YArrayDelta::YArrayDeltaDelete(__self_0) => {
                            YArrayDelta::YArrayDeltaDelete(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YArrayDelta::YArrayDeltaRetain(__self_0) => {
                            YArrayDelta::YArrayDeltaRetain(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YArrayDelta<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YArrayDelta::YArrayDeltaInsert(e) => {
                            f.debug_tuple("YArrayDelta::YArrayDeltaInsert")
                                .field(e)
                                .finish()
                        }
                        YArrayDelta::YArrayDeltaDelete(e) => {
                            f.debug_tuple("YArrayDelta::YArrayDeltaDelete")
                                .field(e)
                                .finish()
                        }
                        YArrayDelta::YArrayDeltaRetain(e) => {
                            f.debug_tuple("YArrayDelta::YArrayDeltaRetain")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            pub type JsonObject = JsonValueItem;
            pub type TextAttrs = JsonObject;
            pub struct YTextDeltaRetain {
                pub retain: u32,
                pub attributes: Option<TextAttrs>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDeltaRetain {
                #[inline]
                fn clone(&self) -> YTextDeltaRetain {
                    YTextDeltaRetain {
                        retain: ::core::clone::Clone::clone(&self.retain),
                        attributes: ::core::clone::Clone::clone(&self.attributes),
                    }
                }
            }
            impl ::core::fmt::Debug for YTextDeltaRetain {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextDeltaRetain")
                        .field("retain", &self.retain)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            pub struct YTextDeltaInsert {
                pub insert: wit_bindgen::rt::string::String,
                pub attributes: Option<TextAttrs>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDeltaInsert {
                #[inline]
                fn clone(&self) -> YTextDeltaInsert {
                    YTextDeltaInsert {
                        insert: ::core::clone::Clone::clone(&self.insert),
                        attributes: ::core::clone::Clone::clone(&self.attributes),
                    }
                }
            }
            impl ::core::fmt::Debug for YTextDeltaInsert {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextDeltaInsert")
                        .field("insert", &self.insert)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            /// https://quilljs.com/docs/delta/
            pub enum YTextDelta {
                YTextDeltaInsert(YTextDeltaInsert),
                YTextDeltaDelete(YTextDeltaDelete),
                YTextDeltaRetain(YTextDeltaRetain),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDelta {
                #[inline]
                fn clone(&self) -> YTextDelta {
                    match self {
                        YTextDelta::YTextDeltaInsert(__self_0) => {
                            YTextDelta::YTextDeltaInsert(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YTextDelta::YTextDeltaDelete(__self_0) => {
                            YTextDelta::YTextDeltaDelete(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YTextDelta::YTextDeltaRetain(__self_0) => {
                            YTextDelta::YTextDeltaRetain(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for YTextDelta {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YTextDelta::YTextDeltaInsert(e) => {
                            f.debug_tuple("YTextDelta::YTextDeltaInsert")
                                .field(e)
                                .finish()
                        }
                        YTextDelta::YTextDeltaDelete(e) => {
                            f.debug_tuple("YTextDelta::YTextDeltaDelete")
                                .field(e)
                                .finish()
                        }
                        YTextDelta::YTextDeltaRetain(e) => {
                            f.debug_tuple("YTextDelta::YTextDeltaRetain")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            pub type JsonArray = JsonValueItem;
            pub enum EventPathItem<'a> {
                String(&'a str),
                U32(u32),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for EventPathItem<'a> {
                #[inline]
                fn clone(&self) -> EventPathItem<'a> {
                    match self {
                        EventPathItem::String(__self_0) => {
                            EventPathItem::String(::core::clone::Clone::clone(__self_0))
                        }
                        EventPathItem::U32(__self_0) => {
                            EventPathItem::U32(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for EventPathItem<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        EventPathItem::String(e) => {
                            f.debug_tuple("EventPathItem::String").field(e).finish()
                        }
                        EventPathItem::U32(e) => {
                            f.debug_tuple("EventPathItem::U32").field(e).finish()
                        }
                    }
                }
            }
            pub type EventPath<'a> = &'a [EventPathItem<'a>];
            pub struct YTextEvent<'a> {
                pub target: YText,
                pub delta: &'a [&'a YTextDelta],
                pub path: EventPath<'a>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YTextEvent<'a> {
                #[inline]
                fn clone(&self) -> YTextEvent<'a> {
                    YTextEvent {
                        target: ::core::clone::Clone::clone(&self.target),
                        delta: ::core::clone::Clone::clone(&self.delta),
                        path: ::core::clone::Clone::clone(&self.path),
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YTextEvent<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextEvent")
                        .field("target", &self.target)
                        .field("delta", &self.delta)
                        .field("path", &self.path)
                        .finish()
                }
            }
            pub struct YMapEvent<'a> {
                pub target: YMap,
                pub keys: &'a [(&'a str, YMapDelta<'a>)],
                pub path: EventPath<'a>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YMapEvent<'a> {
                #[inline]
                fn clone(&self) -> YMapEvent<'a> {
                    YMapEvent {
                        target: ::core::clone::Clone::clone(&self.target),
                        keys: ::core::clone::Clone::clone(&self.keys),
                        path: ::core::clone::Clone::clone(&self.path),
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YMapEvent<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YMapEvent")
                        .field("target", &self.target)
                        .field("keys", &self.keys)
                        .field("path", &self.path)
                        .finish()
                }
            }
            pub struct YArrayEvent<'a> {
                pub target: YArray,
                pub delta: &'a [YArrayDelta<'a>],
                pub path: EventPath<'a>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YArrayEvent<'a> {
                #[inline]
                fn clone(&self) -> YArrayEvent<'a> {
                    YArrayEvent {
                        target: ::core::clone::Clone::clone(&self.target),
                        delta: ::core::clone::Clone::clone(&self.delta),
                        path: ::core::clone::Clone::clone(&self.path),
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YArrayEvent<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayEvent")
                        .field("target", &self.target)
                        .field("delta", &self.delta)
                        .field("path", &self.path)
                        .finish()
                }
            }
            pub enum YEvent<'a> {
                YArrayEvent(YArrayEvent<'a>),
                YMapEvent(YMapEvent<'a>),
                YTextEvent(YTextEvent<'a>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for YEvent<'a> {
                #[inline]
                fn clone(&self) -> YEvent<'a> {
                    match self {
                        YEvent::YArrayEvent(__self_0) => {
                            YEvent::YArrayEvent(::core::clone::Clone::clone(__self_0))
                        }
                        YEvent::YMapEvent(__self_0) => {
                            YEvent::YMapEvent(::core::clone::Clone::clone(__self_0))
                        }
                        YEvent::YTextEvent(__self_0) => {
                            YEvent::YTextEvent(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl<'a> ::core::fmt::Debug for YEvent<'a> {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YEvent::YArrayEvent(e) => {
                            f.debug_tuple("YEvent::YArrayEvent").field(e).finish()
                        }
                        YEvent::YMapEvent(e) => {
                            f.debug_tuple("YEvent::YMapEvent").field(e).finish()
                        }
                        YEvent::YTextEvent(e) => {
                            f.debug_tuple("YEvent::YTextEvent").field(e).finish()
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct EventObserver {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EventObserver {}
            #[automatically_derived]
            impl ::core::clone::Clone for EventObserver {
                #[inline]
                fn clone(&self) -> EventObserver {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for EventObserver {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EventObserver").field("ref", &self.ref_).finish()
                }
            }
        }
    }
}
pub mod exports {
    pub mod y_crdt_namespace {
        pub mod y_crdt {
            #[allow(clippy::all)]
            pub mod y_doc_methods {
                pub type EventObserver = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver;
                pub type YValue = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue;
                pub type YDoc = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc;
                pub type YTransaction = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction;
                pub type ReadTransaction = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction;
                pub type WriteTransaction = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction;
                pub type YText = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText;
                pub type YArray = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray;
                pub type YMap = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap;
                pub type YXmlFragment = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment;
                pub type YXmlElement = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement;
                pub type YXmlText = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText;
                pub type YTextDelta = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta;
                pub type YSnapshot = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot;
                pub type JsonObject = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonObject;
                pub type JsonArray = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArray;
                pub type JsonValueItem = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem;
                pub type TextAttrs = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::TextAttrs;
                pub type Origin = wit_bindgen::rt::vec::Vec<u8>;
                #[repr(u8)]
                pub enum OffsetKind {
                    /// Compute editable strings length and offset using UTF-8 byte count.
                    Bytes,
                    /// Compute editable strings length and offset using UTF-16 chars count.
                    Utf16,
                    /// Compute editable strings length and offset using Unicode code points number.
                    Utf32,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for OffsetKind {
                    #[inline]
                    fn clone(&self) -> OffsetKind {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for OffsetKind {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for OffsetKind {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for OffsetKind {
                    #[inline]
                    fn eq(&self, other: &OffsetKind) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for OffsetKind {}
                #[automatically_derived]
                impl ::core::cmp::Eq for OffsetKind {
                    #[inline]
                    #[doc(hidden)]
                    #[no_coverage]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                impl ::core::fmt::Debug for OffsetKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            OffsetKind::Bytes => {
                                f.debug_tuple("OffsetKind::Bytes").finish()
                            }
                            OffsetKind::Utf16 => {
                                f.debug_tuple("OffsetKind::Utf16").finish()
                            }
                            OffsetKind::Utf32 => {
                                f.debug_tuple("OffsetKind::Utf32").finish()
                            }
                        }
                    }
                }
                pub struct YDocOptions {
                    /// Globally unique client identifier. This value must be unique across all active collaborating
                    /// peers, otherwise a update collisions will happen, causing document store state to be corrupted.
                    ///
                    /// Default value: randomly generated.
                    pub client_id: Option<u64>,
                    /// A globally unique identifier for this document.
                    ///
                    /// Default value: randomly generated UUID v4.
                    pub guid: Option<wit_bindgen::rt::string::String>,
                    /// Associate this document with a collection. This only plays a role if your provider has
                    /// a concept of collection.
                    ///
                    /// Default value: `None`.
                    pub collection_id: Option<wit_bindgen::rt::string::String>,
                    /// How to we count offsets and lengths used in text operations.
                    ///
                    /// Default value: [OffsetKind::Bytes].
                    pub offset_kind: Option<OffsetKind>,
                    /// Determines if transactions commits should try to perform GC-ing of deleted items.
                    ///
                    /// Default value: `false`.
                    pub skip_gc: Option<bool>,
                    /// If a subdocument, automatically load document. If this is a subdocument, remote peers will
                    /// load the document as well automatically.
                    ///
                    /// Default value: `false`.
                    pub auto_load: Option<bool>,
                    /// Whether the document should be synced by the provider now.
                    /// This is toggled to true when you call ydoc.load().
                    ///
                    /// Default value: `true`.
                    pub should_load: Option<bool>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for YDocOptions {
                    #[inline]
                    fn clone(&self) -> YDocOptions {
                        YDocOptions {
                            client_id: ::core::clone::Clone::clone(&self.client_id),
                            guid: ::core::clone::Clone::clone(&self.guid),
                            collection_id: ::core::clone::Clone::clone(
                                &self.collection_id,
                            ),
                            offset_kind: ::core::clone::Clone::clone(&self.offset_kind),
                            skip_gc: ::core::clone::Clone::clone(&self.skip_gc),
                            auto_load: ::core::clone::Clone::clone(&self.auto_load),
                            should_load: ::core::clone::Clone::clone(&self.should_load),
                        }
                    }
                }
                impl ::core::fmt::Debug for YDocOptions {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("YDocOptions")
                            .field("client-id", &self.client_id)
                            .field("guid", &self.guid)
                            .field("collection-id", &self.collection_id)
                            .field("offset-kind", &self.offset_kind)
                            .field("skip-gc", &self.skip_gc)
                            .field("auto-load", &self.auto_load)
                            .field("should-load", &self.should_load)
                            .finish()
                    }
                }
                pub type ImplicitTransaction = Option<YTransaction>;
                pub type Error = wit_bindgen::rt::string::String;
                pub trait YDocMethods {
                    fn y_doc_dispose(ref_: YDoc) -> bool;
                    fn y_text_dispose(ref_: YText) -> bool;
                    fn y_array_dispose(ref_: YArray) -> bool;
                    fn y_map_dispose(ref_: YMap) -> bool;
                    fn y_xml_element_dispose(ref_: YXmlElement) -> bool;
                    fn y_xml_fragment_dispose(ref_: YXmlFragment) -> bool;
                    fn y_xml_text_dispose(ref_: YXmlText) -> bool;
                    fn y_transaction_dispose(ref_: YTransaction) -> bool;
                    fn y_value_dispose(ref_: YValue) -> bool;
                    fn callback_dispose(ref_: EventObserver) -> bool;
                    fn y_doc_new(options: Option<YDocOptions>) -> YDoc;
                    fn y_doc_parent_doc(ref_: YDoc) -> Option<YDoc>;
                    fn y_doc_id(ref_: YDoc) -> u64;
                    fn y_doc_guid(ref_: YDoc) -> wit_bindgen::rt::string::String;
                    fn y_doc_read_transaction(ref_: YDoc) -> ReadTransaction;
                    fn y_doc_write_transaction(
                        ref_: YDoc,
                        origin: Origin,
                    ) -> WriteTransaction;
                    fn y_doc_text(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YText;
                    fn y_doc_array(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YArray;
                    fn y_doc_map(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YMap;
                    fn y_doc_xml_fragment(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YXmlFragment;
                    fn y_doc_xml_element(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YXmlElement;
                    fn y_doc_xml_text(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YXmlText;
                    fn y_doc_on_update_v1(ref_: YDoc, function_id: u32) -> EventObserver;
                    fn load(ref_: YDoc, parent_txn: ImplicitTransaction);
                    fn destroy(ref_: YDoc, parent_txn: ImplicitTransaction);
                    fn subdocs(
                        ref_: YDoc,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<YDoc>;
                    fn subdoc_guids(
                        ref_: YDoc,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<wit_bindgen::rt::string::String>;
                    fn encode_state_vector(ref_: YDoc) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn encode_state_as_update(
                        ref_: YDoc,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn encode_state_as_update_v2(
                        ref_: YDoc,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn apply_update(
                        ref_: YDoc,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                        origin: Origin,
                    ) -> Result<(), Error>;
                    fn apply_update_v2(
                        ref_: YDoc,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                        origin: Origin,
                    ) -> Result<(), Error>;
                    fn transaction_origin(txn: YTransaction) -> Option<Origin>;
                    fn transaction_commit(txn: YTransaction);
                    fn transaction_state_vector_v1(
                        txn: YTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn transaction_diff_v1(
                        txn: YTransaction,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn transaction_diff_v2(
                        txn: YTransaction,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn transaction_apply_v1(
                        txn: YTransaction,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<(), Error>;
                    fn transaction_apply_v2(
                        txn: YTransaction,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<(), Error>;
                    fn transaction_encode_update(
                        txn: YTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn transaction_encode_update_v2(
                        txn: YTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn y_text_new(
                        init: Option<wit_bindgen::rt::string::String>,
                    ) -> YText;
                    fn y_text_prelim(ref_: YText) -> bool;
                    fn y_text_length(ref_: YText, txn: ImplicitTransaction) -> u32;
                    fn y_text_to_string(
                        ref_: YText,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::string::String;
                    fn y_text_to_json(
                        ref_: YText,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::string::String;
                    fn y_text_insert(
                        ref_: YText,
                        index: u32,
                        chunk: wit_bindgen::rt::string::String,
                        attributes: Option<TextAttrs>,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_insert_embed(
                        ref_: YText,
                        index: u32,
                        embed: JsonValueItem,
                        attributes: Option<TextAttrs>,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_format(
                        ref_: YText,
                        index: u32,
                        length: u32,
                        attributes: TextAttrs,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_push(
                        ref_: YText,
                        chunk: wit_bindgen::rt::string::String,
                        attributes: Option<TextAttrs>,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_delete(
                        ref_: YText,
                        index: u32,
                        length: u32,
                        txn: ImplicitTransaction,
                    );
                    /// https://quilljs.com/docs/delta/
                    /// TODO: implement compute_ychange: Option<Function>,
                    fn y_text_to_delta(
                        ref_: YText,
                        snapshot: Option<YSnapshot>,
                        prev_snapshot: Option<YSnapshot>,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<YTextDelta>;
                    fn y_text_observe(ref_: YText, function_id: u32) -> EventObserver;
                    fn y_text_observe_deep(
                        ref_: YText,
                        function_id: u32,
                    ) -> EventObserver;
                    fn snapshot(doc: YDoc) -> YSnapshot;
                    fn equal_snapshot(left: YSnapshot, right: YSnapshot) -> bool;
                    fn encode_snapshot_v1(
                        snapshot: YSnapshot,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn encode_snapshot_v2(
                        snapshot: YSnapshot,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn decode_snapshot_v1(
                        snapshot: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<YSnapshot, Error>;
                    fn decode_snapshot_v2(
                        snapshot: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<YSnapshot, Error>;
                    fn encode_state_from_snapshot_v1(
                        doc: YDoc,
                        snapshot: YSnapshot,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn encode_state_from_snapshot_v2(
                        doc: YDoc,
                        snapshot: YSnapshot,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn y_array_new(init: Option<JsonArray>) -> YArray;
                    fn y_array_prelim(ref_: YArray) -> bool;
                    fn y_array_length(ref_: YArray, txn: ImplicitTransaction) -> u32;
                    fn y_array_to_json(
                        ref_: YArray,
                        txn: ImplicitTransaction,
                    ) -> JsonValueItem;
                    fn y_array_insert(
                        ref_: YArray,
                        index: u32,
                        items: JsonArray,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_push(
                        ref_: YArray,
                        items: JsonArray,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_delete(
                        ref_: YArray,
                        index: u32,
                        length: u32,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_move_content(
                        ref_: YArray,
                        source: u32,
                        target: u32,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_get(
                        ref_: YArray,
                        index: u32,
                        txn: ImplicitTransaction,
                    ) -> Result<YValue, Error>;
                    fn y_array_values(
                        ref_: YArray,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<YValue>;
                    fn y_array_observe(ref_: YArray, function_id: u32) -> EventObserver;
                    fn y_array_observe_deep(
                        ref_: YArray,
                        function_id: u32,
                    ) -> EventObserver;
                    fn y_map_new(init: Option<JsonObject>) -> YMap;
                    fn y_map_prelim(ref_: YMap) -> bool;
                    fn y_map_length(ref_: YMap, txn: ImplicitTransaction) -> u32;
                    fn y_map_to_json(
                        ref_: YMap,
                        txn: ImplicitTransaction,
                    ) -> JsonValueItem;
                    fn y_map_set(
                        ref_: YMap,
                        key: wit_bindgen::rt::string::String,
                        value: JsonValueItem,
                        txn: ImplicitTransaction,
                    );
                    fn y_map_delete(
                        ref_: YMap,
                        key: wit_bindgen::rt::string::String,
                        txn: ImplicitTransaction,
                    );
                    fn y_map_get(
                        ref_: YMap,
                        key: wit_bindgen::rt::string::String,
                        txn: ImplicitTransaction,
                    ) -> Option<YValue>;
                    fn y_map_entries(
                        ref_: YMap,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<
                        (wit_bindgen::rt::string::String, YValue),
                    >;
                    fn y_map_observe(ref_: YMap, function_id: u32) -> EventObserver;
                    fn y_map_observe_deep(ref_: YMap, function_id: u32) -> EventObserver;
                    fn y_xml_element_name(
                        ref_: YXmlElement,
                    ) -> Option<wit_bindgen::rt::string::String>;
                    fn y_xml_element_length(
                        ref_: YXmlElement,
                        txn: ImplicitTransaction,
                    ) -> u32;
                    fn y_xml_element_insert_xml_element(
                        ref_: YXmlElement,
                        index: u32,
                        name: wit_bindgen::rt::string::String,
                        txn: ImplicitTransaction,
                    ) -> YXmlElement;
                    fn y_xml_element_insert_xml_text(
                        ref_: YXmlElement,
                        index: u32,
                        txn: ImplicitTransaction,
                    ) -> YXmlText;
                    fn y_xml_element_delete(
                        ref_: YXmlElement,
                        index: u32,
                        length: u32,
                        txn: ImplicitTransaction,
                    );
                    fn y_xml_fragment_name(
                        ref_: YXmlFragment,
                    ) -> Option<wit_bindgen::rt::string::String>;
                    fn y_xml_fragment_length(
                        ref_: YXmlFragment,
                        txn: ImplicitTransaction,
                    ) -> u32;
                    fn y_xml_text_length(
                        ref_: YXmlText,
                        txn: ImplicitTransaction,
                    ) -> u32;
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_dispose<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_doc_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_dispose<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_dispose<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_dispose<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_element_dispose<T: YDocMethods>(
                    arg0: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_element_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_fragment_dispose<T: YDocMethods>(
                    arg0: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_fragment_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_text_dispose<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_text_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_transaction_dispose<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_transaction_dispose(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_value_dispose<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i64,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result11 = T::y_value_dispose(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem({
                                    let base5 = arg4;
                                    let len5 = arg5;
                                    let mut result5 = Vec::with_capacity(len5 as usize);
                                    for i in 0..len5 {
                                        let base = base5 + i * 8;
                                        result5
                                            .push({
                                                let base4 = *((base + 0) as *const i32);
                                                let len4 = *((base + 4) as *const i32);
                                                let mut result4 = Vec::with_capacity(len4 as usize);
                                                for i in 0..len4 {
                                                    let base = base4 + i * 16;
                                                    result4
                                                        .push({
                                                            {
                                                                match i32::from(*((base + 0) as *const u8)) {
                                                                    0 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                    }
                                                                    1 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                    }
                                                                    2 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                            #[cfg(debug_assertions)]
                                                                            {
                                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                                    0 => false,
                                                                                    1 => true,
                                                                                    _ => {
                                                                                        ::core::panicking::panic_fmt(
                                                                                            format_args!("invalid bool discriminant"),
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    3 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                            *((base + 8) as *const f64),
                                                                        )
                                                                    }
                                                                    4 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                            *((base + 8) as *const i64),
                                                                        )
                                                                    }
                                                                    5 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                                            {
                                                                                #[cfg(debug_assertions)]
                                                                                {
                                                                                    String::from_utf8(
                                                                                            Vec::from_raw_parts(
                                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                                len2,
                                                                                                len2,
                                                                                            ),
                                                                                        )
                                                                                        .unwrap()
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    6 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len3,
                                                                                len3,
                                                                            )
                                                                        })
                                                                    }
                                                                    7 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    8 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid enum discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                                result4
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                                    let base10 = arg6;
                                    let len10 = arg7;
                                    let mut result10 = Vec::with_capacity(len10 as usize);
                                    for i in 0..len10 {
                                        let base = base10 + i * 8;
                                        result10
                                            .push({
                                                let base9 = *((base + 0) as *const i32);
                                                let len9 = *((base + 4) as *const i32);
                                                let mut result9 = Vec::with_capacity(len9 as usize);
                                                for i in 0..len9 {
                                                    let base = base9 + i * 24;
                                                    result9
                                                        .push({
                                                            let len6 = *((base + 4) as *const i32) as usize;
                                                            (
                                                                {
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        String::from_utf8(
                                                                                Vec::from_raw_parts(
                                                                                    *((base + 0) as *const i32) as *mut _,
                                                                                    len6,
                                                                                    len6,
                                                                                ),
                                                                            )
                                                                            .unwrap()
                                                                    }
                                                                },
                                                                {
                                                                    {
                                                                        match i32::from(*((base + 8) as *const u8)) {
                                                                            0 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                            }
                                                                            1 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                            }
                                                                            2 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                                    #[cfg(debug_assertions)]
                                                                                    {
                                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                                            0 => false,
                                                                                            1 => true,
                                                                                            _ => {
                                                                                                ::core::panicking::panic_fmt(
                                                                                                    format_args!("invalid bool discriminant"),
                                                                                                );
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            3 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                    *((base + 16) as *const f64),
                                                                                )
                                                                            }
                                                                            4 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                    *((base + 16) as *const i64),
                                                                                )
                                                                            }
                                                                            5 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                                    {
                                                                                        #[cfg(debug_assertions)]
                                                                                        {
                                                                                            String::from_utf8(
                                                                                                    Vec::from_raw_parts(
                                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                                        len7,
                                                                                                        len7,
                                                                                                    ),
                                                                                                )
                                                                                                .unwrap()
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            6 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len8,
                                                                                        len8,
                                                                                    )
                                                                                })
                                                                            }
                                                                            7 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            8 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                },
                                                            )
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                                result9
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: {
                                            {
                                                match arg1 {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match arg2 as i32 {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            f64::from_bits(arg2 as u64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            arg2,
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len0 = arg3 as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len1 = arg3 as usize;
                                                            Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: arg2 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: arg2 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        },
                                        array_references: result5,
                                        map_references: result10,
                                    }
                                })
                            }
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                    ref_: arg1 as u32,
                                })
                            }
                            2 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                    ref_: arg1 as u32,
                                })
                            }
                            3 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                    ref_: arg1 as u32,
                                })
                            }
                            4 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                    ref_: arg1 as u32,
                                })
                            }
                            5 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                    ref_: arg1 as u32,
                                })
                            }
                            6 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            7 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                    match result11 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_callback_dispose<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::callback_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_new<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result2 = T::y_doc_new(
                        match i32::from(*((arg0 + 0) as *const u8)) {
                            0 => None,
                            1 => {
                                Some(YDocOptions {
                                    client_id: match i32::from(*((arg0 + 8) as *const u8)) {
                                        0 => None,
                                        1 => Some(*((arg0 + 16) as *const i64) as u64),
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                    guid: match i32::from(*((arg0 + 24) as *const u8)) {
                                        0 => None,
                                        1 => {
                                            Some({
                                                let len0 = *((arg0 + 32) as *const i32) as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((arg0 + 28) as *const i32) as *mut _,
                                                                    len0,
                                                                    len0,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                    collection_id: match i32::from(
                                        *((arg0 + 36) as *const u8),
                                    ) {
                                        0 => None,
                                        1 => {
                                            Some({
                                                let len1 = *((arg0 + 44) as *const i32) as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((arg0 + 40) as *const i32) as *mut _,
                                                                    len1,
                                                                    len1,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                    offset_kind: match i32::from(*((arg0 + 48) as *const u8)) {
                                        0 => None,
                                        1 => {
                                            Some({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match i32::from(*((arg0 + 49) as *const u8)) {
                                                        0 => OffsetKind::Bytes,
                                                        1 => OffsetKind::Utf16,
                                                        2 => OffsetKind::Utf32,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid enum discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                    skip_gc: match i32::from(*((arg0 + 50) as *const u8)) {
                                        0 => None,
                                        1 => {
                                            Some({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match i32::from(*((arg0 + 51) as *const u8)) {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                    auto_load: match i32::from(*((arg0 + 52) as *const u8)) {
                                        0 => None,
                                        1 => {
                                            Some({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match i32::from(*((arg0 + 53) as *const u8)) {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                    should_load: match i32::from(*((arg0 + 54) as *const u8)) {
                                        0 => None,
                                        1 => {
                                            Some({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match i32::from(*((arg0 + 55) as *const u8)) {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    },
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::dealloc(arg0, 56, 8);
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: ref_3,
                    } = result2;
                    wit_bindgen::rt::as_i32(ref_3)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_parent_doc<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_doc_parent_doc(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Some(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: ref_2,
                            } = e;
                            *((ptr1 + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_2);
                        }
                        None => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_id<T: YDocMethods>(arg0: i32) -> i64 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_doc_id(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    wit_bindgen::rt::as_i64(result0)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_guid<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_doc_guid(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_doc_guid<T: YDocMethods>(arg0: i32) {
                    wit_bindgen::rt::dealloc(
                        *((arg0 + 0) as *const i32),
                        (*((arg0 + 4) as *const i32)) as usize,
                        1,
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_read_transaction<T: YDocMethods>(
                    arg0: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_doc_read_transaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_write_transaction<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_write_transaction(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_text<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_text(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_array<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_array(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_map<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_map(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_xml_fragment<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_xml_fragment(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_xml_element<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_xml_element(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_xml_text<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_doc_xml_text(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_doc_on_update_v1<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_doc_on_update_v1(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_load<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::load(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_destroy<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::destroy(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_subdocs<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::subdocs(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_subdocs<T: YDocMethods>(arg0: i32) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 4, 4);
                }
                #[doc(hidden)]
                pub unsafe fn call_subdoc_guids<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::subdoc_guids(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec3 = result0;
                    let len3 = vec3.len() as i32;
                    let layout3 = alloc::Layout::from_size_align_unchecked(
                        vec3.len() * 8,
                        4,
                    );
                    let result3 = if layout3.size() != 0 {
                        let ptr = alloc::alloc(layout3);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout3);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3 as i32 + (i as i32) * 8;
                        {
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr() as i32;
                            let len2 = vec2.len() as i32;
                            ::core::mem::forget(vec2);
                            *((base + 4) as *mut i32) = len2;
                            *((base + 0) as *mut i32) = ptr2;
                        }
                    }
                    *((ptr1 + 4) as *mut i32) = len3;
                    *((ptr1 + 0) as *mut i32) = result3 as i32;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_subdoc_guids<T: YDocMethods>(arg0: i32) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    for i in 0..len0 {
                        let base = base0 + i * 8;
                        {
                            wit_bindgen::rt::dealloc(
                                *((base + 0) as *const i32),
                                (*((base + 4) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 8, 4);
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_state_vector<T: YDocMethods>(
                    arg0: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::encode_state_vector(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_state_vector<T: YDocMethods>(
                    arg0: i32,
                ) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_state_as_update<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result1 = T::encode_state_as_update(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some({
                                    let len0 = arg3 as usize;
                                    Vec::from_raw_parts(arg2 as *mut _, len0, len0)
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(e) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr2 + 8) as *mut i32) = len3;
                            *((ptr2 + 4) as *mut i32) = ptr3;
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr2 + 8) as *mut i32) = len4;
                            *((ptr2 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_state_as_update<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_state_as_update_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result1 = T::encode_state_as_update_v2(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some({
                                    let len0 = arg3 as usize;
                                    Vec::from_raw_parts(arg2 as *mut _, len0, len0)
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(e) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr2 + 8) as *mut i32) = len3;
                            *((ptr2 + 4) as *mut i32) = ptr3;
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr2 + 8) as *mut i32) = len4;
                            *((ptr2 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_state_as_update_v2<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_apply_update<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let len1 = arg4 as usize;
                    let result2 = T::apply_update(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                        Vec::from_raw_parts(arg3 as *mut _, len1, len1),
                    );
                    let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result2 {
                        Ok(_) => {
                            *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                        }
                        Err(e) => {
                            *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr3 + 8) as *mut i32) = len4;
                            *((ptr3 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                pub unsafe fn post_return_apply_update<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_apply_update_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let len1 = arg4 as usize;
                    let result2 = T::apply_update_v2(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                        Vec::from_raw_parts(arg3 as *mut _, len1, len1),
                    );
                    let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result2 {
                        Ok(_) => {
                            *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                        }
                        Err(e) => {
                            *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr3 + 8) as *mut i32) = len4;
                            *((ptr3 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                pub unsafe fn post_return_apply_update_v2<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_origin<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::transaction_origin(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Some(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let vec2 = (e).into_boxed_slice();
                            let ptr2 = vec2.as_ptr() as i32;
                            let len2 = vec2.len() as i32;
                            ::core::mem::forget(vec2);
                            *((ptr1 + 8) as *mut i32) = len2;
                            *((ptr1 + 4) as *mut i32) = ptr2;
                        }
                        None => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_origin<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_commit<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::transaction_commit(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_state_vector_v1<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::transaction_state_vector_v1(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_state_vector_v1<T: YDocMethods>(
                    arg0: i32,
                ) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_diff_v1<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result1 = T::transaction_diff_v1(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                        match arg2 {
                            0 => None,
                            1 => {
                                Some({
                                    let len0 = arg4 as usize;
                                    Vec::from_raw_parts(arg3 as *mut _, len0, len0)
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(e) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr2 + 8) as *mut i32) = len3;
                            *((ptr2 + 4) as *mut i32) = ptr3;
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr2 + 8) as *mut i32) = len4;
                            *((ptr2 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_diff_v1<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_diff_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result1 = T::transaction_diff_v2(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                        match arg2 {
                            0 => None,
                            1 => {
                                Some({
                                    let len0 = arg4 as usize;
                                    Vec::from_raw_parts(arg3 as *mut _, len0, len0)
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(e) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr2 + 8) as *mut i32) = len3;
                            *((ptr2 + 4) as *mut i32) = ptr3;
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr2 + 8) as *mut i32) = len4;
                            *((ptr2 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_diff_v2<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_apply_v1<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg3 as usize;
                    let result1 = T::transaction_apply_v1(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                        Vec::from_raw_parts(arg2 as *mut _, len0, len0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(_) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr2 + 8) as *mut i32) = len3;
                            *((ptr2 + 4) as *mut i32) = ptr3;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_apply_v1<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_apply_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg3 as usize;
                    let result1 = T::transaction_apply_v2(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                        Vec::from_raw_parts(arg2 as *mut _, len0, len0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(_) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr2 + 8) as *mut i32) = len3;
                            *((ptr2 + 4) as *mut i32) = ptr3;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_apply_v2<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_encode_update<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::transaction_encode_update(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_encode_update<T: YDocMethods>(
                    arg0: i32,
                ) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                }
                #[doc(hidden)]
                pub unsafe fn call_transaction_encode_update_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::transaction_encode_update_v2(
                        match arg0 {
                            0 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            1 => {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid union discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_transaction_encode_update_v2<T: YDocMethods>(
                    arg0: i32,
                ) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_new<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result1 = T::y_text_new(
                        match arg0 {
                            0 => None,
                            1 => {
                                Some({
                                    let len0 = arg2 as usize;
                                    {
                                        #[cfg(debug_assertions)]
                                        {
                                            String::from_utf8(
                                                    Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                                )
                                                .unwrap()
                                        }
                                    }
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_prelim<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_prelim(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_length<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_length(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::as_i32(result0)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_to_string<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_to_string(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_text_to_string<T: YDocMethods>(arg0: i32) {
                    wit_bindgen::rt::dealloc(
                        *((arg0 + 0) as *const i32),
                        (*((arg0 + 4) as *const i32)) as usize,
                        1,
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_to_json<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_to_json(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_text_to_json<T: YDocMethods>(arg0: i32) {
                    wit_bindgen::rt::dealloc(
                        *((arg0 + 0) as *const i32),
                        (*((arg0 + 4) as *const i32)) as usize,
                        1,
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_insert<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i64,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                    arg13: i32,
                    arg14: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg3 as usize;
                    T::y_text_insert(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg2 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                        match arg4 {
                            0 => None,
                            1 => {
                                Some({
                                    let base6 = arg8;
                                    let len6 = arg9;
                                    let mut result6 = Vec::with_capacity(len6 as usize);
                                    for i in 0..len6 {
                                        let base = base6 + i * 8;
                                        result6
                                            .push({
                                                let base5 = *((base + 0) as *const i32);
                                                let len5 = *((base + 4) as *const i32);
                                                let mut result5 = Vec::with_capacity(len5 as usize);
                                                for i in 0..len5 {
                                                    let base = base5 + i * 16;
                                                    result5
                                                        .push({
                                                            {
                                                                match i32::from(*((base + 0) as *const u8)) {
                                                                    0 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                    }
                                                                    1 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                    }
                                                                    2 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                            #[cfg(debug_assertions)]
                                                                            {
                                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                                    0 => false,
                                                                                    1 => true,
                                                                                    _ => {
                                                                                        ::core::panicking::panic_fmt(
                                                                                            format_args!("invalid bool discriminant"),
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    3 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                            *((base + 8) as *const f64),
                                                                        )
                                                                    }
                                                                    4 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                            *((base + 8) as *const i64),
                                                                        )
                                                                    }
                                                                    5 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                                            {
                                                                                #[cfg(debug_assertions)]
                                                                                {
                                                                                    String::from_utf8(
                                                                                            Vec::from_raw_parts(
                                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                                len3,
                                                                                                len3,
                                                                                            ),
                                                                                        )
                                                                                        .unwrap()
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    6 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                            let len4 = *((base + 12) as *const i32) as usize;
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len4,
                                                                                len4,
                                                                            )
                                                                        })
                                                                    }
                                                                    7 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    8 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid enum discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base5, (len5 as usize) * 16, 8);
                                                result5
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                    let base11 = arg10;
                                    let len11 = arg11;
                                    let mut result11 = Vec::with_capacity(len11 as usize);
                                    for i in 0..len11 {
                                        let base = base11 + i * 8;
                                        result11
                                            .push({
                                                let base10 = *((base + 0) as *const i32);
                                                let len10 = *((base + 4) as *const i32);
                                                let mut result10 = Vec::with_capacity(len10 as usize);
                                                for i in 0..len10 {
                                                    let base = base10 + i * 24;
                                                    result10
                                                        .push({
                                                            let len7 = *((base + 4) as *const i32) as usize;
                                                            (
                                                                {
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        String::from_utf8(
                                                                                Vec::from_raw_parts(
                                                                                    *((base + 0) as *const i32) as *mut _,
                                                                                    len7,
                                                                                    len7,
                                                                                ),
                                                                            )
                                                                            .unwrap()
                                                                    }
                                                                },
                                                                {
                                                                    {
                                                                        match i32::from(*((base + 8) as *const u8)) {
                                                                            0 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                            }
                                                                            1 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                            }
                                                                            2 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                                    #[cfg(debug_assertions)]
                                                                                    {
                                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                                            0 => false,
                                                                                            1 => true,
                                                                                            _ => {
                                                                                                ::core::panicking::panic_fmt(
                                                                                                    format_args!("invalid bool discriminant"),
                                                                                                );
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            3 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                    *((base + 16) as *const f64),
                                                                                )
                                                                            }
                                                                            4 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                    *((base + 16) as *const i64),
                                                                                )
                                                                            }
                                                                            5 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                                    {
                                                                                        #[cfg(debug_assertions)]
                                                                                        {
                                                                                            String::from_utf8(
                                                                                                    Vec::from_raw_parts(
                                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                                        len8,
                                                                                                        len8,
                                                                                                    ),
                                                                                                )
                                                                                                .unwrap()
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            6 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                                    let len9 = *((base + 20) as *const i32) as usize;
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len9,
                                                                                        len9,
                                                                                    )
                                                                                })
                                                                            }
                                                                            7 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            8 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                },
                                                            )
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base10, (len10 as usize) * 24, 8);
                                                result10
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: {
                                            {
                                                match arg5 {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match arg6 as i32 {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            f64::from_bits(arg6 as u64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            arg6,
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len1 = arg7 as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(arg6 as i32 as *mut _, len1, len1),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len2 = arg7 as usize;
                                                            Vec::from_raw_parts(arg6 as i32 as *mut _, len2, len2)
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: arg6 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: arg6 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        },
                                        array_references: result6,
                                        map_references: result11,
                                    }
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                        match arg12 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg13 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg14 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg14 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_insert_embed<T: YDocMethods>(arg0: i32) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let base5 = *((arg0 + 24) as *const i32);
                    let len5 = *((arg0 + 28) as *const i32);
                    let mut result5 = Vec::with_capacity(len5 as usize);
                    for i in 0..len5 {
                        let base = base5 + i * 8;
                        result5
                            .push({
                                let base4 = *((base + 0) as *const i32);
                                let len4 = *((base + 4) as *const i32);
                                let mut result4 = Vec::with_capacity(len4 as usize);
                                for i in 0..len4 {
                                    let base = base4 + i * 16;
                                    result4
                                        .push({
                                            {
                                                match i32::from(*((base + 0) as *const u8)) {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            *((base + 8) as *const f64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            *((base + 8) as *const i64),
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len2,
                                                                                len2,
                                                                            ),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                            Vec::from_raw_parts(
                                                                *((base + 8) as *const i32) as *mut _,
                                                                len3,
                                                                len3,
                                                            )
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        });
                                }
                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                result4
                            });
                    }
                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                    let base10 = *((arg0 + 32) as *const i32);
                    let len10 = *((arg0 + 36) as *const i32);
                    let mut result10 = Vec::with_capacity(len10 as usize);
                    for i in 0..len10 {
                        let base = base10 + i * 8;
                        result10
                            .push({
                                let base9 = *((base + 0) as *const i32);
                                let len9 = *((base + 4) as *const i32);
                                let mut result9 = Vec::with_capacity(len9 as usize);
                                for i in 0..len9 {
                                    let base = base9 + i * 24;
                                    result9
                                        .push({
                                            let len6 = *((base + 4) as *const i32) as usize;
                                            (
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((base + 0) as *const i32) as *mut _,
                                                                    len6,
                                                                    len6,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                },
                                                {
                                                    {
                                                        match i32::from(*((base + 8) as *const u8)) {
                                                            0 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                            }
                                                            1 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                            }
                                                            2 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                            0 => false,
                                                                            1 => true,
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid bool discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            3 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    *((base + 16) as *const f64),
                                                                )
                                                            }
                                                            4 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    *((base + 16) as *const i64),
                                                                )
                                                            }
                                                            5 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                    {
                                                                        #[cfg(debug_assertions)]
                                                                        {
                                                                            String::from_utf8(
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len7,
                                                                                        len7,
                                                                                    ),
                                                                                )
                                                                                .unwrap()
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            6 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                    Vec::from_raw_parts(
                                                                        *((base + 16) as *const i32) as *mut _,
                                                                        len8,
                                                                        len8,
                                                                    )
                                                                })
                                                            }
                                                            7 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            8 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            _ => {
                                                                ::core::panicking::panic_fmt(
                                                                    format_args!("invalid enum discriminant"),
                                                                );
                                                            }
                                                        }
                                                    }
                                                },
                                            )
                                        });
                                }
                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                result9
                            });
                    }
                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                    T::y_text_insert_embed(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: *((arg0 + 0) as *const i32) as u32,
                        },
                        *((arg0 + 4) as *const i32) as u32,
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: {
                                {
                                    match i32::from(*((arg0 + 8) as *const u8)) {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                        }
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                        }
                                        2 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match i32::from(*((arg0 + 16) as *const u8)) {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        3 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                *((arg0 + 16) as *const f64),
                                            )
                                        }
                                        4 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                *((arg0 + 16) as *const i64),
                                            )
                                        }
                                        5 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                let len0 = *((arg0 + 20) as *const i32) as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((arg0 + 16) as *const i32) as *mut _,
                                                                    len0,
                                                                    len0,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        6 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                let len1 = *((arg0 + 20) as *const i32) as usize;
                                                Vec::from_raw_parts(
                                                    *((arg0 + 16) as *const i32) as *mut _,
                                                    len1,
                                                    len1,
                                                )
                                            })
                                        }
                                        7 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: *((arg0 + 16) as *const i32) as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        8 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: *((arg0 + 16) as *const i32) as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    }
                                }
                            },
                            array_references: result5,
                            map_references: result10,
                        },
                        match i32::from(*((arg0 + 40) as *const u8)) {
                            0 => None,
                            1 => {
                                Some({
                                    let base16 = *((arg0 + 64) as *const i32);
                                    let len16 = *((arg0 + 68) as *const i32);
                                    let mut result16 = Vec::with_capacity(len16 as usize);
                                    for i in 0..len16 {
                                        let base = base16 + i * 8;
                                        result16
                                            .push({
                                                let base15 = *((base + 0) as *const i32);
                                                let len15 = *((base + 4) as *const i32);
                                                let mut result15 = Vec::with_capacity(len15 as usize);
                                                for i in 0..len15 {
                                                    let base = base15 + i * 16;
                                                    result15
                                                        .push({
                                                            {
                                                                match i32::from(*((base + 0) as *const u8)) {
                                                                    0 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                    }
                                                                    1 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                    }
                                                                    2 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                            #[cfg(debug_assertions)]
                                                                            {
                                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                                    0 => false,
                                                                                    1 => true,
                                                                                    _ => {
                                                                                        ::core::panicking::panic_fmt(
                                                                                            format_args!("invalid bool discriminant"),
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    3 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                            *((base + 8) as *const f64),
                                                                        )
                                                                    }
                                                                    4 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                            *((base + 8) as *const i64),
                                                                        )
                                                                    }
                                                                    5 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                            let len13 = *((base + 12) as *const i32) as usize;
                                                                            {
                                                                                #[cfg(debug_assertions)]
                                                                                {
                                                                                    String::from_utf8(
                                                                                            Vec::from_raw_parts(
                                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                                len13,
                                                                                                len13,
                                                                                            ),
                                                                                        )
                                                                                        .unwrap()
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    6 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                            let len14 = *((base + 12) as *const i32) as usize;
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len14,
                                                                                len14,
                                                                            )
                                                                        })
                                                                    }
                                                                    7 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    8 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid enum discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base15, (len15 as usize) * 16, 8);
                                                result15
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base16, (len16 as usize) * 8, 4);
                                    let base21 = *((arg0 + 72) as *const i32);
                                    let len21 = *((arg0 + 76) as *const i32);
                                    let mut result21 = Vec::with_capacity(len21 as usize);
                                    for i in 0..len21 {
                                        let base = base21 + i * 8;
                                        result21
                                            .push({
                                                let base20 = *((base + 0) as *const i32);
                                                let len20 = *((base + 4) as *const i32);
                                                let mut result20 = Vec::with_capacity(len20 as usize);
                                                for i in 0..len20 {
                                                    let base = base20 + i * 24;
                                                    result20
                                                        .push({
                                                            let len17 = *((base + 4) as *const i32) as usize;
                                                            (
                                                                {
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        String::from_utf8(
                                                                                Vec::from_raw_parts(
                                                                                    *((base + 0) as *const i32) as *mut _,
                                                                                    len17,
                                                                                    len17,
                                                                                ),
                                                                            )
                                                                            .unwrap()
                                                                    }
                                                                },
                                                                {
                                                                    {
                                                                        match i32::from(*((base + 8) as *const u8)) {
                                                                            0 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                            }
                                                                            1 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                            }
                                                                            2 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                                    #[cfg(debug_assertions)]
                                                                                    {
                                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                                            0 => false,
                                                                                            1 => true,
                                                                                            _ => {
                                                                                                ::core::panicking::panic_fmt(
                                                                                                    format_args!("invalid bool discriminant"),
                                                                                                );
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            3 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                    *((base + 16) as *const f64),
                                                                                )
                                                                            }
                                                                            4 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                    *((base + 16) as *const i64),
                                                                                )
                                                                            }
                                                                            5 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                                    let len18 = *((base + 20) as *const i32) as usize;
                                                                                    {
                                                                                        #[cfg(debug_assertions)]
                                                                                        {
                                                                                            String::from_utf8(
                                                                                                    Vec::from_raw_parts(
                                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                                        len18,
                                                                                                        len18,
                                                                                                    ),
                                                                                                )
                                                                                                .unwrap()
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            6 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                                    let len19 = *((base + 20) as *const i32) as usize;
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len19,
                                                                                        len19,
                                                                                    )
                                                                                })
                                                                            }
                                                                            7 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            8 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                },
                                                            )
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base20, (len20 as usize) * 24, 8);
                                                result20
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base21, (len21 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: {
                                            {
                                                match i32::from(*((arg0 + 48) as *const u8)) {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match i32::from(*((arg0 + 56) as *const u8)) {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            *((arg0 + 56) as *const f64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            *((arg0 + 56) as *const i64),
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len11 = *((arg0 + 60) as *const i32) as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(
                                                                                *((arg0 + 56) as *const i32) as *mut _,
                                                                                len11,
                                                                                len11,
                                                                            ),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len12 = *((arg0 + 60) as *const i32) as usize;
                                                            Vec::from_raw_parts(
                                                                *((arg0 + 56) as *const i32) as *mut _,
                                                                len12,
                                                                len12,
                                                            )
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: *((arg0 + 56) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: *((arg0 + 56) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        },
                                        array_references: result16,
                                        map_references: result21,
                                    }
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                        match i32::from(*((arg0 + 80) as *const u8)) {
                            0 => None,
                            1 => {
                                Some(
                                    match i32::from(*((arg0 + 84) as *const u8)) {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: *((arg0 + 88) as *const i32) as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: *((arg0 + 88) as *const i32) as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::dealloc(arg0, 96, 8);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_format<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i64,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let base5 = arg6;
                    let len5 = arg7;
                    let mut result5 = Vec::with_capacity(len5 as usize);
                    for i in 0..len5 {
                        let base = base5 + i * 8;
                        result5
                            .push({
                                let base4 = *((base + 0) as *const i32);
                                let len4 = *((base + 4) as *const i32);
                                let mut result4 = Vec::with_capacity(len4 as usize);
                                for i in 0..len4 {
                                    let base = base4 + i * 16;
                                    result4
                                        .push({
                                            {
                                                match i32::from(*((base + 0) as *const u8)) {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            *((base + 8) as *const f64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            *((base + 8) as *const i64),
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len2,
                                                                                len2,
                                                                            ),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                            Vec::from_raw_parts(
                                                                *((base + 8) as *const i32) as *mut _,
                                                                len3,
                                                                len3,
                                                            )
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        });
                                }
                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                result4
                            });
                    }
                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                    let base10 = arg8;
                    let len10 = arg9;
                    let mut result10 = Vec::with_capacity(len10 as usize);
                    for i in 0..len10 {
                        let base = base10 + i * 8;
                        result10
                            .push({
                                let base9 = *((base + 0) as *const i32);
                                let len9 = *((base + 4) as *const i32);
                                let mut result9 = Vec::with_capacity(len9 as usize);
                                for i in 0..len9 {
                                    let base = base9 + i * 24;
                                    result9
                                        .push({
                                            let len6 = *((base + 4) as *const i32) as usize;
                                            (
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((base + 0) as *const i32) as *mut _,
                                                                    len6,
                                                                    len6,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                },
                                                {
                                                    {
                                                        match i32::from(*((base + 8) as *const u8)) {
                                                            0 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                            }
                                                            1 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                            }
                                                            2 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                            0 => false,
                                                                            1 => true,
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid bool discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            3 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    *((base + 16) as *const f64),
                                                                )
                                                            }
                                                            4 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    *((base + 16) as *const i64),
                                                                )
                                                            }
                                                            5 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                    {
                                                                        #[cfg(debug_assertions)]
                                                                        {
                                                                            String::from_utf8(
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len7,
                                                                                        len7,
                                                                                    ),
                                                                                )
                                                                                .unwrap()
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            6 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                    Vec::from_raw_parts(
                                                                        *((base + 16) as *const i32) as *mut _,
                                                                        len8,
                                                                        len8,
                                                                    )
                                                                })
                                                            }
                                                            7 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            8 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            _ => {
                                                                ::core::panicking::panic_fmt(
                                                                    format_args!("invalid enum discriminant"),
                                                                );
                                                            }
                                                        }
                                                    }
                                                },
                                            )
                                        });
                                }
                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                result9
                            });
                    }
                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                    T::y_text_format(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        arg2 as u32,
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: {
                                {
                                    match arg3 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                        }
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                        }
                                        2 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match arg4 as i32 {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        3 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                f64::from_bits(arg4 as u64),
                                            )
                                        }
                                        4 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                arg4,
                                            )
                                        }
                                        5 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                let len0 = arg5 as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(arg4 as i32 as *mut _, len0, len0),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        6 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                let len1 = arg5 as usize;
                                                Vec::from_raw_parts(arg4 as i32 as *mut _, len1, len1)
                                            })
                                        }
                                        7 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: arg4 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        8 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: arg4 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    }
                                }
                            },
                            array_references: result5,
                            map_references: result10,
                        },
                        match arg10 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg11 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg12 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg12 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_push<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i64,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                    arg13: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    T::y_text_push(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                        match arg3 {
                            0 => None,
                            1 => {
                                Some({
                                    let base6 = arg7;
                                    let len6 = arg8;
                                    let mut result6 = Vec::with_capacity(len6 as usize);
                                    for i in 0..len6 {
                                        let base = base6 + i * 8;
                                        result6
                                            .push({
                                                let base5 = *((base + 0) as *const i32);
                                                let len5 = *((base + 4) as *const i32);
                                                let mut result5 = Vec::with_capacity(len5 as usize);
                                                for i in 0..len5 {
                                                    let base = base5 + i * 16;
                                                    result5
                                                        .push({
                                                            {
                                                                match i32::from(*((base + 0) as *const u8)) {
                                                                    0 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                    }
                                                                    1 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                    }
                                                                    2 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                            #[cfg(debug_assertions)]
                                                                            {
                                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                                    0 => false,
                                                                                    1 => true,
                                                                                    _ => {
                                                                                        ::core::panicking::panic_fmt(
                                                                                            format_args!("invalid bool discriminant"),
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    3 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                            *((base + 8) as *const f64),
                                                                        )
                                                                    }
                                                                    4 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                            *((base + 8) as *const i64),
                                                                        )
                                                                    }
                                                                    5 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                                            {
                                                                                #[cfg(debug_assertions)]
                                                                                {
                                                                                    String::from_utf8(
                                                                                            Vec::from_raw_parts(
                                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                                len3,
                                                                                                len3,
                                                                                            ),
                                                                                        )
                                                                                        .unwrap()
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    6 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                            let len4 = *((base + 12) as *const i32) as usize;
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len4,
                                                                                len4,
                                                                            )
                                                                        })
                                                                    }
                                                                    7 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    8 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid enum discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base5, (len5 as usize) * 16, 8);
                                                result5
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                    let base11 = arg9;
                                    let len11 = arg10;
                                    let mut result11 = Vec::with_capacity(len11 as usize);
                                    for i in 0..len11 {
                                        let base = base11 + i * 8;
                                        result11
                                            .push({
                                                let base10 = *((base + 0) as *const i32);
                                                let len10 = *((base + 4) as *const i32);
                                                let mut result10 = Vec::with_capacity(len10 as usize);
                                                for i in 0..len10 {
                                                    let base = base10 + i * 24;
                                                    result10
                                                        .push({
                                                            let len7 = *((base + 4) as *const i32) as usize;
                                                            (
                                                                {
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        String::from_utf8(
                                                                                Vec::from_raw_parts(
                                                                                    *((base + 0) as *const i32) as *mut _,
                                                                                    len7,
                                                                                    len7,
                                                                                ),
                                                                            )
                                                                            .unwrap()
                                                                    }
                                                                },
                                                                {
                                                                    {
                                                                        match i32::from(*((base + 8) as *const u8)) {
                                                                            0 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                            }
                                                                            1 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                            }
                                                                            2 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                                    #[cfg(debug_assertions)]
                                                                                    {
                                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                                            0 => false,
                                                                                            1 => true,
                                                                                            _ => {
                                                                                                ::core::panicking::panic_fmt(
                                                                                                    format_args!("invalid bool discriminant"),
                                                                                                );
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            3 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                    *((base + 16) as *const f64),
                                                                                )
                                                                            }
                                                                            4 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                    *((base + 16) as *const i64),
                                                                                )
                                                                            }
                                                                            5 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                                    {
                                                                                        #[cfg(debug_assertions)]
                                                                                        {
                                                                                            String::from_utf8(
                                                                                                    Vec::from_raw_parts(
                                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                                        len8,
                                                                                                        len8,
                                                                                                    ),
                                                                                                )
                                                                                                .unwrap()
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            6 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                                    let len9 = *((base + 20) as *const i32) as usize;
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len9,
                                                                                        len9,
                                                                                    )
                                                                                })
                                                                            }
                                                                            7 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            8 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                },
                                                            )
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base10, (len10 as usize) * 24, 8);
                                                result10
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: {
                                            {
                                                match arg4 {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match arg5 as i32 {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            f64::from_bits(arg5 as u64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            arg5,
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len1 = arg6 as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(arg5 as i32 as *mut _, len1, len1),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len2 = arg6 as usize;
                                                            Vec::from_raw_parts(arg5 as i32 as *mut _, len2, len2)
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: arg5 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: arg5 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        },
                                        array_references: result6,
                                        map_references: result11,
                                    }
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                        match arg11 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg12 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg13 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg13 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_delete<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::y_text_delete(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        arg2 as u32,
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg4 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_to_delta<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_to_delta(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                    ref_: arg2 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                    ref_: arg4 as u32,
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                        match arg5 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg6 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg7 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg7 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec44 = result0;
                    let len44 = vec44.len() as i32;
                    let layout44 = alloc::Layout::from_size_align_unchecked(
                        vec44.len() * 56,
                        8,
                    );
                    let result44 = if layout44.size() != 0 {
                        let ptr = alloc::alloc(layout44);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout44);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec44.into_iter().enumerate() {
                        let base = result44 as i32 + (i as i32) * 56;
                        {
                            match e {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaInsert(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (0i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaInsert {
                                        insert: insert2,
                                        attributes: attributes2,
                                    } = e;
                                    let vec3 = (insert2.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr() as i32;
                                    let len3 = vec3.len() as i32;
                                    ::core::mem::forget(vec3);
                                    *((base + 12) as *mut i32) = len3;
                                    *((base + 8) as *mut i32) = ptr3;
                                    match attributes2 {
                                        Some(e) => {
                                            *((base + 16) as *mut u8) = (1i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                item: item4,
                                                array_references: array_references4,
                                                map_references: map_references4,
                                            } = e;
                                            match item4 {
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (2i32) as u8;
                                                    *((base + 32)
                                                        as *mut u8) = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    }) as u8;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (3i32) as u8;
                                                    *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (4i32) as u8;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (5i32) as u8;
                                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                                    let ptr5 = vec5.as_ptr() as i32;
                                                    let len5 = vec5.len() as i32;
                                                    ::core::mem::forget(vec5);
                                                    *((base + 36) as *mut i32) = len5;
                                                    *((base + 32) as *mut i32) = ptr5;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (6i32) as u8;
                                                    let vec6 = (e).into_boxed_slice();
                                                    let ptr6 = vec6.as_ptr() as i32;
                                                    let len6 = vec6.len() as i32;
                                                    ::core::mem::forget(vec6);
                                                    *((base + 36) as *mut i32) = len6;
                                                    *((base + 32) as *mut i32) = ptr6;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (7i32) as u8;
                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: index7,
                                                    } = e;
                                                    *((base + 32)
                                                        as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (8i32) as u8;
                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: index8,
                                                    } = e;
                                                    *((base + 32)
                                                        as *mut i32) = wit_bindgen::rt::as_i32(index8);
                                                }
                                            };
                                            let vec14 = array_references4;
                                            let len14 = vec14.len() as i32;
                                            let layout14 = alloc::Layout::from_size_align_unchecked(
                                                vec14.len() * 8,
                                                4,
                                            );
                                            let result14 = if layout14.size() != 0 {
                                                let ptr = alloc::alloc(layout14);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout14);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec14.into_iter().enumerate() {
                                                let base = result14 as i32 + (i as i32) * 8;
                                                {
                                                    let vec13 = e;
                                                    let len13 = vec13.len() as i32;
                                                    let layout13 = alloc::Layout::from_size_align_unchecked(
                                                        vec13.len() * 16,
                                                        8,
                                                    );
                                                    let result13 = if layout13.size() != 0 {
                                                        let ptr = alloc::alloc(layout13);
                                                        if ptr.is_null() {
                                                            alloc::handle_alloc_error(layout13);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec13.into_iter().enumerate() {
                                                        let base = result13 as i32 + (i as i32) * 16;
                                                        {
                                                            match e {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                    *((base + 0) as *mut u8) = (0i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                    *((base + 0) as *mut u8) = (1i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (2i32) as u8;
                                                                    *((base + 8)
                                                                        as *mut u8) = (match e {
                                                                        true => 1,
                                                                        false => 0,
                                                                    }) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (3i32) as u8;
                                                                    *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (4i32) as u8;
                                                                    *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (5i32) as u8;
                                                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                                                    let ptr9 = vec9.as_ptr() as i32;
                                                                    let len9 = vec9.len() as i32;
                                                                    ::core::mem::forget(vec9);
                                                                    *((base + 12) as *mut i32) = len9;
                                                                    *((base + 8) as *mut i32) = ptr9;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (6i32) as u8;
                                                                    let vec10 = (e).into_boxed_slice();
                                                                    let ptr10 = vec10.as_ptr() as i32;
                                                                    let len10 = vec10.len() as i32;
                                                                    ::core::mem::forget(vec10);
                                                                    *((base + 12) as *mut i32) = len10;
                                                                    *((base + 8) as *mut i32) = ptr10;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (7i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: index11,
                                                                    } = e;
                                                                    *((base + 8)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (8i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: index12,
                                                                    } = e;
                                                                    *((base + 8)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                                }
                                                            };
                                                        }
                                                    }
                                                    *((base + 4) as *mut i32) = len13;
                                                    *((base + 0) as *mut i32) = result13 as i32;
                                                }
                                            }
                                            *((base + 44) as *mut i32) = len14;
                                            *((base + 40) as *mut i32) = result14 as i32;
                                            let vec22 = map_references4;
                                            let len22 = vec22.len() as i32;
                                            let layout22 = alloc::Layout::from_size_align_unchecked(
                                                vec22.len() * 8,
                                                4,
                                            );
                                            let result22 = if layout22.size() != 0 {
                                                let ptr = alloc::alloc(layout22);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout22);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec22.into_iter().enumerate() {
                                                let base = result22 as i32 + (i as i32) * 8;
                                                {
                                                    let vec21 = e;
                                                    let len21 = vec21.len() as i32;
                                                    let layout21 = alloc::Layout::from_size_align_unchecked(
                                                        vec21.len() * 24,
                                                        8,
                                                    );
                                                    let result21 = if layout21.size() != 0 {
                                                        let ptr = alloc::alloc(layout21);
                                                        if ptr.is_null() {
                                                            alloc::handle_alloc_error(layout21);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec21.into_iter().enumerate() {
                                                        let base = result21 as i32 + (i as i32) * 24;
                                                        {
                                                            let (t15_0, t15_1) = e;
                                                            let vec16 = (t15_0.into_bytes()).into_boxed_slice();
                                                            let ptr16 = vec16.as_ptr() as i32;
                                                            let len16 = vec16.len() as i32;
                                                            ::core::mem::forget(vec16);
                                                            *((base + 4) as *mut i32) = len16;
                                                            *((base + 0) as *mut i32) = ptr16;
                                                            match t15_1 {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                    *((base + 8) as *mut u8) = (0i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                    *((base + 8) as *mut u8) = (1i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (2i32) as u8;
                                                                    *((base + 16)
                                                                        as *mut u8) = (match e {
                                                                        true => 1,
                                                                        false => 0,
                                                                    }) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (3i32) as u8;
                                                                    *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (4i32) as u8;
                                                                    *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (5i32) as u8;
                                                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                                                    let ptr17 = vec17.as_ptr() as i32;
                                                                    let len17 = vec17.len() as i32;
                                                                    ::core::mem::forget(vec17);
                                                                    *((base + 20) as *mut i32) = len17;
                                                                    *((base + 16) as *mut i32) = ptr17;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (6i32) as u8;
                                                                    let vec18 = (e).into_boxed_slice();
                                                                    let ptr18 = vec18.as_ptr() as i32;
                                                                    let len18 = vec18.len() as i32;
                                                                    ::core::mem::forget(vec18);
                                                                    *((base + 20) as *mut i32) = len18;
                                                                    *((base + 16) as *mut i32) = ptr18;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (7i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: index19,
                                                                    } = e;
                                                                    *((base + 16)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index19);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (8i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: index20,
                                                                    } = e;
                                                                    *((base + 16)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                                                }
                                                            };
                                                        }
                                                    }
                                                    *((base + 4) as *mut i32) = len21;
                                                    *((base + 0) as *mut i32) = result21 as i32;
                                                }
                                            }
                                            *((base + 52) as *mut i32) = len22;
                                            *((base + 48) as *mut i32) = result22 as i32;
                                        }
                                        None => {
                                            *((base + 16) as *mut u8) = (0i32) as u8;
                                        }
                                    };
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaDelete(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (1i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaDelete {
                                        delete: delete23,
                                    } = e;
                                    *((base + 8)
                                        as *mut i32) = wit_bindgen::rt::as_i32(delete23);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaRetain(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (2i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaRetain {
                                        retain: retain24,
                                        attributes: attributes24,
                                    } = e;
                                    *((base + 8)
                                        as *mut i32) = wit_bindgen::rt::as_i32(retain24);
                                    match attributes24 {
                                        Some(e) => {
                                            *((base + 16) as *mut u8) = (1i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                item: item25,
                                                array_references: array_references25,
                                                map_references: map_references25,
                                            } = e;
                                            match item25 {
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (2i32) as u8;
                                                    *((base + 32)
                                                        as *mut u8) = (match e {
                                                        true => 1,
                                                        false => 0,
                                                    }) as u8;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (3i32) as u8;
                                                    *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (4i32) as u8;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (5i32) as u8;
                                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                                    let ptr26 = vec26.as_ptr() as i32;
                                                    let len26 = vec26.len() as i32;
                                                    ::core::mem::forget(vec26);
                                                    *((base + 36) as *mut i32) = len26;
                                                    *((base + 32) as *mut i32) = ptr26;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (6i32) as u8;
                                                    let vec27 = (e).into_boxed_slice();
                                                    let ptr27 = vec27.as_ptr() as i32;
                                                    let len27 = vec27.len() as i32;
                                                    ::core::mem::forget(vec27);
                                                    *((base + 36) as *mut i32) = len27;
                                                    *((base + 32) as *mut i32) = ptr27;
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (7i32) as u8;
                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: index28,
                                                    } = e;
                                                    *((base + 32)
                                                        as *mut i32) = wit_bindgen::rt::as_i32(index28);
                                                }
                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                    e,
                                                ) => {
                                                    *((base + 24) as *mut u8) = (8i32) as u8;
                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: index29,
                                                    } = e;
                                                    *((base + 32)
                                                        as *mut i32) = wit_bindgen::rt::as_i32(index29);
                                                }
                                            };
                                            let vec35 = array_references25;
                                            let len35 = vec35.len() as i32;
                                            let layout35 = alloc::Layout::from_size_align_unchecked(
                                                vec35.len() * 8,
                                                4,
                                            );
                                            let result35 = if layout35.size() != 0 {
                                                let ptr = alloc::alloc(layout35);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout35);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec35.into_iter().enumerate() {
                                                let base = result35 as i32 + (i as i32) * 8;
                                                {
                                                    let vec34 = e;
                                                    let len34 = vec34.len() as i32;
                                                    let layout34 = alloc::Layout::from_size_align_unchecked(
                                                        vec34.len() * 16,
                                                        8,
                                                    );
                                                    let result34 = if layout34.size() != 0 {
                                                        let ptr = alloc::alloc(layout34);
                                                        if ptr.is_null() {
                                                            alloc::handle_alloc_error(layout34);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec34.into_iter().enumerate() {
                                                        let base = result34 as i32 + (i as i32) * 16;
                                                        {
                                                            match e {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                    *((base + 0) as *mut u8) = (0i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                    *((base + 0) as *mut u8) = (1i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (2i32) as u8;
                                                                    *((base + 8)
                                                                        as *mut u8) = (match e {
                                                                        true => 1,
                                                                        false => 0,
                                                                    }) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (3i32) as u8;
                                                                    *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (4i32) as u8;
                                                                    *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (5i32) as u8;
                                                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                                                    let ptr30 = vec30.as_ptr() as i32;
                                                                    let len30 = vec30.len() as i32;
                                                                    ::core::mem::forget(vec30);
                                                                    *((base + 12) as *mut i32) = len30;
                                                                    *((base + 8) as *mut i32) = ptr30;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (6i32) as u8;
                                                                    let vec31 = (e).into_boxed_slice();
                                                                    let ptr31 = vec31.as_ptr() as i32;
                                                                    let len31 = vec31.len() as i32;
                                                                    ::core::mem::forget(vec31);
                                                                    *((base + 12) as *mut i32) = len31;
                                                                    *((base + 8) as *mut i32) = ptr31;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (7i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: index32,
                                                                    } = e;
                                                                    *((base + 8)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index32);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                    e,
                                                                ) => {
                                                                    *((base + 0) as *mut u8) = (8i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: index33,
                                                                    } = e;
                                                                    *((base + 8)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index33);
                                                                }
                                                            };
                                                        }
                                                    }
                                                    *((base + 4) as *mut i32) = len34;
                                                    *((base + 0) as *mut i32) = result34 as i32;
                                                }
                                            }
                                            *((base + 44) as *mut i32) = len35;
                                            *((base + 40) as *mut i32) = result35 as i32;
                                            let vec43 = map_references25;
                                            let len43 = vec43.len() as i32;
                                            let layout43 = alloc::Layout::from_size_align_unchecked(
                                                vec43.len() * 8,
                                                4,
                                            );
                                            let result43 = if layout43.size() != 0 {
                                                let ptr = alloc::alloc(layout43);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout43);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec43.into_iter().enumerate() {
                                                let base = result43 as i32 + (i as i32) * 8;
                                                {
                                                    let vec42 = e;
                                                    let len42 = vec42.len() as i32;
                                                    let layout42 = alloc::Layout::from_size_align_unchecked(
                                                        vec42.len() * 24,
                                                        8,
                                                    );
                                                    let result42 = if layout42.size() != 0 {
                                                        let ptr = alloc::alloc(layout42);
                                                        if ptr.is_null() {
                                                            alloc::handle_alloc_error(layout42);
                                                        }
                                                        ptr
                                                    } else {
                                                        ::core::ptr::null_mut()
                                                    };
                                                    for (i, e) in vec42.into_iter().enumerate() {
                                                        let base = result42 as i32 + (i as i32) * 24;
                                                        {
                                                            let (t36_0, t36_1) = e;
                                                            let vec37 = (t36_0.into_bytes()).into_boxed_slice();
                                                            let ptr37 = vec37.as_ptr() as i32;
                                                            let len37 = vec37.len() as i32;
                                                            ::core::mem::forget(vec37);
                                                            *((base + 4) as *mut i32) = len37;
                                                            *((base + 0) as *mut i32) = ptr37;
                                                            match t36_1 {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                                    *((base + 8) as *mut u8) = (0i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                                    *((base + 8) as *mut u8) = (1i32) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (2i32) as u8;
                                                                    *((base + 16)
                                                                        as *mut u8) = (match e {
                                                                        true => 1,
                                                                        false => 0,
                                                                    }) as u8;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (3i32) as u8;
                                                                    *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (4i32) as u8;
                                                                    *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (5i32) as u8;
                                                                    let vec38 = (e.into_bytes()).into_boxed_slice();
                                                                    let ptr38 = vec38.as_ptr() as i32;
                                                                    let len38 = vec38.len() as i32;
                                                                    ::core::mem::forget(vec38);
                                                                    *((base + 20) as *mut i32) = len38;
                                                                    *((base + 16) as *mut i32) = ptr38;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (6i32) as u8;
                                                                    let vec39 = (e).into_boxed_slice();
                                                                    let ptr39 = vec39.as_ptr() as i32;
                                                                    let len39 = vec39.len() as i32;
                                                                    ::core::mem::forget(vec39);
                                                                    *((base + 20) as *mut i32) = len39;
                                                                    *((base + 16) as *mut i32) = ptr39;
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (7i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: index40,
                                                                    } = e;
                                                                    *((base + 16)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index40);
                                                                }
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                                    e,
                                                                ) => {
                                                                    *((base + 8) as *mut u8) = (8i32) as u8;
                                                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: index41,
                                                                    } = e;
                                                                    *((base + 16)
                                                                        as *mut i32) = wit_bindgen::rt::as_i32(index41);
                                                                }
                                                            };
                                                        }
                                                    }
                                                    *((base + 4) as *mut i32) = len42;
                                                    *((base + 0) as *mut i32) = result42 as i32;
                                                }
                                            }
                                            *((base + 52) as *mut i32) = len43;
                                            *((base + 48) as *mut i32) = result43 as i32;
                                        }
                                        None => {
                                            *((base + 16) as *mut u8) = (0i32) as u8;
                                        }
                                    };
                                }
                            };
                        }
                    }
                    *((ptr1 + 4) as *mut i32) = len44;
                    *((ptr1 + 0) as *mut i32) = result44 as i32;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_text_to_delta<T: YDocMethods>(arg0: i32) {
                    let base14 = *((arg0 + 0) as *const i32);
                    let len14 = *((arg0 + 4) as *const i32);
                    for i in 0..len14 {
                        let base = base14 + i * 56;
                        {
                            match i32::from(*((base + 0) as *const u8)) {
                                0 => {
                                    wit_bindgen::rt::dealloc(
                                        *((base + 8) as *const i32),
                                        (*((base + 12) as *const i32)) as usize,
                                        1,
                                    );
                                    match i32::from(*((base + 16) as *const u8)) {
                                        0 => {}
                                        _ => {
                                            match i32::from(*((base + 24) as *const u8)) {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    wit_bindgen::rt::dealloc(
                                                        *((base + 32) as *const i32),
                                                        (*((base + 36) as *const i32)) as usize,
                                                        1,
                                                    );
                                                }
                                                6 => {
                                                    let base0 = *((base + 32) as *const i32);
                                                    let len0 = *((base + 36) as *const i32);
                                                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                            let base3 = *((base + 40) as *const i32);
                                            let len3 = *((base + 44) as *const i32);
                                            for i in 0..len3 {
                                                let base = base3 + i * 8;
                                                {
                                                    let base2 = *((base + 0) as *const i32);
                                                    let len2 = *((base + 4) as *const i32);
                                                    for i in 0..len2 {
                                                        let base = base2 + i * 16;
                                                        {
                                                            match i32::from(*((base + 0) as *const u8)) {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    wit_bindgen::rt::dealloc(
                                                                        *((base + 8) as *const i32),
                                                                        (*((base + 12) as *const i32)) as usize,
                                                                        1,
                                                                    );
                                                                }
                                                                6 => {
                                                                    let base1 = *((base + 8) as *const i32);
                                                                    let len1 = *((base + 12) as *const i32);
                                                                    wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                                            let base6 = *((base + 48) as *const i32);
                                            let len6 = *((base + 52) as *const i32);
                                            for i in 0..len6 {
                                                let base = base6 + i * 8;
                                                {
                                                    let base5 = *((base + 0) as *const i32);
                                                    let len5 = *((base + 4) as *const i32);
                                                    for i in 0..len5 {
                                                        let base = base5 + i * 24;
                                                        {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 0) as *const i32),
                                                                (*((base + 4) as *const i32)) as usize,
                                                                1,
                                                            );
                                                            match i32::from(*((base + 8) as *const u8)) {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    wit_bindgen::rt::dealloc(
                                                                        *((base + 16) as *const i32),
                                                                        (*((base + 20) as *const i32)) as usize,
                                                                        1,
                                                                    );
                                                                }
                                                                6 => {
                                                                    let base4 = *((base + 16) as *const i32);
                                                                    let len4 = *((base + 20) as *const i32);
                                                                    wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                        }
                                    }
                                }
                                1 => {}
                                _ => {
                                    match i32::from(*((base + 16) as *const u8)) {
                                        0 => {}
                                        _ => {
                                            match i32::from(*((base + 24) as *const u8)) {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    wit_bindgen::rt::dealloc(
                                                        *((base + 32) as *const i32),
                                                        (*((base + 36) as *const i32)) as usize,
                                                        1,
                                                    );
                                                }
                                                6 => {
                                                    let base7 = *((base + 32) as *const i32);
                                                    let len7 = *((base + 36) as *const i32);
                                                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                            let base10 = *((base + 40) as *const i32);
                                            let len10 = *((base + 44) as *const i32);
                                            for i in 0..len10 {
                                                let base = base10 + i * 8;
                                                {
                                                    let base9 = *((base + 0) as *const i32);
                                                    let len9 = *((base + 4) as *const i32);
                                                    for i in 0..len9 {
                                                        let base = base9 + i * 16;
                                                        {
                                                            match i32::from(*((base + 0) as *const u8)) {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    wit_bindgen::rt::dealloc(
                                                                        *((base + 8) as *const i32),
                                                                        (*((base + 12) as *const i32)) as usize,
                                                                        1,
                                                                    );
                                                                }
                                                                6 => {
                                                                    let base8 = *((base + 8) as *const i32);
                                                                    let len8 = *((base + 12) as *const i32);
                                                                    wit_bindgen::rt::dealloc(base8, (len8 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base9, (len9 as usize) * 16, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                                            let base13 = *((base + 48) as *const i32);
                                            let len13 = *((base + 52) as *const i32);
                                            for i in 0..len13 {
                                                let base = base13 + i * 8;
                                                {
                                                    let base12 = *((base + 0) as *const i32);
                                                    let len12 = *((base + 4) as *const i32);
                                                    for i in 0..len12 {
                                                        let base = base12 + i * 24;
                                                        {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 0) as *const i32),
                                                                (*((base + 4) as *const i32)) as usize,
                                                                1,
                                                            );
                                                            match i32::from(*((base + 8) as *const u8)) {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    wit_bindgen::rt::dealloc(
                                                                        *((base + 16) as *const i32),
                                                                        (*((base + 20) as *const i32)) as usize,
                                                                        1,
                                                                    );
                                                                }
                                                                6 => {
                                                                    let base11 = *((base + 16) as *const i32);
                                                                    let len11 = *((base + 20) as *const i32);
                                                                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base12, (len12 as usize) * 24, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base13, (len13 as usize) * 8, 4);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    wit_bindgen::rt::dealloc(base14, (len14 as usize) * 56, 8);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_observe<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_observe(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_text_observe_deep<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_text_observe_deep(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_snapshot<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::snapshot(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                        ref_: arg0 as u32,
                    });
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_equal_snapshot<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::equal_snapshot(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg0 as u32,
                        },
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg1 as u32,
                        },
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_snapshot_v1<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::encode_snapshot_v1(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_snapshot_v1<T: YDocMethods>(arg0: i32) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_snapshot_v2<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::encode_snapshot_v2(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    ::core::mem::forget(vec2);
                    *((ptr1 + 4) as *mut i32) = len2;
                    *((ptr1 + 0) as *mut i32) = ptr2;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_snapshot_v2<T: YDocMethods>(arg0: i32) {
                    let base0 = *((arg0 + 0) as *const i32);
                    let len0 = *((arg0 + 4) as *const i32);
                    wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                }
                #[doc(hidden)]
                pub unsafe fn call_decode_snapshot_v1<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg1 as usize;
                    let result1 = T::decode_snapshot_v1(
                        Vec::from_raw_parts(arg0 as *mut _, len0, len0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(e) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                ref_: ref_3,
                            } = e;
                            *((ptr2 + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_3);
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr2 + 8) as *mut i32) = len4;
                            *((ptr2 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_decode_snapshot_v1<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_decode_snapshot_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg1 as usize;
                    let result1 = T::decode_snapshot_v2(
                        Vec::from_raw_parts(arg0 as *mut _, len0, len0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Ok(e) => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                ref_: ref_3,
                            } = e;
                            *((ptr2 + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_3);
                        }
                        Err(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr2 + 8) as *mut i32) = len4;
                            *((ptr2 + 4) as *mut i32) = ptr4;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_decode_snapshot_v2<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_state_from_snapshot_v1<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::encode_state_from_snapshot_v1(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg1 as u32,
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Ok(e) => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            let vec2 = (e).into_boxed_slice();
                            let ptr2 = vec2.as_ptr() as i32;
                            let len2 = vec2.len() as i32;
                            ::core::mem::forget(vec2);
                            *((ptr1 + 8) as *mut i32) = len2;
                            *((ptr1 + 4) as *mut i32) = ptr2;
                        }
                        Err(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr1 + 8) as *mut i32) = len3;
                            *((ptr1 + 4) as *mut i32) = ptr3;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_state_from_snapshot_v1<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_encode_state_from_snapshot_v2<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::encode_state_from_snapshot_v2(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        },
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg1 as u32,
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Ok(e) => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            let vec2 = (e).into_boxed_slice();
                            let ptr2 = vec2.as_ptr() as i32;
                            let len2 = vec2.len() as i32;
                            ::core::mem::forget(vec2);
                            *((ptr1 + 8) as *mut i32) = len2;
                            *((ptr1 + 4) as *mut i32) = ptr2;
                        }
                        Err(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr1 + 8) as *mut i32) = len3;
                            *((ptr1 + 4) as *mut i32) = ptr3;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_encode_state_from_snapshot_v2<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            let base0 = *((arg0 + 4) as *const i32);
                            let len0 = *((arg0 + 8) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_new<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i64,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result11 = T::y_array_new(
                        match arg0 {
                            0 => None,
                            1 => {
                                Some({
                                    let base5 = arg4;
                                    let len5 = arg5;
                                    let mut result5 = Vec::with_capacity(len5 as usize);
                                    for i in 0..len5 {
                                        let base = base5 + i * 8;
                                        result5
                                            .push({
                                                let base4 = *((base + 0) as *const i32);
                                                let len4 = *((base + 4) as *const i32);
                                                let mut result4 = Vec::with_capacity(len4 as usize);
                                                for i in 0..len4 {
                                                    let base = base4 + i * 16;
                                                    result4
                                                        .push({
                                                            {
                                                                match i32::from(*((base + 0) as *const u8)) {
                                                                    0 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                    }
                                                                    1 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                    }
                                                                    2 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                            #[cfg(debug_assertions)]
                                                                            {
                                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                                    0 => false,
                                                                                    1 => true,
                                                                                    _ => {
                                                                                        ::core::panicking::panic_fmt(
                                                                                            format_args!("invalid bool discriminant"),
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    3 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                            *((base + 8) as *const f64),
                                                                        )
                                                                    }
                                                                    4 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                            *((base + 8) as *const i64),
                                                                        )
                                                                    }
                                                                    5 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                                            {
                                                                                #[cfg(debug_assertions)]
                                                                                {
                                                                                    String::from_utf8(
                                                                                            Vec::from_raw_parts(
                                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                                len2,
                                                                                                len2,
                                                                                            ),
                                                                                        )
                                                                                        .unwrap()
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    6 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len3,
                                                                                len3,
                                                                            )
                                                                        })
                                                                    }
                                                                    7 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    8 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid enum discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                                result4
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                                    let base10 = arg6;
                                    let len10 = arg7;
                                    let mut result10 = Vec::with_capacity(len10 as usize);
                                    for i in 0..len10 {
                                        let base = base10 + i * 8;
                                        result10
                                            .push({
                                                let base9 = *((base + 0) as *const i32);
                                                let len9 = *((base + 4) as *const i32);
                                                let mut result9 = Vec::with_capacity(len9 as usize);
                                                for i in 0..len9 {
                                                    let base = base9 + i * 24;
                                                    result9
                                                        .push({
                                                            let len6 = *((base + 4) as *const i32) as usize;
                                                            (
                                                                {
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        String::from_utf8(
                                                                                Vec::from_raw_parts(
                                                                                    *((base + 0) as *const i32) as *mut _,
                                                                                    len6,
                                                                                    len6,
                                                                                ),
                                                                            )
                                                                            .unwrap()
                                                                    }
                                                                },
                                                                {
                                                                    {
                                                                        match i32::from(*((base + 8) as *const u8)) {
                                                                            0 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                            }
                                                                            1 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                            }
                                                                            2 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                                    #[cfg(debug_assertions)]
                                                                                    {
                                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                                            0 => false,
                                                                                            1 => true,
                                                                                            _ => {
                                                                                                ::core::panicking::panic_fmt(
                                                                                                    format_args!("invalid bool discriminant"),
                                                                                                );
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            3 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                    *((base + 16) as *const f64),
                                                                                )
                                                                            }
                                                                            4 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                    *((base + 16) as *const i64),
                                                                                )
                                                                            }
                                                                            5 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                                    {
                                                                                        #[cfg(debug_assertions)]
                                                                                        {
                                                                                            String::from_utf8(
                                                                                                    Vec::from_raw_parts(
                                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                                        len7,
                                                                                                        len7,
                                                                                                    ),
                                                                                                )
                                                                                                .unwrap()
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            6 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len8,
                                                                                        len8,
                                                                                    )
                                                                                })
                                                                            }
                                                                            7 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            8 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                },
                                                            )
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                                result9
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: {
                                            {
                                                match arg1 {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match arg2 as i32 {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            f64::from_bits(arg2 as u64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            arg2,
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len0 = arg3 as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len1 = arg3 as usize;
                                                            Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: arg2 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: arg2 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        },
                                        array_references: result5,
                                        map_references: result10,
                                    }
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                        ref_: ref_12,
                    } = result11;
                    wit_bindgen::rt::as_i32(ref_12)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_prelim<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_prelim(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_length<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_length(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::as_i32(result0)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_to_json<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_to_json(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                        item: item2,
                        array_references: array_references2,
                        map_references: map_references2,
                    } = result0;
                    match item2 {
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (2i32) as u8;
                            *((ptr1 + 8)
                                as *mut u8) = (match e {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (3i32) as u8;
                            *((ptr1 + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (4i32) as u8;
                            *((ptr1 + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (5i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr1 + 12) as *mut i32) = len3;
                            *((ptr1 + 8) as *mut i32) = ptr3;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (6i32) as u8;
                            let vec4 = (e).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr1 + 12) as *mut i32) = len4;
                            *((ptr1 + 8) as *mut i32) = ptr4;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (7i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                index: index5,
                            } = e;
                            *((ptr1 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index5);
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (8i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                index: index6,
                            } = e;
                            *((ptr1 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index6);
                        }
                    };
                    let vec12 = array_references2;
                    let len12 = vec12.len() as i32;
                    let layout12 = alloc::Layout::from_size_align_unchecked(
                        vec12.len() * 8,
                        4,
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = alloc::alloc(layout12);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12 as i32 + (i as i32) * 8;
                        {
                            let vec11 = e;
                            let len11 = vec11.len() as i32;
                            let layout11 = alloc::Layout::from_size_align_unchecked(
                                vec11.len() * 16,
                                8,
                            );
                            let result11 = if layout11.size() != 0 {
                                let ptr = alloc::alloc(layout11);
                                if ptr.is_null() {
                                    alloc::handle_alloc_error(layout11);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec11.into_iter().enumerate() {
                                let base = result11 as i32 + (i as i32) * 16;
                                {
                                    match e {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((base + 0) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((base + 0) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (2i32) as u8;
                                            *((base + 8)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (3i32) as u8;
                                            *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (4i32) as u8;
                                            *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (5i32) as u8;
                                            let vec7 = (e.into_bytes()).into_boxed_slice();
                                            let ptr7 = vec7.as_ptr() as i32;
                                            let len7 = vec7.len() as i32;
                                            ::core::mem::forget(vec7);
                                            *((base + 12) as *mut i32) = len7;
                                            *((base + 8) as *mut i32) = ptr7;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (6i32) as u8;
                                            let vec8 = (e).into_boxed_slice();
                                            let ptr8 = vec8.as_ptr() as i32;
                                            let len8 = vec8.len() as i32;
                                            ::core::mem::forget(vec8);
                                            *((base + 12) as *mut i32) = len8;
                                            *((base + 8) as *mut i32) = ptr8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index9,
                                            } = e;
                                            *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(index9);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index10,
                                            } = e;
                                            *((base + 8)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                        }
                                    };
                                }
                            }
                            *((base + 4) as *mut i32) = len11;
                            *((base + 0) as *mut i32) = result11 as i32;
                        }
                    }
                    *((ptr1 + 20) as *mut i32) = len12;
                    *((ptr1 + 16) as *mut i32) = result12 as i32;
                    let vec20 = map_references2;
                    let len20 = vec20.len() as i32;
                    let layout20 = alloc::Layout::from_size_align_unchecked(
                        vec20.len() * 8,
                        4,
                    );
                    let result20 = if layout20.size() != 0 {
                        let ptr = alloc::alloc(layout20);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout20);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec20.into_iter().enumerate() {
                        let base = result20 as i32 + (i as i32) * 8;
                        {
                            let vec19 = e;
                            let len19 = vec19.len() as i32;
                            let layout19 = alloc::Layout::from_size_align_unchecked(
                                vec19.len() * 24,
                                8,
                            );
                            let result19 = if layout19.size() != 0 {
                                let ptr = alloc::alloc(layout19);
                                if ptr.is_null() {
                                    alloc::handle_alloc_error(layout19);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec19.into_iter().enumerate() {
                                let base = result19 as i32 + (i as i32) * 24;
                                {
                                    let (t13_0, t13_1) = e;
                                    let vec14 = (t13_0.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr() as i32;
                                    let len14 = vec14.len() as i32;
                                    ::core::mem::forget(vec14);
                                    *((base + 4) as *mut i32) = len14;
                                    *((base + 0) as *mut i32) = ptr14;
                                    match t13_1 {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                            *((base + 16)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                            let vec15 = (e.into_bytes()).into_boxed_slice();
                                            let ptr15 = vec15.as_ptr() as i32;
                                            let len15 = vec15.len() as i32;
                                            ::core::mem::forget(vec15);
                                            *((base + 20) as *mut i32) = len15;
                                            *((base + 16) as *mut i32) = ptr15;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                            let vec16 = (e).into_boxed_slice();
                                            let ptr16 = vec16.as_ptr() as i32;
                                            let len16 = vec16.len() as i32;
                                            ::core::mem::forget(vec16);
                                            *((base + 20) as *mut i32) = len16;
                                            *((base + 16) as *mut i32) = ptr16;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index17,
                                            } = e;
                                            *((base + 16)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index17);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index18,
                                            } = e;
                                            *((base + 16)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                        }
                                    };
                                }
                            }
                            *((base + 4) as *mut i32) = len19;
                            *((base + 0) as *mut i32) = result19 as i32;
                        }
                    }
                    *((ptr1 + 28) as *mut i32) = len20;
                    *((ptr1 + 24) as *mut i32) = result20 as i32;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_array_to_json<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        1 => {}
                        2 => {}
                        3 => {}
                        4 => {}
                        5 => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 8) as *const i32),
                                (*((arg0 + 12) as *const i32)) as usize,
                                1,
                            );
                        }
                        6 => {
                            let base0 = *((arg0 + 8) as *const i32);
                            let len0 = *((arg0 + 12) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        7 => {}
                        _ => {}
                    }
                    let base3 = *((arg0 + 16) as *const i32);
                    let len3 = *((arg0 + 20) as *const i32);
                    for i in 0..len3 {
                        let base = base3 + i * 8;
                        {
                            let base2 = *((base + 0) as *const i32);
                            let len2 = *((base + 4) as *const i32);
                            for i in 0..len2 {
                                let base = base2 + i * 16;
                                {
                                    match i32::from(*((base + 0) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((base + 8) as *const i32),
                                                (*((base + 12) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base1 = *((base + 8) as *const i32);
                                            let len1 = *((base + 12) as *const i32);
                                            wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                        }
                    }
                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                    let base6 = *((arg0 + 24) as *const i32);
                    let len6 = *((arg0 + 28) as *const i32);
                    for i in 0..len6 {
                        let base = base6 + i * 8;
                        {
                            let base5 = *((base + 0) as *const i32);
                            let len5 = *((base + 4) as *const i32);
                            for i in 0..len5 {
                                let base = base5 + i * 24;
                                {
                                    wit_bindgen::rt::dealloc(
                                        *((base + 0) as *const i32),
                                        (*((base + 4) as *const i32)) as usize,
                                        1,
                                    );
                                    match i32::from(*((base + 8) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((base + 16) as *const i32),
                                                (*((base + 20) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base4 = *((base + 16) as *const i32);
                                            let len4 = *((base + 20) as *const i32);
                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                        }
                    }
                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_insert<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i64,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let base5 = arg5;
                    let len5 = arg6;
                    let mut result5 = Vec::with_capacity(len5 as usize);
                    for i in 0..len5 {
                        let base = base5 + i * 8;
                        result5
                            .push({
                                let base4 = *((base + 0) as *const i32);
                                let len4 = *((base + 4) as *const i32);
                                let mut result4 = Vec::with_capacity(len4 as usize);
                                for i in 0..len4 {
                                    let base = base4 + i * 16;
                                    result4
                                        .push({
                                            {
                                                match i32::from(*((base + 0) as *const u8)) {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            *((base + 8) as *const f64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            *((base + 8) as *const i64),
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len2,
                                                                                len2,
                                                                            ),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                            Vec::from_raw_parts(
                                                                *((base + 8) as *const i32) as *mut _,
                                                                len3,
                                                                len3,
                                                            )
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        });
                                }
                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                result4
                            });
                    }
                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                    let base10 = arg7;
                    let len10 = arg8;
                    let mut result10 = Vec::with_capacity(len10 as usize);
                    for i in 0..len10 {
                        let base = base10 + i * 8;
                        result10
                            .push({
                                let base9 = *((base + 0) as *const i32);
                                let len9 = *((base + 4) as *const i32);
                                let mut result9 = Vec::with_capacity(len9 as usize);
                                for i in 0..len9 {
                                    let base = base9 + i * 24;
                                    result9
                                        .push({
                                            let len6 = *((base + 4) as *const i32) as usize;
                                            (
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((base + 0) as *const i32) as *mut _,
                                                                    len6,
                                                                    len6,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                },
                                                {
                                                    {
                                                        match i32::from(*((base + 8) as *const u8)) {
                                                            0 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                            }
                                                            1 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                            }
                                                            2 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                            0 => false,
                                                                            1 => true,
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid bool discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            3 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    *((base + 16) as *const f64),
                                                                )
                                                            }
                                                            4 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    *((base + 16) as *const i64),
                                                                )
                                                            }
                                                            5 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                    {
                                                                        #[cfg(debug_assertions)]
                                                                        {
                                                                            String::from_utf8(
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len7,
                                                                                        len7,
                                                                                    ),
                                                                                )
                                                                                .unwrap()
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            6 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                    Vec::from_raw_parts(
                                                                        *((base + 16) as *const i32) as *mut _,
                                                                        len8,
                                                                        len8,
                                                                    )
                                                                })
                                                            }
                                                            7 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            8 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            _ => {
                                                                ::core::panicking::panic_fmt(
                                                                    format_args!("invalid enum discriminant"),
                                                                );
                                                            }
                                                        }
                                                    }
                                                },
                                            )
                                        });
                                }
                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                result9
                            });
                    }
                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                    T::y_array_insert(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: {
                                {
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                        }
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                        }
                                        2 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match arg3 as i32 {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        3 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                f64::from_bits(arg3 as u64),
                                            )
                                        }
                                        4 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                arg3,
                                            )
                                        }
                                        5 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                let len0 = arg4 as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(arg3 as i32 as *mut _, len0, len0),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        6 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                let len1 = arg4 as usize;
                                                Vec::from_raw_parts(arg3 as i32 as *mut _, len1, len1)
                                            })
                                        }
                                        7 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: arg3 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        8 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: arg3 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    }
                                }
                            },
                            array_references: result5,
                            map_references: result10,
                        },
                        match arg9 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg10 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg11 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg11 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_push<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i64,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let base5 = arg4;
                    let len5 = arg5;
                    let mut result5 = Vec::with_capacity(len5 as usize);
                    for i in 0..len5 {
                        let base = base5 + i * 8;
                        result5
                            .push({
                                let base4 = *((base + 0) as *const i32);
                                let len4 = *((base + 4) as *const i32);
                                let mut result4 = Vec::with_capacity(len4 as usize);
                                for i in 0..len4 {
                                    let base = base4 + i * 16;
                                    result4
                                        .push({
                                            {
                                                match i32::from(*((base + 0) as *const u8)) {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            *((base + 8) as *const f64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            *((base + 8) as *const i64),
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len2,
                                                                                len2,
                                                                            ),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                            Vec::from_raw_parts(
                                                                *((base + 8) as *const i32) as *mut _,
                                                                len3,
                                                                len3,
                                                            )
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        });
                                }
                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                result4
                            });
                    }
                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                    let base10 = arg6;
                    let len10 = arg7;
                    let mut result10 = Vec::with_capacity(len10 as usize);
                    for i in 0..len10 {
                        let base = base10 + i * 8;
                        result10
                            .push({
                                let base9 = *((base + 0) as *const i32);
                                let len9 = *((base + 4) as *const i32);
                                let mut result9 = Vec::with_capacity(len9 as usize);
                                for i in 0..len9 {
                                    let base = base9 + i * 24;
                                    result9
                                        .push({
                                            let len6 = *((base + 4) as *const i32) as usize;
                                            (
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((base + 0) as *const i32) as *mut _,
                                                                    len6,
                                                                    len6,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                },
                                                {
                                                    {
                                                        match i32::from(*((base + 8) as *const u8)) {
                                                            0 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                            }
                                                            1 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                            }
                                                            2 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                            0 => false,
                                                                            1 => true,
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid bool discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            3 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    *((base + 16) as *const f64),
                                                                )
                                                            }
                                                            4 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    *((base + 16) as *const i64),
                                                                )
                                                            }
                                                            5 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                    {
                                                                        #[cfg(debug_assertions)]
                                                                        {
                                                                            String::from_utf8(
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len7,
                                                                                        len7,
                                                                                    ),
                                                                                )
                                                                                .unwrap()
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            6 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                    Vec::from_raw_parts(
                                                                        *((base + 16) as *const i32) as *mut _,
                                                                        len8,
                                                                        len8,
                                                                    )
                                                                })
                                                            }
                                                            7 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            8 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            _ => {
                                                                ::core::panicking::panic_fmt(
                                                                    format_args!("invalid enum discriminant"),
                                                                );
                                                            }
                                                        }
                                                    }
                                                },
                                            )
                                        });
                                }
                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                result9
                            });
                    }
                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                    T::y_array_push(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: {
                                {
                                    match arg1 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                        }
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                        }
                                        2 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match arg2 as i32 {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        3 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                f64::from_bits(arg2 as u64),
                                            )
                                        }
                                        4 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                arg2,
                                            )
                                        }
                                        5 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                let len0 = arg3 as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        6 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                let len1 = arg3 as usize;
                                                Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                            })
                                        }
                                        7 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: arg2 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        8 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: arg2 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    }
                                }
                            },
                            array_references: result5,
                            map_references: result10,
                        },
                        match arg8 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg9 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg10 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg10 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_delete<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::y_array_delete(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        arg2 as u32,
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg4 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_move_content<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::y_array_move_content(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        arg2 as u32,
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg4 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_get<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_get(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        match arg2 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg3 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg4 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg4 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Ok(e) => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            match e {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (0i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: item2,
                                        array_references: array_references2,
                                        map_references: map_references2,
                                    } = e;
                                    match item2 {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((ptr1 + 16) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((ptr1 + 16) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (2i32) as u8;
                                            *((ptr1 + 24)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (3i32) as u8;
                                            *((ptr1 + 24) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (4i32) as u8;
                                            *((ptr1 + 24) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (5i32) as u8;
                                            let vec3 = (e.into_bytes()).into_boxed_slice();
                                            let ptr3 = vec3.as_ptr() as i32;
                                            let len3 = vec3.len() as i32;
                                            ::core::mem::forget(vec3);
                                            *((ptr1 + 28) as *mut i32) = len3;
                                            *((ptr1 + 24) as *mut i32) = ptr3;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (6i32) as u8;
                                            let vec4 = (e).into_boxed_slice();
                                            let ptr4 = vec4.as_ptr() as i32;
                                            let len4 = vec4.len() as i32;
                                            ::core::mem::forget(vec4);
                                            *((ptr1 + 28) as *mut i32) = len4;
                                            *((ptr1 + 24) as *mut i32) = ptr4;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index5,
                                            } = e;
                                            *((ptr1 + 24)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index5);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((ptr1 + 16) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index6,
                                            } = e;
                                            *((ptr1 + 24)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                        }
                                    };
                                    let vec12 = array_references2;
                                    let len12 = vec12.len() as i32;
                                    let layout12 = alloc::Layout::from_size_align_unchecked(
                                        vec12.len() * 8,
                                        4,
                                    );
                                    let result12 = if layout12.size() != 0 {
                                        let ptr = alloc::alloc(layout12);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout12);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec12.into_iter().enumerate() {
                                        let base = result12 as i32 + (i as i32) * 8;
                                        {
                                            let vec11 = e;
                                            let len11 = vec11.len() as i32;
                                            let layout11 = alloc::Layout::from_size_align_unchecked(
                                                vec11.len() * 16,
                                                8,
                                            );
                                            let result11 = if layout11.size() != 0 {
                                                let ptr = alloc::alloc(layout11);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout11);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec11.into_iter().enumerate() {
                                                let base = result11 as i32 + (i as i32) * 16;
                                                {
                                                    match e {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 0) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 0) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (2i32) as u8;
                                                            *((base + 8)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (3i32) as u8;
                                                            *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (4i32) as u8;
                                                            *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (5i32) as u8;
                                                            let vec7 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr7 = vec7.as_ptr() as i32;
                                                            let len7 = vec7.len() as i32;
                                                            ::core::mem::forget(vec7);
                                                            *((base + 12) as *mut i32) = len7;
                                                            *((base + 8) as *mut i32) = ptr7;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (6i32) as u8;
                                                            let vec8 = (e).into_boxed_slice();
                                                            let ptr8 = vec8.as_ptr() as i32;
                                                            let len8 = vec8.len() as i32;
                                                            ::core::mem::forget(vec8);
                                                            *((base + 12) as *mut i32) = len8;
                                                            *((base + 8) as *mut i32) = ptr8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index9,
                                                            } = e;
                                                            *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(index9);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index10,
                                                            } = e;
                                                            *((base + 8)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len11;
                                            *((base + 0) as *mut i32) = result11 as i32;
                                        }
                                    }
                                    *((ptr1 + 36) as *mut i32) = len12;
                                    *((ptr1 + 32) as *mut i32) = result12 as i32;
                                    let vec20 = map_references2;
                                    let len20 = vec20.len() as i32;
                                    let layout20 = alloc::Layout::from_size_align_unchecked(
                                        vec20.len() * 8,
                                        4,
                                    );
                                    let result20 = if layout20.size() != 0 {
                                        let ptr = alloc::alloc(layout20);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout20);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec20.into_iter().enumerate() {
                                        let base = result20 as i32 + (i as i32) * 8;
                                        {
                                            let vec19 = e;
                                            let len19 = vec19.len() as i32;
                                            let layout19 = alloc::Layout::from_size_align_unchecked(
                                                vec19.len() * 24,
                                                8,
                                            );
                                            let result19 = if layout19.size() != 0 {
                                                let ptr = alloc::alloc(layout19);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout19);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec19.into_iter().enumerate() {
                                                let base = result19 as i32 + (i as i32) * 24;
                                                {
                                                    let (t13_0, t13_1) = e;
                                                    let vec14 = (t13_0.into_bytes()).into_boxed_slice();
                                                    let ptr14 = vec14.as_ptr() as i32;
                                                    let len14 = vec14.len() as i32;
                                                    ::core::mem::forget(vec14);
                                                    *((base + 4) as *mut i32) = len14;
                                                    *((base + 0) as *mut i32) = ptr14;
                                                    match t13_1 {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                                            *((base + 16)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                                            let vec15 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr15 = vec15.as_ptr() as i32;
                                                            let len15 = vec15.len() as i32;
                                                            ::core::mem::forget(vec15);
                                                            *((base + 20) as *mut i32) = len15;
                                                            *((base + 16) as *mut i32) = ptr15;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                                            let vec16 = (e).into_boxed_slice();
                                                            let ptr16 = vec16.as_ptr() as i32;
                                                            let len16 = vec16.len() as i32;
                                                            ::core::mem::forget(vec16);
                                                            *((base + 20) as *mut i32) = len16;
                                                            *((base + 16) as *mut i32) = ptr16;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index17,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index17);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index18,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len19;
                                            *((base + 0) as *mut i32) = result19 as i32;
                                        }
                                    }
                                    *((ptr1 + 44) as *mut i32) = len20;
                                    *((ptr1 + 40) as *mut i32) = result20 as i32;
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (1i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                        ref_: ref_21,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_21);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (2i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                        ref_: ref_22,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_22);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (3i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                        ref_: ref_23,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_23);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (4i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                        ref_: ref_24,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_24);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (5i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                        ref_: ref_25,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (6i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                        ref_: ref_26,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                    e,
                                ) => {
                                    *((ptr1 + 8) as *mut u8) = (7i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                        ref_: ref_27,
                                    } = e;
                                    *((ptr1 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                }
                            };
                        }
                        Err(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let vec28 = (e.into_bytes()).into_boxed_slice();
                            let ptr28 = vec28.as_ptr() as i32;
                            let len28 = vec28.len() as i32;
                            ::core::mem::forget(vec28);
                            *((ptr1 + 12) as *mut i32) = len28;
                            *((ptr1 + 8) as *mut i32) = ptr28;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_array_get<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {
                            match i32::from(*((arg0 + 8) as *const u8)) {
                                0 => {
                                    match i32::from(*((arg0 + 16) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((arg0 + 24) as *const i32),
                                                (*((arg0 + 28) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base0 = *((arg0 + 24) as *const i32);
                                            let len0 = *((arg0 + 28) as *const i32);
                                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                    let base3 = *((arg0 + 32) as *const i32);
                                    let len3 = *((arg0 + 36) as *const i32);
                                    for i in 0..len3 {
                                        let base = base3 + i * 8;
                                        {
                                            let base2 = *((base + 0) as *const i32);
                                            let len2 = *((base + 4) as *const i32);
                                            for i in 0..len2 {
                                                let base = base2 + i * 16;
                                                {
                                                    match i32::from(*((base + 0) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 8) as *const i32),
                                                                (*((base + 12) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base1 = *((base + 8) as *const i32);
                                                            let len1 = *((base + 12) as *const i32);
                                                            wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                                    let base6 = *((arg0 + 40) as *const i32);
                                    let len6 = *((arg0 + 44) as *const i32);
                                    for i in 0..len6 {
                                        let base = base6 + i * 8;
                                        {
                                            let base5 = *((base + 0) as *const i32);
                                            let len5 = *((base + 4) as *const i32);
                                            for i in 0..len5 {
                                                let base = base5 + i * 24;
                                                {
                                                    wit_bindgen::rt::dealloc(
                                                        *((base + 0) as *const i32),
                                                        (*((base + 4) as *const i32)) as usize,
                                                        1,
                                                    );
                                                    match i32::from(*((base + 8) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 16) as *const i32),
                                                                (*((base + 20) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base4 = *((base + 16) as *const i32);
                                                            let len4 = *((base + 20) as *const i32);
                                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                }
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {}
                                6 => {}
                                _ => {}
                            }
                        }
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 8) as *const i32),
                                (*((arg0 + 12) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_values<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_values(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec28 = result0;
                    let len28 = vec28.len() as i32;
                    let layout28 = alloc::Layout::from_size_align_unchecked(
                        vec28.len() * 40,
                        8,
                    );
                    let result28 = if layout28.size() != 0 {
                        let ptr = alloc::alloc(layout28);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout28);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec28.into_iter().enumerate() {
                        let base = result28 as i32 + (i as i32) * 40;
                        {
                            match e {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (0i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: item2,
                                        array_references: array_references2,
                                        map_references: map_references2,
                                    } = e;
                                    match item2 {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                            *((base + 16)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                            let vec3 = (e.into_bytes()).into_boxed_slice();
                                            let ptr3 = vec3.as_ptr() as i32;
                                            let len3 = vec3.len() as i32;
                                            ::core::mem::forget(vec3);
                                            *((base + 20) as *mut i32) = len3;
                                            *((base + 16) as *mut i32) = ptr3;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                            let vec4 = (e).into_boxed_slice();
                                            let ptr4 = vec4.as_ptr() as i32;
                                            let len4 = vec4.len() as i32;
                                            ::core::mem::forget(vec4);
                                            *((base + 20) as *mut i32) = len4;
                                            *((base + 16) as *mut i32) = ptr4;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index5,
                                            } = e;
                                            *((base + 16)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index5);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index6,
                                            } = e;
                                            *((base + 16)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                        }
                                    };
                                    let vec12 = array_references2;
                                    let len12 = vec12.len() as i32;
                                    let layout12 = alloc::Layout::from_size_align_unchecked(
                                        vec12.len() * 8,
                                        4,
                                    );
                                    let result12 = if layout12.size() != 0 {
                                        let ptr = alloc::alloc(layout12);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout12);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec12.into_iter().enumerate() {
                                        let base = result12 as i32 + (i as i32) * 8;
                                        {
                                            let vec11 = e;
                                            let len11 = vec11.len() as i32;
                                            let layout11 = alloc::Layout::from_size_align_unchecked(
                                                vec11.len() * 16,
                                                8,
                                            );
                                            let result11 = if layout11.size() != 0 {
                                                let ptr = alloc::alloc(layout11);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout11);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec11.into_iter().enumerate() {
                                                let base = result11 as i32 + (i as i32) * 16;
                                                {
                                                    match e {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 0) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 0) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (2i32) as u8;
                                                            *((base + 8)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (3i32) as u8;
                                                            *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (4i32) as u8;
                                                            *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (5i32) as u8;
                                                            let vec7 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr7 = vec7.as_ptr() as i32;
                                                            let len7 = vec7.len() as i32;
                                                            ::core::mem::forget(vec7);
                                                            *((base + 12) as *mut i32) = len7;
                                                            *((base + 8) as *mut i32) = ptr7;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (6i32) as u8;
                                                            let vec8 = (e).into_boxed_slice();
                                                            let ptr8 = vec8.as_ptr() as i32;
                                                            let len8 = vec8.len() as i32;
                                                            ::core::mem::forget(vec8);
                                                            *((base + 12) as *mut i32) = len8;
                                                            *((base + 8) as *mut i32) = ptr8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index9,
                                                            } = e;
                                                            *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(index9);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index10,
                                                            } = e;
                                                            *((base + 8)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len11;
                                            *((base + 0) as *mut i32) = result11 as i32;
                                        }
                                    }
                                    *((base + 28) as *mut i32) = len12;
                                    *((base + 24) as *mut i32) = result12 as i32;
                                    let vec20 = map_references2;
                                    let len20 = vec20.len() as i32;
                                    let layout20 = alloc::Layout::from_size_align_unchecked(
                                        vec20.len() * 8,
                                        4,
                                    );
                                    let result20 = if layout20.size() != 0 {
                                        let ptr = alloc::alloc(layout20);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout20);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec20.into_iter().enumerate() {
                                        let base = result20 as i32 + (i as i32) * 8;
                                        {
                                            let vec19 = e;
                                            let len19 = vec19.len() as i32;
                                            let layout19 = alloc::Layout::from_size_align_unchecked(
                                                vec19.len() * 24,
                                                8,
                                            );
                                            let result19 = if layout19.size() != 0 {
                                                let ptr = alloc::alloc(layout19);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout19);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec19.into_iter().enumerate() {
                                                let base = result19 as i32 + (i as i32) * 24;
                                                {
                                                    let (t13_0, t13_1) = e;
                                                    let vec14 = (t13_0.into_bytes()).into_boxed_slice();
                                                    let ptr14 = vec14.as_ptr() as i32;
                                                    let len14 = vec14.len() as i32;
                                                    ::core::mem::forget(vec14);
                                                    *((base + 4) as *mut i32) = len14;
                                                    *((base + 0) as *mut i32) = ptr14;
                                                    match t13_1 {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                                            *((base + 16)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                                            let vec15 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr15 = vec15.as_ptr() as i32;
                                                            let len15 = vec15.len() as i32;
                                                            ::core::mem::forget(vec15);
                                                            *((base + 20) as *mut i32) = len15;
                                                            *((base + 16) as *mut i32) = ptr15;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                                            let vec16 = (e).into_boxed_slice();
                                                            let ptr16 = vec16.as_ptr() as i32;
                                                            let len16 = vec16.len() as i32;
                                                            ::core::mem::forget(vec16);
                                                            *((base + 20) as *mut i32) = len16;
                                                            *((base + 16) as *mut i32) = ptr16;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index17,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index17);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index18,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len19;
                                            *((base + 0) as *mut i32) = result19 as i32;
                                        }
                                    }
                                    *((base + 36) as *mut i32) = len20;
                                    *((base + 32) as *mut i32) = result20 as i32;
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (1i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                        ref_: ref_21,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_21);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (2i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                        ref_: ref_22,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_22);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (3i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                        ref_: ref_23,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_23);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (4i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                        ref_: ref_24,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_24);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (5i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                        ref_: ref_25,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (6i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                        ref_: ref_26,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                    e,
                                ) => {
                                    *((base + 0) as *mut u8) = (7i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                        ref_: ref_27,
                                    } = e;
                                    *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                }
                            };
                        }
                    }
                    *((ptr1 + 4) as *mut i32) = len28;
                    *((ptr1 + 0) as *mut i32) = result28 as i32;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_array_values<T: YDocMethods>(arg0: i32) {
                    let base7 = *((arg0 + 0) as *const i32);
                    let len7 = *((arg0 + 4) as *const i32);
                    for i in 0..len7 {
                        let base = base7 + i * 40;
                        {
                            match i32::from(*((base + 0) as *const u8)) {
                                0 => {
                                    match i32::from(*((base + 8) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((base + 16) as *const i32),
                                                (*((base + 20) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base0 = *((base + 16) as *const i32);
                                            let len0 = *((base + 20) as *const i32);
                                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                    let base3 = *((base + 24) as *const i32);
                                    let len3 = *((base + 28) as *const i32);
                                    for i in 0..len3 {
                                        let base = base3 + i * 8;
                                        {
                                            let base2 = *((base + 0) as *const i32);
                                            let len2 = *((base + 4) as *const i32);
                                            for i in 0..len2 {
                                                let base = base2 + i * 16;
                                                {
                                                    match i32::from(*((base + 0) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 8) as *const i32),
                                                                (*((base + 12) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base1 = *((base + 8) as *const i32);
                                                            let len1 = *((base + 12) as *const i32);
                                                            wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                                    let base6 = *((base + 32) as *const i32);
                                    let len6 = *((base + 36) as *const i32);
                                    for i in 0..len6 {
                                        let base = base6 + i * 8;
                                        {
                                            let base5 = *((base + 0) as *const i32);
                                            let len5 = *((base + 4) as *const i32);
                                            for i in 0..len5 {
                                                let base = base5 + i * 24;
                                                {
                                                    wit_bindgen::rt::dealloc(
                                                        *((base + 0) as *const i32),
                                                        (*((base + 4) as *const i32)) as usize,
                                                        1,
                                                    );
                                                    match i32::from(*((base + 8) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 16) as *const i32),
                                                                (*((base + 20) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base4 = *((base + 16) as *const i32);
                                                            let len4 = *((base + 20) as *const i32);
                                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                }
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {}
                                6 => {}
                                _ => {}
                            }
                        }
                    }
                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 40, 8);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_observe<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_observe(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_array_observe_deep<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_array_observe_deep(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_new<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i64,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result11 = T::y_map_new(
                        match arg0 {
                            0 => None,
                            1 => {
                                Some({
                                    let base5 = arg4;
                                    let len5 = arg5;
                                    let mut result5 = Vec::with_capacity(len5 as usize);
                                    for i in 0..len5 {
                                        let base = base5 + i * 8;
                                        result5
                                            .push({
                                                let base4 = *((base + 0) as *const i32);
                                                let len4 = *((base + 4) as *const i32);
                                                let mut result4 = Vec::with_capacity(len4 as usize);
                                                for i in 0..len4 {
                                                    let base = base4 + i * 16;
                                                    result4
                                                        .push({
                                                            {
                                                                match i32::from(*((base + 0) as *const u8)) {
                                                                    0 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                    }
                                                                    1 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                    }
                                                                    2 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                            #[cfg(debug_assertions)]
                                                                            {
                                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                                    0 => false,
                                                                                    1 => true,
                                                                                    _ => {
                                                                                        ::core::panicking::panic_fmt(
                                                                                            format_args!("invalid bool discriminant"),
                                                                                        );
                                                                                    }
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    3 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                            *((base + 8) as *const f64),
                                                                        )
                                                                    }
                                                                    4 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                            *((base + 8) as *const i64),
                                                                        )
                                                                    }
                                                                    5 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                            let len2 = *((base + 12) as *const i32) as usize;
                                                                            {
                                                                                #[cfg(debug_assertions)]
                                                                                {
                                                                                    String::from_utf8(
                                                                                            Vec::from_raw_parts(
                                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                                len2,
                                                                                                len2,
                                                                                            ),
                                                                                        )
                                                                                        .unwrap()
                                                                                }
                                                                            }
                                                                        })
                                                                    }
                                                                    6 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len3,
                                                                                len3,
                                                                            )
                                                                        })
                                                                    }
                                                                    7 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    8 => {
                                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: *((base + 8) as *const i32) as u32,
                                                                        })
                                                                    }
                                                                    #[cfg(debug_assertions)]
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid enum discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 16, 8);
                                                result4
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
                                    let base10 = arg6;
                                    let len10 = arg7;
                                    let mut result10 = Vec::with_capacity(len10 as usize);
                                    for i in 0..len10 {
                                        let base = base10 + i * 8;
                                        result10
                                            .push({
                                                let base9 = *((base + 0) as *const i32);
                                                let len9 = *((base + 4) as *const i32);
                                                let mut result9 = Vec::with_capacity(len9 as usize);
                                                for i in 0..len9 {
                                                    let base = base9 + i * 24;
                                                    result9
                                                        .push({
                                                            let len6 = *((base + 4) as *const i32) as usize;
                                                            (
                                                                {
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        String::from_utf8(
                                                                                Vec::from_raw_parts(
                                                                                    *((base + 0) as *const i32) as *mut _,
                                                                                    len6,
                                                                                    len6,
                                                                                ),
                                                                            )
                                                                            .unwrap()
                                                                    }
                                                                },
                                                                {
                                                                    {
                                                                        match i32::from(*((base + 8) as *const u8)) {
                                                                            0 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                                            }
                                                                            1 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                                            }
                                                                            2 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                                    #[cfg(debug_assertions)]
                                                                                    {
                                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                                            0 => false,
                                                                                            1 => true,
                                                                                            _ => {
                                                                                                ::core::panicking::panic_fmt(
                                                                                                    format_args!("invalid bool discriminant"),
                                                                                                );
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            3 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                                    *((base + 16) as *const f64),
                                                                                )
                                                                            }
                                                                            4 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                                    *((base + 16) as *const i64),
                                                                                )
                                                                            }
                                                                            5 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                                    let len7 = *((base + 20) as *const i32) as usize;
                                                                                    {
                                                                                        #[cfg(debug_assertions)]
                                                                                        {
                                                                                            String::from_utf8(
                                                                                                    Vec::from_raw_parts(
                                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                                        len7,
                                                                                                        len7,
                                                                                                    ),
                                                                                                )
                                                                                                .unwrap()
                                                                                        }
                                                                                    }
                                                                                })
                                                                            }
                                                                            6 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len8,
                                                                                        len8,
                                                                                    )
                                                                                })
                                                                            }
                                                                            7 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            8 => {
                                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: *((base + 16) as *const i32) as u32,
                                                                                })
                                                                            }
                                                                            #[cfg(debug_assertions)]
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                },
                                                            )
                                                        });
                                                }
                                                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 24, 8);
                                                result9
                                            });
                                    }
                                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: {
                                            {
                                                match arg1 {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match arg2 as i32 {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            f64::from_bits(arg2 as u64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            arg2,
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len0 = arg3 as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len1 = arg3 as usize;
                                                            Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: arg2 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: arg2 as i32 as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        },
                                        array_references: result5,
                                        map_references: result10,
                                    }
                                })
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                        ref_: ref_12,
                    } = result11;
                    wit_bindgen::rt::as_i32(ref_12)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_prelim<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_prelim(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                        ref_: arg0 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_length<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_length(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::as_i32(result0)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_to_json<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_to_json(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                        item: item2,
                        array_references: array_references2,
                        map_references: map_references2,
                    } = result0;
                    match item2 {
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (2i32) as u8;
                            *((ptr1 + 8)
                                as *mut u8) = (match e {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (3i32) as u8;
                            *((ptr1 + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (4i32) as u8;
                            *((ptr1 + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (5i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((ptr1 + 12) as *mut i32) = len3;
                            *((ptr1 + 8) as *mut i32) = ptr3;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (6i32) as u8;
                            let vec4 = (e).into_boxed_slice();
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            ::core::mem::forget(vec4);
                            *((ptr1 + 12) as *mut i32) = len4;
                            *((ptr1 + 8) as *mut i32) = ptr4;
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (7i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                index: index5,
                            } = e;
                            *((ptr1 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index5);
                        }
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                            e,
                        ) => {
                            *((ptr1 + 0) as *mut u8) = (8i32) as u8;
                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                index: index6,
                            } = e;
                            *((ptr1 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index6);
                        }
                    };
                    let vec12 = array_references2;
                    let len12 = vec12.len() as i32;
                    let layout12 = alloc::Layout::from_size_align_unchecked(
                        vec12.len() * 8,
                        4,
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = alloc::alloc(layout12);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12 as i32 + (i as i32) * 8;
                        {
                            let vec11 = e;
                            let len11 = vec11.len() as i32;
                            let layout11 = alloc::Layout::from_size_align_unchecked(
                                vec11.len() * 16,
                                8,
                            );
                            let result11 = if layout11.size() != 0 {
                                let ptr = alloc::alloc(layout11);
                                if ptr.is_null() {
                                    alloc::handle_alloc_error(layout11);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec11.into_iter().enumerate() {
                                let base = result11 as i32 + (i as i32) * 16;
                                {
                                    match e {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((base + 0) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((base + 0) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (2i32) as u8;
                                            *((base + 8)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (3i32) as u8;
                                            *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (4i32) as u8;
                                            *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (5i32) as u8;
                                            let vec7 = (e.into_bytes()).into_boxed_slice();
                                            let ptr7 = vec7.as_ptr() as i32;
                                            let len7 = vec7.len() as i32;
                                            ::core::mem::forget(vec7);
                                            *((base + 12) as *mut i32) = len7;
                                            *((base + 8) as *mut i32) = ptr7;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (6i32) as u8;
                                            let vec8 = (e).into_boxed_slice();
                                            let ptr8 = vec8.as_ptr() as i32;
                                            let len8 = vec8.len() as i32;
                                            ::core::mem::forget(vec8);
                                            *((base + 12) as *mut i32) = len8;
                                            *((base + 8) as *mut i32) = ptr8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index9,
                                            } = e;
                                            *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(index9);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((base + 0) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index10,
                                            } = e;
                                            *((base + 8)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                        }
                                    };
                                }
                            }
                            *((base + 4) as *mut i32) = len11;
                            *((base + 0) as *mut i32) = result11 as i32;
                        }
                    }
                    *((ptr1 + 20) as *mut i32) = len12;
                    *((ptr1 + 16) as *mut i32) = result12 as i32;
                    let vec20 = map_references2;
                    let len20 = vec20.len() as i32;
                    let layout20 = alloc::Layout::from_size_align_unchecked(
                        vec20.len() * 8,
                        4,
                    );
                    let result20 = if layout20.size() != 0 {
                        let ptr = alloc::alloc(layout20);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout20);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec20.into_iter().enumerate() {
                        let base = result20 as i32 + (i as i32) * 8;
                        {
                            let vec19 = e;
                            let len19 = vec19.len() as i32;
                            let layout19 = alloc::Layout::from_size_align_unchecked(
                                vec19.len() * 24,
                                8,
                            );
                            let result19 = if layout19.size() != 0 {
                                let ptr = alloc::alloc(layout19);
                                if ptr.is_null() {
                                    alloc::handle_alloc_error(layout19);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec19.into_iter().enumerate() {
                                let base = result19 as i32 + (i as i32) * 24;
                                {
                                    let (t13_0, t13_1) = e;
                                    let vec14 = (t13_0.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr() as i32;
                                    let len14 = vec14.len() as i32;
                                    ::core::mem::forget(vec14);
                                    *((base + 4) as *mut i32) = len14;
                                    *((base + 0) as *mut i32) = ptr14;
                                    match t13_1 {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                            *((base + 16)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                            let vec15 = (e.into_bytes()).into_boxed_slice();
                                            let ptr15 = vec15.as_ptr() as i32;
                                            let len15 = vec15.len() as i32;
                                            ::core::mem::forget(vec15);
                                            *((base + 20) as *mut i32) = len15;
                                            *((base + 16) as *mut i32) = ptr15;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                            let vec16 = (e).into_boxed_slice();
                                            let ptr16 = vec16.as_ptr() as i32;
                                            let len16 = vec16.len() as i32;
                                            ::core::mem::forget(vec16);
                                            *((base + 20) as *mut i32) = len16;
                                            *((base + 16) as *mut i32) = ptr16;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index17,
                                            } = e;
                                            *((base + 16)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index17);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index18,
                                            } = e;
                                            *((base + 16)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                        }
                                    };
                                }
                            }
                            *((base + 4) as *mut i32) = len19;
                            *((base + 0) as *mut i32) = result19 as i32;
                        }
                    }
                    *((ptr1 + 28) as *mut i32) = len20;
                    *((ptr1 + 24) as *mut i32) = result20 as i32;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_map_to_json<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        1 => {}
                        2 => {}
                        3 => {}
                        4 => {}
                        5 => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 8) as *const i32),
                                (*((arg0 + 12) as *const i32)) as usize,
                                1,
                            );
                        }
                        6 => {
                            let base0 = *((arg0 + 8) as *const i32);
                            let len0 = *((arg0 + 12) as *const i32);
                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                        }
                        7 => {}
                        _ => {}
                    }
                    let base3 = *((arg0 + 16) as *const i32);
                    let len3 = *((arg0 + 20) as *const i32);
                    for i in 0..len3 {
                        let base = base3 + i * 8;
                        {
                            let base2 = *((base + 0) as *const i32);
                            let len2 = *((base + 4) as *const i32);
                            for i in 0..len2 {
                                let base = base2 + i * 16;
                                {
                                    match i32::from(*((base + 0) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((base + 8) as *const i32),
                                                (*((base + 12) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base1 = *((base + 8) as *const i32);
                                            let len1 = *((base + 12) as *const i32);
                                            wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                        }
                    }
                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                    let base6 = *((arg0 + 24) as *const i32);
                    let len6 = *((arg0 + 28) as *const i32);
                    for i in 0..len6 {
                        let base = base6 + i * 8;
                        {
                            let base5 = *((base + 0) as *const i32);
                            let len5 = *((base + 4) as *const i32);
                            for i in 0..len5 {
                                let base = base5 + i * 24;
                                {
                                    wit_bindgen::rt::dealloc(
                                        *((base + 0) as *const i32),
                                        (*((base + 4) as *const i32)) as usize,
                                        1,
                                    );
                                    match i32::from(*((base + 8) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((base + 16) as *const i32),
                                                (*((base + 20) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base4 = *((base + 16) as *const i32);
                                            let len4 = *((base + 20) as *const i32);
                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                        }
                    }
                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_set<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i64,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let base6 = arg6;
                    let len6 = arg7;
                    let mut result6 = Vec::with_capacity(len6 as usize);
                    for i in 0..len6 {
                        let base = base6 + i * 8;
                        result6
                            .push({
                                let base5 = *((base + 0) as *const i32);
                                let len5 = *((base + 4) as *const i32);
                                let mut result5 = Vec::with_capacity(len5 as usize);
                                for i in 0..len5 {
                                    let base = base5 + i * 16;
                                    result5
                                        .push({
                                            {
                                                match i32::from(*((base + 0) as *const u8)) {
                                                    0 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                    }
                                                    1 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                    }
                                                    2 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                            #[cfg(debug_assertions)]
                                                            {
                                                                match i32::from(*((base + 8) as *const u8)) {
                                                                    0 => false,
                                                                    1 => true,
                                                                    _ => {
                                                                        ::core::panicking::panic_fmt(
                                                                            format_args!("invalid bool discriminant"),
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        })
                                                    }
                                                    3 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            *((base + 8) as *const f64),
                                                        )
                                                    }
                                                    4 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            *((base + 8) as *const i64),
                                                        )
                                                    }
                                                    5 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                            let len3 = *((base + 12) as *const i32) as usize;
                                                            {
                                                                #[cfg(debug_assertions)]
                                                                {
                                                                    String::from_utf8(
                                                                            Vec::from_raw_parts(
                                                                                *((base + 8) as *const i32) as *mut _,
                                                                                len3,
                                                                                len3,
                                                                            ),
                                                                        )
                                                                        .unwrap()
                                                                }
                                                            }
                                                        })
                                                    }
                                                    6 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                            let len4 = *((base + 12) as *const i32) as usize;
                                                            Vec::from_raw_parts(
                                                                *((base + 8) as *const i32) as *mut _,
                                                                len4,
                                                                len4,
                                                            )
                                                        })
                                                    }
                                                    7 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    8 => {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: *((base + 8) as *const i32) as u32,
                                                        })
                                                    }
                                                    #[cfg(debug_assertions)]
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!("invalid enum discriminant"),
                                                        );
                                                    }
                                                }
                                            }
                                        });
                                }
                                wit_bindgen::rt::dealloc(base5, (len5 as usize) * 16, 8);
                                result5
                            });
                    }
                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                    let base11 = arg8;
                    let len11 = arg9;
                    let mut result11 = Vec::with_capacity(len11 as usize);
                    for i in 0..len11 {
                        let base = base11 + i * 8;
                        result11
                            .push({
                                let base10 = *((base + 0) as *const i32);
                                let len10 = *((base + 4) as *const i32);
                                let mut result10 = Vec::with_capacity(len10 as usize);
                                for i in 0..len10 {
                                    let base = base10 + i * 24;
                                    result10
                                        .push({
                                            let len7 = *((base + 4) as *const i32) as usize;
                                            (
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(
                                                                    *((base + 0) as *const i32) as *mut _,
                                                                    len7,
                                                                    len7,
                                                                ),
                                                            )
                                                            .unwrap()
                                                    }
                                                },
                                                {
                                                    {
                                                        match i32::from(*((base + 8) as *const u8)) {
                                                            0 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                                            }
                                                            1 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                                            }
                                                            2 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                                    #[cfg(debug_assertions)]
                                                                    {
                                                                        match i32::from(*((base + 16) as *const u8)) {
                                                                            0 => false,
                                                                            1 => true,
                                                                            _ => {
                                                                                ::core::panicking::panic_fmt(
                                                                                    format_args!("invalid bool discriminant"),
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            3 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                                    *((base + 16) as *const f64),
                                                                )
                                                            }
                                                            4 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                                    *((base + 16) as *const i64),
                                                                )
                                                            }
                                                            5 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                                    let len8 = *((base + 20) as *const i32) as usize;
                                                                    {
                                                                        #[cfg(debug_assertions)]
                                                                        {
                                                                            String::from_utf8(
                                                                                    Vec::from_raw_parts(
                                                                                        *((base + 16) as *const i32) as *mut _,
                                                                                        len8,
                                                                                        len8,
                                                                                    ),
                                                                                )
                                                                                .unwrap()
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                            6 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                                    let len9 = *((base + 20) as *const i32) as usize;
                                                                    Vec::from_raw_parts(
                                                                        *((base + 16) as *const i32) as *mut _,
                                                                        len9,
                                                                        len9,
                                                                    )
                                                                })
                                                            }
                                                            7 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            8 => {
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: *((base + 16) as *const i32) as u32,
                                                                })
                                                            }
                                                            #[cfg(debug_assertions)]
                                                            _ => {
                                                                ::core::panicking::panic_fmt(
                                                                    format_args!("invalid enum discriminant"),
                                                                );
                                                            }
                                                        }
                                                    }
                                                },
                                            )
                                        });
                                }
                                wit_bindgen::rt::dealloc(base10, (len10 as usize) * 24, 8);
                                result10
                            });
                    }
                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                    T::y_map_set(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: {
                                {
                                    match arg3 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null
                                        }
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined
                                        }
                                        2 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean({
                                                #[cfg(debug_assertions)]
                                                {
                                                    match arg4 as i32 {
                                                        0 => false,
                                                        1 => true,
                                                        _ => {
                                                            ::core::panicking::panic_fmt(
                                                                format_args!("invalid bool discriminant"),
                                                            );
                                                        }
                                                    }
                                                }
                                            })
                                        }
                                        3 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                f64::from_bits(arg4 as u64),
                                            )
                                        }
                                        4 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                arg4,
                                            )
                                        }
                                        5 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str({
                                                let len1 = arg5 as usize;
                                                {
                                                    #[cfg(debug_assertions)]
                                                    {
                                                        String::from_utf8(
                                                                Vec::from_raw_parts(arg4 as i32 as *mut _, len1, len1),
                                                            )
                                                            .unwrap()
                                                    }
                                                }
                                            })
                                        }
                                        6 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer({
                                                let len2 = arg5 as usize;
                                                Vec::from_raw_parts(arg4 as i32 as *mut _, len2, len2)
                                            })
                                        }
                                        7 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: arg4 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        8 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: arg4 as i32 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid enum discriminant"),
                                            );
                                        }
                                    }
                                }
                            },
                            array_references: result6,
                            map_references: result11,
                        },
                        match arg10 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg11 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg12 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg12 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_delete<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    T::y_map_delete(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg4 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_get<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg2 as usize;
                    let result1 = T::y_map_get(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg4 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result1 {
                        Some(e) => {
                            *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            match e {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (0i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: item3,
                                        array_references: array_references3,
                                        map_references: map_references3,
                                    } = e;
                                    match item3 {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((ptr2 + 16) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((ptr2 + 16) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (2i32) as u8;
                                            *((ptr2 + 24)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (3i32) as u8;
                                            *((ptr2 + 24) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (4i32) as u8;
                                            *((ptr2 + 24) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (5i32) as u8;
                                            let vec4 = (e.into_bytes()).into_boxed_slice();
                                            let ptr4 = vec4.as_ptr() as i32;
                                            let len4 = vec4.len() as i32;
                                            ::core::mem::forget(vec4);
                                            *((ptr2 + 28) as *mut i32) = len4;
                                            *((ptr2 + 24) as *mut i32) = ptr4;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (6i32) as u8;
                                            let vec5 = (e).into_boxed_slice();
                                            let ptr5 = vec5.as_ptr() as i32;
                                            let len5 = vec5.len() as i32;
                                            ::core::mem::forget(vec5);
                                            *((ptr2 + 28) as *mut i32) = len5;
                                            *((ptr2 + 24) as *mut i32) = ptr5;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index6,
                                            } = e;
                                            *((ptr2 + 24)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((ptr2 + 16) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index7,
                                            } = e;
                                            *((ptr2 + 24)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                        }
                                    };
                                    let vec13 = array_references3;
                                    let len13 = vec13.len() as i32;
                                    let layout13 = alloc::Layout::from_size_align_unchecked(
                                        vec13.len() * 8,
                                        4,
                                    );
                                    let result13 = if layout13.size() != 0 {
                                        let ptr = alloc::alloc(layout13);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout13);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec13.into_iter().enumerate() {
                                        let base = result13 as i32 + (i as i32) * 8;
                                        {
                                            let vec12 = e;
                                            let len12 = vec12.len() as i32;
                                            let layout12 = alloc::Layout::from_size_align_unchecked(
                                                vec12.len() * 16,
                                                8,
                                            );
                                            let result12 = if layout12.size() != 0 {
                                                let ptr = alloc::alloc(layout12);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout12);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec12.into_iter().enumerate() {
                                                let base = result12 as i32 + (i as i32) * 16;
                                                {
                                                    match e {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 0) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 0) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (2i32) as u8;
                                                            *((base + 8)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (3i32) as u8;
                                                            *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (4i32) as u8;
                                                            *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (5i32) as u8;
                                                            let vec8 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr8 = vec8.as_ptr() as i32;
                                                            let len8 = vec8.len() as i32;
                                                            ::core::mem::forget(vec8);
                                                            *((base + 12) as *mut i32) = len8;
                                                            *((base + 8) as *mut i32) = ptr8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (6i32) as u8;
                                                            let vec9 = (e).into_boxed_slice();
                                                            let ptr9 = vec9.as_ptr() as i32;
                                                            let len9 = vec9.len() as i32;
                                                            ::core::mem::forget(vec9);
                                                            *((base + 12) as *mut i32) = len9;
                                                            *((base + 8) as *mut i32) = ptr9;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index10,
                                                            } = e;
                                                            *((base + 8)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index10);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index11,
                                                            } = e;
                                                            *((base + 8)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len12;
                                            *((base + 0) as *mut i32) = result12 as i32;
                                        }
                                    }
                                    *((ptr2 + 36) as *mut i32) = len13;
                                    *((ptr2 + 32) as *mut i32) = result13 as i32;
                                    let vec21 = map_references3;
                                    let len21 = vec21.len() as i32;
                                    let layout21 = alloc::Layout::from_size_align_unchecked(
                                        vec21.len() * 8,
                                        4,
                                    );
                                    let result21 = if layout21.size() != 0 {
                                        let ptr = alloc::alloc(layout21);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout21);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec21.into_iter().enumerate() {
                                        let base = result21 as i32 + (i as i32) * 8;
                                        {
                                            let vec20 = e;
                                            let len20 = vec20.len() as i32;
                                            let layout20 = alloc::Layout::from_size_align_unchecked(
                                                vec20.len() * 24,
                                                8,
                                            );
                                            let result20 = if layout20.size() != 0 {
                                                let ptr = alloc::alloc(layout20);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout20);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec20.into_iter().enumerate() {
                                                let base = result20 as i32 + (i as i32) * 24;
                                                {
                                                    let (t14_0, t14_1) = e;
                                                    let vec15 = (t14_0.into_bytes()).into_boxed_slice();
                                                    let ptr15 = vec15.as_ptr() as i32;
                                                    let len15 = vec15.len() as i32;
                                                    ::core::mem::forget(vec15);
                                                    *((base + 4) as *mut i32) = len15;
                                                    *((base + 0) as *mut i32) = ptr15;
                                                    match t14_1 {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                                            *((base + 16)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                                            let vec16 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr16 = vec16.as_ptr() as i32;
                                                            let len16 = vec16.len() as i32;
                                                            ::core::mem::forget(vec16);
                                                            *((base + 20) as *mut i32) = len16;
                                                            *((base + 16) as *mut i32) = ptr16;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                                            let vec17 = (e).into_boxed_slice();
                                                            let ptr17 = vec17.as_ptr() as i32;
                                                            let len17 = vec17.len() as i32;
                                                            ::core::mem::forget(vec17);
                                                            *((base + 20) as *mut i32) = len17;
                                                            *((base + 16) as *mut i32) = ptr17;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index18,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index18);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index19,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index19);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len20;
                                            *((base + 0) as *mut i32) = result20 as i32;
                                        }
                                    }
                                    *((ptr2 + 44) as *mut i32) = len21;
                                    *((ptr2 + 40) as *mut i32) = result21 as i32;
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (1i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                        ref_: ref_22,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_22);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (2i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                        ref_: ref_23,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_23);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (3i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                        ref_: ref_24,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_24);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (4i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                        ref_: ref_25,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (5i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                        ref_: ref_26,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (6i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                        ref_: ref_27,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                    e,
                                ) => {
                                    *((ptr2 + 8) as *mut u8) = (7i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                        ref_: ref_28,
                                    } = e;
                                    *((ptr2 + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                }
                            };
                        }
                        None => {
                            *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_map_get<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            match i32::from(*((arg0 + 8) as *const u8)) {
                                0 => {
                                    match i32::from(*((arg0 + 16) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((arg0 + 24) as *const i32),
                                                (*((arg0 + 28) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base0 = *((arg0 + 24) as *const i32);
                                            let len0 = *((arg0 + 28) as *const i32);
                                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                    let base3 = *((arg0 + 32) as *const i32);
                                    let len3 = *((arg0 + 36) as *const i32);
                                    for i in 0..len3 {
                                        let base = base3 + i * 8;
                                        {
                                            let base2 = *((base + 0) as *const i32);
                                            let len2 = *((base + 4) as *const i32);
                                            for i in 0..len2 {
                                                let base = base2 + i * 16;
                                                {
                                                    match i32::from(*((base + 0) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 8) as *const i32),
                                                                (*((base + 12) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base1 = *((base + 8) as *const i32);
                                                            let len1 = *((base + 12) as *const i32);
                                                            wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                                    let base6 = *((arg0 + 40) as *const i32);
                                    let len6 = *((arg0 + 44) as *const i32);
                                    for i in 0..len6 {
                                        let base = base6 + i * 8;
                                        {
                                            let base5 = *((base + 0) as *const i32);
                                            let len5 = *((base + 4) as *const i32);
                                            for i in 0..len5 {
                                                let base = base5 + i * 24;
                                                {
                                                    wit_bindgen::rt::dealloc(
                                                        *((base + 0) as *const i32),
                                                        (*((base + 4) as *const i32)) as usize,
                                                        1,
                                                    );
                                                    match i32::from(*((base + 8) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 16) as *const i32),
                                                                (*((base + 20) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base4 = *((base + 16) as *const i32);
                                                            let len4 = *((base + 20) as *const i32);
                                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                }
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {}
                                6 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_entries<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_entries(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    let vec30 = result0;
                    let len30 = vec30.len() as i32;
                    let layout30 = alloc::Layout::from_size_align_unchecked(
                        vec30.len() * 48,
                        8,
                    );
                    let result30 = if layout30.size() != 0 {
                        let ptr = alloc::alloc(layout30);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout30);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec30.into_iter().enumerate() {
                        let base = result30 as i32 + (i as i32) * 48;
                        {
                            let (t2_0, t2_1) = e;
                            let vec3 = (t2_0.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            ::core::mem::forget(vec3);
                            *((base + 4) as *mut i32) = len3;
                            *((base + 0) as *mut i32) = ptr3;
                            match t2_1 {
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (0i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: item4,
                                        array_references: array_references4,
                                        map_references: map_references4,
                                    } = e;
                                    match item4 {
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                            *((base + 16) as *mut u8) = (0i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                            *((base + 16) as *mut u8) = (1i32) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (2i32) as u8;
                                            *((base + 24)
                                                as *mut u8) = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (3i32) as u8;
                                            *((base + 24) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (4i32) as u8;
                                            *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (5i32) as u8;
                                            let vec5 = (e.into_bytes()).into_boxed_slice();
                                            let ptr5 = vec5.as_ptr() as i32;
                                            let len5 = vec5.len() as i32;
                                            ::core::mem::forget(vec5);
                                            *((base + 28) as *mut i32) = len5;
                                            *((base + 24) as *mut i32) = ptr5;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (6i32) as u8;
                                            let vec6 = (e).into_boxed_slice();
                                            let ptr6 = vec6.as_ptr() as i32;
                                            let len6 = vec6.len() as i32;
                                            ::core::mem::forget(vec6);
                                            *((base + 28) as *mut i32) = len6;
                                            *((base + 24) as *mut i32) = ptr6;
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (7i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: index7,
                                            } = e;
                                            *((base + 24)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                        }
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                            e,
                                        ) => {
                                            *((base + 16) as *mut u8) = (8i32) as u8;
                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: index8,
                                            } = e;
                                            *((base + 24)
                                                as *mut i32) = wit_bindgen::rt::as_i32(index8);
                                        }
                                    };
                                    let vec14 = array_references4;
                                    let len14 = vec14.len() as i32;
                                    let layout14 = alloc::Layout::from_size_align_unchecked(
                                        vec14.len() * 8,
                                        4,
                                    );
                                    let result14 = if layout14.size() != 0 {
                                        let ptr = alloc::alloc(layout14);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout14);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec14.into_iter().enumerate() {
                                        let base = result14 as i32 + (i as i32) * 8;
                                        {
                                            let vec13 = e;
                                            let len13 = vec13.len() as i32;
                                            let layout13 = alloc::Layout::from_size_align_unchecked(
                                                vec13.len() * 16,
                                                8,
                                            );
                                            let result13 = if layout13.size() != 0 {
                                                let ptr = alloc::alloc(layout13);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout13);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec13.into_iter().enumerate() {
                                                let base = result13 as i32 + (i as i32) * 16;
                                                {
                                                    match e {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 0) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 0) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (2i32) as u8;
                                                            *((base + 8)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (3i32) as u8;
                                                            *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (4i32) as u8;
                                                            *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (5i32) as u8;
                                                            let vec9 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr9 = vec9.as_ptr() as i32;
                                                            let len9 = vec9.len() as i32;
                                                            ::core::mem::forget(vec9);
                                                            *((base + 12) as *mut i32) = len9;
                                                            *((base + 8) as *mut i32) = ptr9;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (6i32) as u8;
                                                            let vec10 = (e).into_boxed_slice();
                                                            let ptr10 = vec10.as_ptr() as i32;
                                                            let len10 = vec10.len() as i32;
                                                            ::core::mem::forget(vec10);
                                                            *((base + 12) as *mut i32) = len10;
                                                            *((base + 8) as *mut i32) = ptr10;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index11,
                                                            } = e;
                                                            *((base + 8)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 0) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index12,
                                                            } = e;
                                                            *((base + 8)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len13;
                                            *((base + 0) as *mut i32) = result13 as i32;
                                        }
                                    }
                                    *((base + 36) as *mut i32) = len14;
                                    *((base + 32) as *mut i32) = result14 as i32;
                                    let vec22 = map_references4;
                                    let len22 = vec22.len() as i32;
                                    let layout22 = alloc::Layout::from_size_align_unchecked(
                                        vec22.len() * 8,
                                        4,
                                    );
                                    let result22 = if layout22.size() != 0 {
                                        let ptr = alloc::alloc(layout22);
                                        if ptr.is_null() {
                                            alloc::handle_alloc_error(layout22);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec22.into_iter().enumerate() {
                                        let base = result22 as i32 + (i as i32) * 8;
                                        {
                                            let vec21 = e;
                                            let len21 = vec21.len() as i32;
                                            let layout21 = alloc::Layout::from_size_align_unchecked(
                                                vec21.len() * 24,
                                                8,
                                            );
                                            let result21 = if layout21.size() != 0 {
                                                let ptr = alloc::alloc(layout21);
                                                if ptr.is_null() {
                                                    alloc::handle_alloc_error(layout21);
                                                }
                                                ptr
                                            } else {
                                                ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec21.into_iter().enumerate() {
                                                let base = result21 as i32 + (i as i32) * 24;
                                                {
                                                    let (t15_0, t15_1) = e;
                                                    let vec16 = (t15_0.into_bytes()).into_boxed_slice();
                                                    let ptr16 = vec16.as_ptr() as i32;
                                                    let len16 = vec16.len() as i32;
                                                    ::core::mem::forget(vec16);
                                                    *((base + 4) as *mut i32) = len16;
                                                    *((base + 0) as *mut i32) = ptr16;
                                                    match t15_1 {
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Null => {
                                                            *((base + 8) as *mut u8) = (0i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Undefined => {
                                                            *((base + 8) as *mut u8) = (1i32) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Boolean(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (2i32) as u8;
                                                            *((base + 16)
                                                                as *mut u8) = (match e {
                                                                true => 1,
                                                                false => 0,
                                                            }) as u8;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Number(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (3i32) as u8;
                                                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::BigInt(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (4i32) as u8;
                                                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Str(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (5i32) as u8;
                                                            let vec17 = (e.into_bytes()).into_boxed_slice();
                                                            let ptr17 = vec17.as_ptr() as i32;
                                                            let len17 = vec17.len() as i32;
                                                            ::core::mem::forget(vec17);
                                                            *((base + 20) as *mut i32) = len17;
                                                            *((base + 16) as *mut i32) = ptr17;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Buffer(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (6i32) as u8;
                                                            let vec18 = (e).into_boxed_slice();
                                                            let ptr18 = vec18.as_ptr() as i32;
                                                            let len18 = vec18.len() as i32;
                                                            ::core::mem::forget(vec18);
                                                            *((base + 20) as *mut i32) = len18;
                                                            *((base + 16) as *mut i32) = ptr18;
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Array(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (7i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                index: index19,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index19);
                                                        }
                                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue::Map(
                                                            e,
                                                        ) => {
                                                            *((base + 8) as *mut u8) = (8i32) as u8;
                                                            let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                index: index20,
                                                            } = e;
                                                            *((base + 16)
                                                                as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                                        }
                                                    };
                                                }
                                            }
                                            *((base + 4) as *mut i32) = len21;
                                            *((base + 0) as *mut i32) = result21 as i32;
                                        }
                                    }
                                    *((base + 44) as *mut i32) = len22;
                                    *((base + 40) as *mut i32) = result22 as i32;
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YText(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (1i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                        ref_: ref_23,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_23);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YArray(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (2i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                        ref_: ref_24,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_24);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YMap(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (3i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                        ref_: ref_25,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlFragment(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (4i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                        ref_: ref_26,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlElement(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (5i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                        ref_: ref_27,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YXmlText(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (6i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                        ref_: ref_28,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                }
                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                    e,
                                ) => {
                                    *((base + 8) as *mut u8) = (7i32) as u8;
                                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                        ref_: ref_29,
                                    } = e;
                                    *((base + 16)
                                        as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                }
                            };
                        }
                    }
                    *((ptr1 + 4) as *mut i32) = len30;
                    *((ptr1 + 0) as *mut i32) = result30 as i32;
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_map_entries<T: YDocMethods>(arg0: i32) {
                    let base7 = *((arg0 + 0) as *const i32);
                    let len7 = *((arg0 + 4) as *const i32);
                    for i in 0..len7 {
                        let base = base7 + i * 48;
                        {
                            wit_bindgen::rt::dealloc(
                                *((base + 0) as *const i32),
                                (*((base + 4) as *const i32)) as usize,
                                1,
                            );
                            match i32::from(*((base + 8) as *const u8)) {
                                0 => {
                                    match i32::from(*((base + 16) as *const u8)) {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        3 => {}
                                        4 => {}
                                        5 => {
                                            wit_bindgen::rt::dealloc(
                                                *((base + 24) as *const i32),
                                                (*((base + 28) as *const i32)) as usize,
                                                1,
                                            );
                                        }
                                        6 => {
                                            let base0 = *((base + 24) as *const i32);
                                            let len0 = *((base + 28) as *const i32);
                                            wit_bindgen::rt::dealloc(base0, (len0 as usize) * 1, 1);
                                        }
                                        7 => {}
                                        _ => {}
                                    }
                                    let base3 = *((base + 32) as *const i32);
                                    let len3 = *((base + 36) as *const i32);
                                    for i in 0..len3 {
                                        let base = base3 + i * 8;
                                        {
                                            let base2 = *((base + 0) as *const i32);
                                            let len2 = *((base + 4) as *const i32);
                                            for i in 0..len2 {
                                                let base = base2 + i * 16;
                                                {
                                                    match i32::from(*((base + 0) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 8) as *const i32),
                                                                (*((base + 12) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base1 = *((base + 8) as *const i32);
                                                            let len1 = *((base + 12) as *const i32);
                                                            wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 16, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                                    let base6 = *((base + 40) as *const i32);
                                    let len6 = *((base + 44) as *const i32);
                                    for i in 0..len6 {
                                        let base = base6 + i * 8;
                                        {
                                            let base5 = *((base + 0) as *const i32);
                                            let len5 = *((base + 4) as *const i32);
                                            for i in 0..len5 {
                                                let base = base5 + i * 24;
                                                {
                                                    wit_bindgen::rt::dealloc(
                                                        *((base + 0) as *const i32),
                                                        (*((base + 4) as *const i32)) as usize,
                                                        1,
                                                    );
                                                    match i32::from(*((base + 8) as *const u8)) {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            wit_bindgen::rt::dealloc(
                                                                *((base + 16) as *const i32),
                                                                (*((base + 20) as *const i32)) as usize,
                                                                1,
                                                            );
                                                        }
                                                        6 => {
                                                            let base4 = *((base + 16) as *const i32);
                                                            let len4 = *((base + 20) as *const i32);
                                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 24, 8);
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                                }
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {}
                                6 => {}
                                _ => {}
                            }
                        }
                    }
                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 48, 8);
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_observe<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_observe(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_map_observe_deep<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_map_observe_deep(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_element_name<T: YDocMethods>(arg0: i32) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_element_name(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Some(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr() as i32;
                            let len2 = vec2.len() as i32;
                            ::core::mem::forget(vec2);
                            *((ptr1 + 8) as *mut i32) = len2;
                            *((ptr1 + 4) as *mut i32) = ptr2;
                        }
                        None => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_xml_element_name<T: YDocMethods>(arg0: i32) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_element_length<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_element_length(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::as_i32(result0)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_element_insert_xml_element<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let len0 = arg3 as usize;
                    let result1 = T::y_xml_element_insert_xml_element(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        {
                            #[cfg(debug_assertions)]
                            {
                                String::from_utf8(
                                        Vec::from_raw_parts(arg2 as *mut _, len0, len0),
                                    )
                                    .unwrap()
                            }
                        },
                        match arg4 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg5 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg6 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg6 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                        ref_: ref_2,
                    } = result1;
                    wit_bindgen::rt::as_i32(ref_2)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_element_insert_xml_text<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_element_insert_xml_text(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        match arg2 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg3 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg4 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg4 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                        ref_: ref_1,
                    } = result0;
                    wit_bindgen::rt::as_i32(ref_1)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_element_delete<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    T::y_xml_element_delete(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: arg0 as u32,
                        },
                        arg1 as u32,
                        arg2 as u32,
                        match arg3 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg4 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg5 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_fragment_name<T: YDocMethods>(
                    arg0: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_fragment_name(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                        ref_: arg0 as u32,
                    });
                    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                    match result0 {
                        Some(e) => {
                            *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr() as i32;
                            let len2 = vec2.len() as i32;
                            ::core::mem::forget(vec2);
                            *((ptr1 + 8) as *mut i32) = len2;
                            *((ptr1 + 4) as *mut i32) = ptr2;
                        }
                        None => {
                            *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                pub unsafe fn post_return_y_xml_fragment_name<T: YDocMethods>(
                    arg0: i32,
                ) {
                    match i32::from(*((arg0 + 0) as *const u8)) {
                        0 => {}
                        _ => {
                            wit_bindgen::rt::dealloc(
                                *((arg0 + 4) as *const i32),
                                (*((arg0 + 8) as *const i32)) as usize,
                                1,
                            );
                        }
                    }
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_fragment_length<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_fragment_length(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::as_i32(result0)
                }
                #[doc(hidden)]
                pub unsafe fn call_y_xml_text_length<T: YDocMethods>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    let result0 = T::y_xml_text_length(
                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                            ref_: arg0 as u32,
                        },
                        match arg1 {
                            0 => None,
                            1 => {
                                Some(
                                    match arg2 {
                                        0 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::ReadTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        1 => {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction::WriteTransaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                ref_: arg3 as u32,
                                            })
                                        }
                                        #[cfg(debug_assertions)]
                                        _ => {
                                            ::core::panicking::panic_fmt(
                                                format_args!("invalid union discriminant"),
                                            );
                                        }
                                    },
                                )
                            }
                            #[cfg(debug_assertions)]
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        },
                    );
                    wit_bindgen::rt::as_i32(result0)
                }
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                #[repr(align(8))]
                struct _RetArea([u8; 48]);
                static mut _RET_AREA: _RetArea = _RetArea([0; 48]);
            }
        }
    }
}
const _: &str = "package y-crdt-namespace:y-crdt\n\nworld y-crdt {\n    use y-doc-methods-types.{y-event}\n\n    import event-callback: func(function-id: u32, event: y-event)\n    import event-deep-callback: func(function-id: u32, event: list<y-event>)\n\n    // TODO: should_load auto_load\n\n    export y-doc-methods\n}\n\ninterface y-doc-methods-types {\n\n    union y-event {\n      y-array-event,\n      y-map-event,\n      y-text-event,\n    }\n\n    record event-observer {\n      ref: u32,\n    }\n\n    union y-value {\n      json-value-item,\n      y-text,\n      y-array,\n      y-map,\n      y-xml-fragment,\n      y-xml-element,\n      y-xml-text,\n      y-doc,\n    }\n\n    record y-doc {\n      ref: u32,\n    }\n    union y-transaction {\n      read-transaction,\n      write-transaction,\n    }\n    record read-transaction {\n      ref: u32,\n    }\n    record write-transaction {\n      ref: u32,\n    }\n\n    record y-text {\n      ref: u32,\n    }\n    record y-array {\n      ref: u32,\n    }\n    record y-map {\n      ref: u32,\n    }\n    record y-xml-fragment {\n      ref: u32,\n    }\n    record y-xml-element {\n      ref: u32,\n    }\n    record y-xml-text {\n      ref: u32,\n    }\n\n    type event-path = list<event-path-item>\n    union event-path-item {\n      string,\n      u32,\n    }\n\n    record y-array-event {\n      target: y-array,\n      delta: list<y-array-delta>,\n      path: event-path,\n    }\n\n    union y-array-delta {\n      y-array-delta-insert,\n      y-array-delta-delete,\n      y-array-delta-retain,\n    }\n\n    record y-array-delta-insert {\n      insert: list<y-value>,\n    }\n    record y-array-delta-delete {\n      delete: u32,\n    }\n    record y-array-delta-retain {\n      retain: u32,\n    }\n\n    record y-map-event {\n      // txn: write-transaction,\n      // target: y-value,\n      target: y-map,\n      keys: list<tuple<string, y-map-delta>>,\n      path: event-path,\n    }\n\n    record y-map-delta {\n      action: y-map-delta-action,\n      old-value: option<y-value>,\n      new-value: option<y-value>,\n    }\n\n    enum y-map-delta-action {\n      insert,\n      update,\n      delete,\n    }\n\n    record y-text-event {\n      // txn: write-transaction,\n      // target: y-value,\n      target: y-text,\n      delta: list<y-text-delta>,\n      path: event-path,\n    }\n    \n    /// https://quilljs.com/docs/delta/\n    union y-text-delta {\n      y-text-delta-insert,\n      y-text-delta-delete,\n      y-text-delta-retain,\n    }\n    record y-text-delta-insert {\n      // TODO: could be an Embeds object\n      insert: string,\n      attributes: option<text-attrs>,\n    }\n    record y-text-delta-delete {\n      delete: u32,\n    }\n    record y-text-delta-retain {\n      retain: u32,\n      attributes: option<text-attrs>,\n    }\n\n    // TODO: should we add fields/methods from Snapshot?\n    record y-snapshot {\n      ref: u32,\n    }\n\n    type json-object = json-value-item\n    type json-array = json-value-item\n    type text-attrs = json-object\n\n    record json-value-item {\n      item: json-value,\n      array-references: list<list<json-value>>,\n      map-references: list<list<tuple<string, json-value>>>,\n    }\n\n    // record json-value-item {\n    //   item: json-value,\n    //   references: list<json-value>,\n    // }\n\n    record json-value-ref {\n      index: u32,\n    }\n\n    record json-array-ref {\n      index: u32,\n    }\n\n    record json-map-ref {\n      index: u32,\n    }\n\n    variant json-value {\n      null,\n      undefined,\n      boolean(bool),\n      number(float64),\n      big-int(s64),\n      str(string),\n      buffer(list<u8>),\n      array(json-array-ref),\n      map(json-map-ref),\n    }\n\n}\n\ninterface y-doc-methods {\n    use y-doc-methods-types.{\n      y-event,\n      event-observer,\n      y-value,\n      y-doc,\n      y-transaction,\n      read-transaction,\n      write-transaction,\n      y-text,\n      y-array,\n      y-map,\n      y-xml-fragment,\n      y-xml-element,\n      y-xml-text,\n      event-path,\n      event-path-item,\n      y-array-event,\n      y-array-delta,\n      y-array-delta-insert,\n      y-array-delta-delete,\n      y-array-delta-retain,\n      y-map-event,\n      y-map-delta,\n      y-map-delta-action,\n      y-text-event,\n      y-text-delta,\n      y-text-delta-insert,\n      y-text-delta-delete,\n      y-text-delta-retain,\n      y-snapshot,\n      json-object,\n      json-array,\n      json-value-item,\n      json-value-ref,\n      json-array-ref,\n      json-map-ref,\n      json-value,\n      text-attrs,\n    }\n\n    type error = string\n    type origin = list<u8>\n    type implicit-transaction = option<y-transaction>\n\n    y-doc-dispose: func(ref: y-doc) -> bool\n    y-text-dispose: func(ref: y-text) -> bool\n    y-array-dispose: func(ref: y-array) -> bool\n    y-map-dispose: func(ref: y-map) -> bool\n    y-xml-element-dispose: func(ref: y-xml-element) -> bool\n    y-xml-fragment-dispose: func(ref: y-xml-fragment) -> bool\n    y-xml-text-dispose: func(ref: y-xml-text) -> bool\n    y-transaction-dispose: func(ref: y-transaction) -> bool\n    y-value-dispose: func(ref: y-value) -> bool\n    callback-dispose: func(ref: event-observer) -> bool\n\n    enum offset-kind {\n        /// Compute editable strings length and offset using UTF-8 byte count.\n        bytes,\n        /// Compute editable strings length and offset using UTF-16 chars count.\n        utf16,\n        /// Compute editable strings length and offset using Unicode code points number.\n        utf32,\n    }\n\n    record y-doc-options {\n      /// Globally unique client identifier. This value must be unique across all active collaborating\n      /// peers, otherwise a update collisions will happen, causing document store state to be corrupted.\n      ///\n      /// Default value: randomly generated.\n      client-id: option<u64>,\n      /// A globally unique identifier for this document.\n      ///\n      /// Default value: randomly generated UUID v4.\n      guid: option<string>,\n      /// Associate this document with a collection. This only plays a role if your provider has\n      /// a concept of collection.\n      ///\n      /// Default value: `None`.\n      collection-id: option<string>,\n      /// How to we count offsets and lengths used in text operations.\n      ///\n      /// Default value: [OffsetKind::Bytes].\n      offset-kind: option<offset-kind>,\n      /// Determines if transactions commits should try to perform GC-ing of deleted items.\n      ///\n      /// Default value: `false`.\n      skip-gc: option<bool>,\n      /// If a subdocument, automatically load document. If this is a subdocument, remote peers will\n      /// load the document as well automatically.\n      ///\n      /// Default value: `false`.\n      auto-load: option<bool>,\n      /// Whether the document should be synced by the provider now.\n      /// This is toggled to true when you call ydoc.load().\n      ///\n      /// Default value: `true`.\n      should-load: option<bool>,\n    }\n\n    y-doc-new: func(options: option<y-doc-options>) -> y-doc\n    y-doc-parent-doc: func(ref: y-doc) -> option<y-doc>\n    y-doc-id: func(ref: y-doc) -> u64\n    y-doc-guid: func(ref: y-doc) -> string\n    y-doc-read-transaction: func(ref: y-doc) -> read-transaction\n    y-doc-write-transaction: func(ref: y-doc, origin: origin) -> write-transaction\n    y-doc-text: func(ref: y-doc, name: string) -> y-text\n    y-doc-array: func(ref: y-doc, name: string) -> y-array\n    y-doc-map: func(ref: y-doc, name: string) -> y-map\n    y-doc-xml-fragment: func(ref: y-doc, name: string) -> y-xml-fragment\n    y-doc-xml-element: func(ref: y-doc, name: string) -> y-xml-element\n    y-doc-xml-text: func(ref: y-doc, name: string) -> y-xml-text\n    y-doc-on-update-v1: func(ref: y-doc, function-id: u32) -> event-observer\n    // on_after_transaction\n    // on_subdocs\n    // on_destroy\n    load: func(ref: y-doc, parent-txn: implicit-transaction)\n    destroy: func(ref: y-doc, parent-txn: implicit-transaction)\n    subdocs: func(ref: y-doc, txn: implicit-transaction) -> list<y-doc>\n    subdoc-guids: func(ref: y-doc, txn: implicit-transaction) -> list<string>\n\n    encode-state-vector: func(ref: y-doc) -> list<u8>\n    // debug_update_v1\n\n\n    encode-state-as-update: func(ref: y-doc, vector: option<list<u8>>) -> result<list<u8>, error>\n    encode-state-as-update-v2: func(ref: y-doc, vector: option<list<u8>>) -> result<list<u8>, error>\n    apply-update: func(ref: y-doc, diff: list<u8>, origin: origin) -> result<_, error>\n    apply-update-v2: func(ref: y-doc, diff: list<u8>, origin: origin) -> result<_, error>\n\n    transaction-origin: func(txn: y-transaction) -> option<origin>\n    transaction-commit: func(txn: y-transaction)\n    transaction-state-vector-v1: func(txn: y-transaction) -> list<u8>\n    transaction-diff-v1: func(txn: y-transaction, vector: option<list<u8>>) -> result<list<u8>, error>\n    transaction-diff-v2: func(txn: y-transaction, vector: option<list<u8>>) -> result<list<u8>, error>\n    transaction-apply-v1: func(txn: y-transaction, diff: list<u8>) -> result<_, error>\n    transaction-apply-v2: func(txn: y-transaction, diff: list<u8>) -> result<_, error>\n\n    transaction-encode-update: func(txn: y-transaction) -> list<u8>\n    transaction-encode-update-v2: func(txn: y-transaction) -> list<u8>\n\n\n    // YMapEvent\n    // YTextEvent\n    // YXmlEvent\n    // YXmlTextEvent\n    // YSubdocsEvent\n    // YSubdocsObserver(SubdocsSubscription)\n    // YDestroyObserver(DestroySubscription)\n    // YAfterTransactionEvent\n    // YAfterTransactionObserver(TransactionCleanupSubscription)\n    // YUpdateObserver(UpdateSubscription)\n\n    // YArrayObserver\n    // YTextObserver\n    // YMapObserver\n    // ... other observers\n    // YEventObserver\n\n\n    y-text-new: func(init: option<string>) -> y-text\n    y-text-prelim: func(ref: y-text) -> bool\n    y-text-length: func(ref: y-text, txn: implicit-transaction) -> u32\n    y-text-to-string: func(ref: y-text, txn: implicit-transaction) -> string\n    y-text-to-json: func(ref: y-text, txn: implicit-transaction) -> string\n    y-text-insert: func(ref: y-text, index: u32, chunk: string, attributes: option<text-attrs>, txn: implicit-transaction)\n    y-text-insert-embed: func(ref: y-text, index: u32, embed: json-value-item, attributes: option<text-attrs>, txn: implicit-transaction)\n    y-text-format: func(ref: y-text, index: u32, length: u32, attributes: text-attrs, txn: implicit-transaction)\n    y-text-push: func(ref: y-text, chunk: string, attributes: option<text-attrs>, txn: implicit-transaction)\n    y-text-delete: func(ref: y-text, index: u32, length: u32, txn: implicit-transaction)\n    /// https://quilljs.com/docs/delta/\n    /// TODO: implement compute_ychange: Option<Function>,\n    y-text-to-delta: func(ref: y-text, snapshot: option<y-snapshot>, prev-snapshot: option<y-snapshot>, txn: implicit-transaction) -> list<y-text-delta>\n    y-text-observe: func(ref: y-text, function-id: u32) -> event-observer\n    y-text-observe-deep: func(ref: y-text, function-id: u32) -> event-observer\n\n    snapshot: func(doc: y-doc) -> y-snapshot\n    equal-snapshot: func(left: y-snapshot, right: y-snapshot) -> bool\n    encode-snapshot-v1: func(snapshot: y-snapshot) -> list<u8>\n    encode-snapshot-v2: func(snapshot: y-snapshot) -> list<u8>\n    decode-snapshot-v1: func(snapshot: list<u8>) -> result<y-snapshot, error>\n    decode-snapshot-v2: func(snapshot: list<u8>) -> result<y-snapshot, error>\n    encode-state-from-snapshot-v1: func(doc: y-doc, snapshot: y-snapshot) -> result<list<u8>, error>\n    encode-state-from-snapshot-v2: func(doc: y-doc, snapshot: y-snapshot) -> result<list<u8>, error>\n\n    y-array-new: func(init: option<json-array>) -> y-array\n    y-array-prelim: func(ref: y-array) -> bool\n    y-array-length: func(ref: y-array, txn: implicit-transaction) -> u32\n    y-array-to-json: func(ref: y-array, txn: implicit-transaction) -> json-value-item\n    y-array-insert: func(ref: y-array, index: u32, items: json-array, txn: implicit-transaction)\n    y-array-push: func(ref: y-array, items: json-array, txn: implicit-transaction)\n    y-array-delete: func(ref: y-array, index: u32, length: u32, txn: implicit-transaction)\n    y-array-move-content: func(ref: y-array, source: u32, target: u32, txn: implicit-transaction)\n    y-array-get: func(ref: y-array, index: u32, txn: implicit-transaction) -> result<y-value, error>\n    y-array-values: func(ref: y-array, txn: implicit-transaction) -> list<y-value>\n    y-array-observe: func(ref: y-array, function-id: u32) -> event-observer\n    y-array-observe-deep: func(ref: y-array, function-id: u32) -> event-observer\n\n\n    y-map-new: func(init: option<json-object>) -> y-map\n    y-map-prelim: func(ref: y-map) -> bool\n    y-map-length: func(ref: y-map, txn: implicit-transaction) -> u32\n    y-map-to-json: func(ref: y-map, txn: implicit-transaction) -> json-value-item // TODO: json-object\n    y-map-set: func(ref: y-map, key: string, value: json-value-item, txn: implicit-transaction)\n    y-map-delete: func(ref: y-map, key: string, txn: implicit-transaction)\n    y-map-get: func(ref: y-map, key: string, txn: implicit-transaction) -> option<y-value>\n    y-map-entries: func(ref: y-map, txn: implicit-transaction) -> list<tuple<string, y-value>>\n    y-map-observe: func(ref: y-map, function-id: u32) -> event-observer\n    y-map-observe-deep: func(ref: y-map, function-id: u32) -> event-observer\n\n\n    y-xml-element-name: func(ref: y-xml-element) -> option<string>\n    y-xml-element-length: func(ref: y-xml-element, txn: implicit-transaction) -> u32\n    y-xml-element-insert-xml-element: func(ref: y-xml-element, index: u32, name: string, txn: implicit-transaction) -> y-xml-element\n    y-xml-element-insert-xml-text: func(ref: y-xml-element, index: u32, txn: implicit-transaction) -> y-xml-text\n    y-xml-element-delete: func(ref: y-xml-element, index: u32, length: u32, txn: implicit-transaction)\n    // fn push_xml_element(&self, name: &str, txn: &ImplicitTransaction) -> YXmlElement\n    // fn push_xml_text(&self, txn: &ImplicitTransaction) -> YXmlText\n    // fn first_child(&self) -> JsValue\n    // fn next_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn prev_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn parent(&self) -> JsValue\n    // fn to_string(&self, txn: &ImplicitTransaction) -> String\n    // fn set_attribute(&self, name: &str, value: &str, txn: &ImplicitTransaction)\n    // fn get_attribute(&self, name: &str, txn: &ImplicitTransaction) -> Option<String>\n    // fn remove_attribute(&self, name: &str, txn: &ImplicitTransaction)\n    // fn attributes(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn tree_walker(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn observe(&mut self, f: js_sys::Function) -> YXmlObserver\n    // fn observe_deep(&mut self, f: js_sys::Function) -> YEventObserver\n\n\n    y-xml-fragment-name: func(ref: y-xml-fragment) -> option<string>\n    y-xml-fragment-length: func(ref: y-xml-fragment, txn: implicit-transaction) -> u32\n\n\n    y-xml-text-length: func(ref: y-xml-text, txn: implicit-transaction) -> u32\n    // fn insert(&self, index: i32, chunk: &str, attrs: JsValue, txn: &ImplicitTransaction)\n    // fn format(&self, index: i32, len: i32, attrs: JsValue, txn: &ImplicitTransaction)\n    // fn push(&self, chunk: &str, attrs: JsValue, txn: &ImplicitTransaction)\n    // fn delete(&self, index: u32, length: u32, txn: &ImplicitTransaction)\n    // fn next_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn prev_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn parent(&self) -> JsValue\n    // fn to_string(&self, txn: &ImplicitTransaction) -> String\n    // fn set_attribute(&self, name: &str, value: &str, txn: &ImplicitTransaction)\n    // fn get_attribute(&self, name: &str, txn: &ImplicitTransaction) -> Option<String>\n    // fn remove_attribute(&self, name: &str, txn: &ImplicitTransaction)\n    // fn attributes(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn observe(&mut self, f: js_sys::Function) -> YXmlTextObserver\n    // fn observe_deep(&mut self, f: js_sys::Function) -> YEventObserver\n\n    // fn create_sticky_index_from_type(\n    //     ytype: &JsValue,\n    //     index: u32,\n    //     assoc: i32,\n    //     txn: &ImplicitTransaction,\n    // ) -> Result<JsValue, JsValue>\n    // \n    // fn create_offset_from_sticky_index(rpos: &JsValue, doc: &YDoc) -> Result<JsValue, JsValue>\n    // fn encode_sticky_index(rpos: &JsValue) -> Result<Uint8Array, JsValue>\n    // fn decode_sticky_index(bin: Uint8Array) -> Result<JsValue, JsValue>\n\n    record y-undo-event {\n      origin: json-value-item,\n      kind: json-value-item,\n      stack-item: json-value-item,\n    }\n}\n";
use exports::y_crdt_namespace::y_crdt::y_doc_methods::*;
use lib0::any::Any;
use std::cell::RefCell;
use std::collections::{HashMap, VecDeque};
use std::convert::TryFrom;
use std::mem::ManuallyDrop;
use std::ops::Deref;
use std::rc::Rc;
use std::sync::Arc;
use y_crdt_namespace::y_crdt::y_doc_methods_types::{
    EventPathItem, JsonArrayRef, JsonMapRef, JsonValue, YArrayDelta, YArrayDeltaDelete,
    YArrayDeltaInsert, YArrayDeltaRetain, YArrayEvent, YMapDelta, YMapDeltaAction,
    YMapEvent, YTextDeltaDelete, YTextDeltaInsert, YTextDeltaRetain, YTextEvent,
};
use yrs::block::{ClientID, ItemContent, Prelim, Unused};
use yrs::types::array::ArrayEvent;
use yrs::types::map::MapEvent;
use yrs::types::text::{ChangeKind, Diff, TextEvent, YChange};
use yrs::types::xml::{XmlEvent, XmlTextEvent};
use yrs::types::{
    Attrs, Branch, BranchPtr, Change, DeepEventsSubscription, DeepObservable, Delta,
    EntryChange, Event, Events, Path, PathSegment, ToJson, TypeRef, Value,
};
use yrs::undo::{EventKind, UndoEventSubscription};
use yrs::updates::decoder::{Decode, DecoderV1};
use yrs::updates::encoder::{Encode, Encoder, EncoderV1, EncoderV2};
use yrs::{
    Array, ArrayRef, Assoc, DeleteSet, DestroySubscription, Doc, GetString, IndexScope,
    Map, MapRef, Observable, Offset, Options, Origin, ReadTxn, Snapshot, StateVector,
    StickyIndex, Store, SubdocsEvent, SubdocsEventIter, SubdocsSubscription,
    Subscription, Text, TextRef, Transact, Transaction, TransactionCleanupEvent,
    TransactionCleanupSubscription, TransactionMut, UndoManager, Update,
    UpdateSubscription, Xml, XmlElementPrelim, XmlElementRef, XmlFragment,
    XmlFragmentRef, XmlNode, XmlTextPrelim, XmlTextRef, ID,
};
use once_cell::unsync::Lazy;
const IMAGES_MAP: ::std::thread::LocalKey<Lazy<RefCell<GlobalState>>> = {
    #[inline]
    fn __init() -> Lazy<RefCell<GlobalState>> {
        Lazy::new(|| Default::default())
    }
    #[inline]
    unsafe fn __getit(
        init: ::std::option::Option<
            &mut ::std::option::Option<Lazy<RefCell<GlobalState>>>,
        >,
    ) -> ::std::option::Option<&'static Lazy<RefCell<GlobalState>>> {
        #[thread_local]
        static __KEY: ::std::thread::local_impl::Key<Lazy<RefCell<GlobalState>>> = ::std::thread::local_impl::Key::<
            Lazy<RefCell<GlobalState>>,
        >::new();
        #[allow(unused_unsafe)]
        unsafe {
            __KEY
                .get(move || {
                    if let ::std::option::Option::Some(init) = init {
                        if let ::std::option::Option::Some(value) = init.take() {
                            return value;
                        } else if true {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("missing default value")
                                    ),
                                );
                            };
                        }
                    }
                    __init()
                })
        }
    }
    unsafe { ::std::thread::LocalKey::new(__getit) }
};
const TXN_STATE: ::std::thread::LocalKey<Lazy<RefCell<TxnState>>> = {
    #[inline]
    fn __init() -> Lazy<RefCell<TxnState>> {
        Lazy::new(|| Default::default())
    }
    #[inline]
    unsafe fn __getit(
        init: ::std::option::Option<&mut ::std::option::Option<Lazy<RefCell<TxnState>>>>,
    ) -> ::std::option::Option<&'static Lazy<RefCell<TxnState>>> {
        #[thread_local]
        static __KEY: ::std::thread::local_impl::Key<Lazy<RefCell<TxnState>>> = ::std::thread::local_impl::Key::<
            Lazy<RefCell<TxnState>>,
        >::new();
        #[allow(unused_unsafe)]
        unsafe {
            __KEY
                .get(move || {
                    if let ::std::option::Option::Some(init) = init {
                        if let ::std::option::Option::Some(value) = init.take() {
                            return value;
                        } else if true {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("missing default value")
                                    ),
                                );
                            };
                        }
                    }
                    __init()
                })
        }
    }
    unsafe { ::std::thread::LocalKey::new(__getit) }
};
pub struct GlobalState {
    pub last_id: u32,
    pub docs: HashMap<u32, Doc>,
    pub texts: HashMap<u32, TextRef>,
    pub arrays: HashMap<u32, ArrayRef>,
    pub maps: HashMap<u32, MapRef>,
    pub xml_elements: HashMap<u32, XmlElementRef>,
    pub xml_fragments: HashMap<u32, XmlFragmentRef>,
    pub xml_texts: HashMap<u32, XmlTextRef>,
    pub snapshots: HashMap<u32, Snapshot>,
    pub callbacks: HashMap<u32, Subscription<Arc<dyn std::any::Any>>>,
}
#[automatically_derived]
impl ::core::default::Default for GlobalState {
    #[inline]
    fn default() -> GlobalState {
        GlobalState {
            last_id: ::core::default::Default::default(),
            docs: ::core::default::Default::default(),
            texts: ::core::default::Default::default(),
            arrays: ::core::default::Default::default(),
            maps: ::core::default::Default::default(),
            xml_elements: ::core::default::Default::default(),
            xml_fragments: ::core::default::Default::default(),
            xml_texts: ::core::default::Default::default(),
            snapshots: ::core::default::Default::default(),
            callbacks: ::core::default::Default::default(),
        }
    }
}
struct CallbackSubs {
    subs: Subscription<Arc<dyn std::any::Any>>,
    function_id: u32,
}
impl GlobalState {
    fn save_doc(&mut self, image: Doc) -> YDoc {
        let id = self.last_id;
        self.last_id += 1;
        let image_ref = YDoc { ref_: id };
        self.docs.insert(id, image);
        image_ref
    }
    fn save_text(&mut self, t: TextRef) -> YText {
        let id = self.last_id;
        self.last_id += 1;
        let v = YText { ref_: id };
        self.texts.insert(id, t);
        v
    }
    fn save_array(&mut self, t: ArrayRef) -> YArray {
        let id = self.last_id;
        self.last_id += 1;
        let v = YArray { ref_: id };
        self.arrays.insert(id, t);
        v
    }
    fn save_map(&mut self, t: MapRef) -> YMap {
        let id = self.last_id;
        self.last_id += 1;
        let v = YMap { ref_: id };
        self.maps.insert(id, t);
        v
    }
    fn save_xml_element(&mut self, t: XmlElementRef) -> YXmlElement {
        let id = self.last_id;
        self.last_id += 1;
        let v = YXmlElement { ref_: id };
        self.xml_elements.insert(id, t);
        v
    }
    fn save_xml_fragment(&mut self, t: XmlFragmentRef) -> YXmlFragment {
        let id = self.last_id;
        self.last_id += 1;
        let v = YXmlFragment { ref_: id };
        self.xml_fragments.insert(id, t);
        v
    }
    fn save_xml_text(&mut self, t: XmlTextRef) -> YXmlText {
        let id = self.last_id;
        self.last_id += 1;
        let v = YXmlText { ref_: id };
        self.xml_texts.insert(id, t);
        v
    }
    fn save_snapshot(&mut self, t: Snapshot) -> YSnapshot {
        let id = self.last_id;
        self.last_id += 1;
        let v = YSnapshot { ref_: id };
        self.snapshots.insert(id, t);
        v
    }
    fn save_callback(
        &mut self,
        subs: Subscription<Arc<dyn std::any::Any>>,
    ) -> EventObserver {
        self.last_id += 1;
        let id = self.last_id;
        self.callbacks.insert(id, subs);
        EventObserver { ref_: id }
    }
}
pub struct TxnState {
    pub last_id: u32,
    pub transactions: HashMap<u32, Rc<Transaction<'static>>>,
    pub transactions_mut: HashMap<u32, TransactionMut<'static>>,
}
#[automatically_derived]
impl ::core::default::Default for TxnState {
    #[inline]
    fn default() -> TxnState {
        TxnState {
            last_id: ::core::default::Default::default(),
            transactions: ::core::default::Default::default(),
            transactions_mut: ::core::default::Default::default(),
        }
    }
}
impl TxnState {
    fn save_transaction(&mut self, t: Transaction<'static>) -> ReadTransaction {
        let id = self.last_id;
        self.last_id += 1;
        let v = ReadTransaction { ref_: id };
        self.transactions.insert(id, Rc::new(t));
        v
    }
    fn save_transaction_mut(&mut self, t: TransactionMut<'static>) -> WriteTransaction {
        let id = self.last_id;
        self.last_id += 1;
        let v = WriteTransaction { ref_: id };
        self.transactions_mut.insert(id, t);
        v
    }
}
fn with_mut<T>(f: impl FnOnce(&mut GlobalState) -> T) -> T {
    IMAGES_MAP.with(|v| f(&mut v.borrow_mut()))
}
fn with<T>(f: impl FnOnce(&GlobalState) -> T) -> T {
    IMAGES_MAP.with(|v| f(&v.borrow()))
}
fn with_txn_state<T>(f: impl FnOnce(&mut TxnState) -> T) -> T {
    TXN_STATE.with(|v| f(&mut v.borrow_mut()))
}
fn operation<T>(image_ref: YDoc, f: impl FnOnce(&Doc) -> T) -> T {
    with(|state| {
        let img = &state.docs[&image_ref.ref_];
        f(img)
    })
}
fn with_mut_all<T>(f: impl FnOnce(&mut GlobalState, &mut TxnState) -> T) -> T {
    IMAGES_MAP
        .with(|v| {
            TXN_STATE.with(|state| f(&mut v.borrow_mut(), &mut state.borrow_mut()))
        })
}
fn with_txn<T>(t: YTransaction, f: impl FnOnce(&YTransactionInner) -> T) -> T {
    TXN_STATE
        .with(|state| {
            let mut m = state.borrow_mut();
            let t = YTransactionInner::from_ref(t, &mut m);
            f(&t)
        })
}
fn with_text<T>(
    text: YText,
    txn: ImplicitTransaction,
    f: impl FnOnce(&TextRef, &mut TransactionMut<'static>) -> T,
) -> T {
    IMAGES_MAP
        .with(|state| {
            TXN_STATE
                .with(|txs| {
                    let v = &state.borrow_mut().texts[&text.ref_];
                    YTransactionInner::from_transact_mut_f(
                        txn,
                        v,
                        &mut txs.borrow_mut(),
                        |txn| f(v, txn),
                    )
                })
        })
}
fn with_array<T>(
    array: YArray,
    txn: ImplicitTransaction,
    f: impl FnOnce(&ArrayRef, &mut TransactionMut<'static>) -> T,
) -> T {
    IMAGES_MAP
        .with(|state| {
            TXN_STATE
                .with(|txs| {
                    let v = &state.borrow_mut().arrays[&array.ref_];
                    YTransactionInner::from_transact_mut_f(
                        txn,
                        v,
                        &mut txs.borrow_mut(),
                        |txn| f(v, txn),
                    )
                })
        })
}
fn with_map<T>(
    map: YMap,
    txn: ImplicitTransaction,
    f: impl FnOnce(&MapRef, &mut TransactionMut<'static>) -> T,
) -> T {
    IMAGES_MAP
        .with(|state| {
            TXN_STATE
                .with(|txs| {
                    let v = &state.borrow_mut().maps[&map.ref_];
                    YTransactionInner::from_transact_mut_f(
                        txn,
                        v,
                        &mut txs.borrow_mut(),
                        |txn| f(v, txn),
                    )
                })
        })
}
struct YTransactionInner<'a>(InnerTxn<'a>);
enum InnerTxn<'a> {
    ReadOnly(Rc<Transaction<'static>>),
    ReadWrite(&'a mut TransactionMut<'static>),
}
impl<'a> YTransactionInner<'a> {
    fn from_ref(txn: YTransaction, state: &'a mut TxnState) -> Self {
        match txn {
            YTransaction::ReadTransaction(t) => {
                let txn = &state.transactions[&t.ref_];
                YTransactionInner(InnerTxn::ReadOnly(txn.clone()))
            }
            YTransaction::WriteTransaction(t) => {
                let txn = state.transactions_mut.get_mut(&t.ref_).unwrap();
                YTransactionInner(InnerTxn::ReadWrite(txn))
            }
        }
    }
    fn from_transact<T: Transact>(
        txn: ImplicitTransaction,
        transact: &'a T,
        state: &'a mut TxnState,
    ) -> Self {
        txn.map(|t| YTransactionInner::from_ref(t, state))
            .unwrap_or_else(|| {
                YTransactionInner(
                    InnerTxn::ReadOnly(
                        Rc::new(unsafe { std::mem::transmute(transact.transact()) }),
                    ),
                )
            })
    }
    fn from_transact_mut_f<T: Transact, P>(
        txn: ImplicitTransaction,
        transact: T,
        state: &mut TxnState,
        f: impl FnOnce(&mut TransactionMut<'static>) -> P,
    ) -> P {
        match txn {
            Some(YTransaction::WriteTransaction(txn)) => {
                f(state.transactions_mut.get_mut(&txn.ref_).unwrap())
            }
            _ => {
                let mut a = transact.transact_mut();
                f(unsafe { std::mem::transmute(&mut a) })
            }
        }
    }
    fn from_transact_mut_none<T: Transact>(
        txn: ImplicitTransaction,
        transact: T,
        state: &mut TxnState,
    ) -> Option<&mut TransactionMut<'static>> {
        match txn {
            Some(YTransaction::WriteTransaction(txn)) => {
                Some(state.transactions_mut.get_mut(&txn.ref_).unwrap())
            }
            _ => None,
        }
    }
    fn try_mut(&mut self) -> Option<&mut TransactionMut<'static>> {
        match &mut self.0 {
            InnerTxn::ReadOnly(_) => None,
            InnerTxn::ReadWrite(txn) => Some(txn),
        }
    }
    fn try_apply(&mut self, update: Update) -> Result<(), String> {
        if let Some(txn) = self.try_mut() {
            txn.apply_update(update);
            Ok(())
        } else {
            Err("cannot apply an update using a read-only transaction".to_string())
        }
    }
}
impl<'a> ReadTxn for YTransactionInner<'a> {
    fn store(&self) -> &Store {
        match &self.0 {
            InnerTxn::ReadOnly(txn) => txn.store(),
            InnerTxn::ReadWrite(txn) => txn.store(),
        }
    }
}
enum SharedType<T, P> {
    Integrated(T),
    Prelim(P),
}
impl<T, P> SharedType<T, P> {
    #[inline(always)]
    fn new(value: T) -> RefCell<Self> {
        RefCell::new(SharedType::Integrated(value))
    }
    #[inline(always)]
    fn prelim(prelim: P) -> RefCell<Self> {
        RefCell::new(SharedType::Prelim(prelim))
    }
    fn as_integrated(&self) -> Option<&T> {
        if let SharedType::Integrated(value) = self { Some(value) } else { None }
    }
}
struct YTextInner(RefCell<SharedType<TextRef, String>>);
struct WitImplementation;
const _: () = {
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_element_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_element_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_fragment_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_fragment_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-text-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_text_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_text_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-transaction-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_transaction_dispose(
            arg0: i32,
            arg1: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_transaction_dispose::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-value-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_value_dispose(
            arg0: i32,
            arg1: i32,
            arg2: i64,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i32,
            arg7: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_value_dispose::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#callback-dispose"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_callback_dispose(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_callback_dispose::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-new"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_new(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_new::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-parent-doc"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_parent_doc(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_parent_doc::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-id"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_id(arg0: i32) -> i64 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_id::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-guid"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_guid(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_guid::<
                WitImplementation,
            >(arg0)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-doc-guid"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_doc_guid(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_doc_guid::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-read-transaction"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_read_transaction(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_read_transaction::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-write-transaction"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_write_transaction(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_write_transaction::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-text"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_text(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_text::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-array"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_array(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_array::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-map"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_map(arg0: i32, arg1: i32, arg2: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_map::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-xml-fragment"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_xml_fragment(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_xml_fragment::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-xml-element"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_xml_element(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_xml_element::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-xml-text"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_xml_text(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_xml_text::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-on-update-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_doc_on_update_v1(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_doc_on_update_v1::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#load"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_load(arg0: i32, arg1: i32, arg2: i32, arg3: i32) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_load::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#destroy"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_destroy(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_destroy::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#subdocs"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_subdocs(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_subdocs::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#subdocs"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_subdocs(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_subdocs::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#subdoc-guids"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_subdoc_guids(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_subdoc_guids::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#subdoc-guids"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_subdoc_guids(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_subdoc_guids::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-vector"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_state_vector(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_state_vector::<
                WitImplementation,
            >(arg0)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-vector"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_state_vector(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_state_vector::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_state_as_update(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_state_as_update::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_state_as_update(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_state_as_update::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_state_as_update_v2(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_state_as_update_v2::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_state_as_update_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_state_as_update_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#apply-update"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_apply_update(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_apply_update::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#apply-update"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_apply_update(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_apply_update::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#apply-update-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_apply_update_v2(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_apply_update_v2::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#apply-update-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_apply_update_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_apply_update_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-origin"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_origin(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_origin::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-origin"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_origin(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_origin::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-commit"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_commit(arg0: i32, arg1: i32) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_commit::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-state-vector-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_state_vector_v1(
            arg0: i32,
            arg1: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_state_vector_v1::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-state-vector-v1"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_state_vector_v1(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_state_vector_v1::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_diff_v1(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_diff_v1::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v1"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_diff_v1(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_diff_v1::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_diff_v2(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_diff_v2::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_diff_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_diff_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_apply_v1(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_apply_v1::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v1"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_apply_v1(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_apply_v1::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_apply_v2(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_apply_v2::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_apply_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_apply_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_encode_update(
            arg0: i32,
            arg1: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_encode_update::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_encode_update(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_encode_update::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_transaction_encode_update_v2(
            arg0: i32,
            arg1: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_transaction_encode_update_v2::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_transaction_encode_update_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_transaction_encode_update_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-new"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_new(
            arg0: i32,
            arg1: i32,
            arg2: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_new::<
                WitImplementation,
            >(arg0, arg1, arg2)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-prelim"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_prelim(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_prelim::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-length"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_length(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_length::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-string"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_to_string(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_to_string::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-string"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_text_to_string(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_text_to_string::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-json"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_to_json(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_to_json::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-json"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_text_to_json(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_text_to_json::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-insert"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_insert(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i64,
            arg7: i32,
            arg8: i32,
            arg9: i32,
            arg10: i32,
            arg11: i32,
            arg12: i32,
            arg13: i32,
            arg14: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_insert::<
                WitImplementation,
            >(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
                arg8,
                arg9,
                arg10,
                arg11,
                arg12,
                arg13,
                arg14,
            )
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-insert-embed"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_insert_embed(arg0: i32) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_insert_embed::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-format"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_format(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i64,
            arg5: i32,
            arg6: i32,
            arg7: i32,
            arg8: i32,
            arg9: i32,
            arg10: i32,
            arg11: i32,
            arg12: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_format::<
                WitImplementation,
            >(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
                arg8,
                arg9,
                arg10,
                arg11,
                arg12,
            )
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-push"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_push(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i64,
            arg6: i32,
            arg7: i32,
            arg8: i32,
            arg9: i32,
            arg10: i32,
            arg11: i32,
            arg12: i32,
            arg13: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_push::<
                WitImplementation,
            >(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
                arg8,
                arg9,
                arg10,
                arg11,
                arg12,
                arg13,
            )
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-delete"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_delete(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_delete::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-delta"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_to_delta(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i32,
            arg7: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_to_delta::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-delta"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_text_to_delta(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_text_to_delta::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-observe"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_observe(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_observe::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-observe-deep"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_text_observe_deep(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_text_observe_deep::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#snapshot"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_snapshot(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_snapshot::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#equal-snapshot"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_equal_snapshot(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_equal_snapshot::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_snapshot_v1(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_snapshot_v1::<
                WitImplementation,
            >(arg0)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v1"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_snapshot_v1(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_snapshot_v1::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_snapshot_v2(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_snapshot_v2::<
                WitImplementation,
            >(arg0)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_snapshot_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_snapshot_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_decode_snapshot_v1(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_decode_snapshot_v1::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v1"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_decode_snapshot_v1(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_decode_snapshot_v1::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_decode_snapshot_v2(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_decode_snapshot_v2::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_decode_snapshot_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_decode_snapshot_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v1"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_state_from_snapshot_v1(
            arg0: i32,
            arg1: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_state_from_snapshot_v1::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v1"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_state_from_snapshot_v1(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_state_from_snapshot_v1::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v2"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_encode_state_from_snapshot_v2(
            arg0: i32,
            arg1: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_encode_state_from_snapshot_v2::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v2"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_encode_state_from_snapshot_v2(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_encode_state_from_snapshot_v2::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-new"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_new(
            arg0: i32,
            arg1: i32,
            arg2: i64,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i32,
            arg7: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_new::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-prelim"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_prelim(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_prelim::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-length"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_length(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_length::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-to-json"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_to_json(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_to_json::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-array-to-json"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_array_to_json(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_array_to_json::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-insert"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_insert(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i64,
            arg4: i32,
            arg5: i32,
            arg6: i32,
            arg7: i32,
            arg8: i32,
            arg9: i32,
            arg10: i32,
            arg11: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_insert::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-push"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_push(
            arg0: i32,
            arg1: i32,
            arg2: i64,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i32,
            arg7: i32,
            arg8: i32,
            arg9: i32,
            arg10: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_push::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-delete"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_delete(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_delete::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-move-content"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_move_content(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_move_content::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-get"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_get(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_get::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-array-get"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_array_get(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_array_get::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-values"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_values(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_values::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-array-values"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_array_values(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_array_values::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-observe"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_observe(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_observe::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-observe-deep"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_array_observe_deep(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_array_observe_deep::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-new"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_new(
            arg0: i32,
            arg1: i32,
            arg2: i64,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i32,
            arg7: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_new::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-prelim"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_prelim(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_prelim::<
                WitImplementation,
            >(arg0)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-length"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_length(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_length::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-to-json"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_to_json(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_to_json::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-map-to-json"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_map_to_json(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_map_to_json::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-set"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_set(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i64,
            arg5: i32,
            arg6: i32,
            arg7: i32,
            arg8: i32,
            arg9: i32,
            arg10: i32,
            arg11: i32,
            arg12: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_set::<
                WitImplementation,
            >(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
                arg8,
                arg9,
                arg10,
                arg11,
                arg12,
            )
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-delete"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_delete(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_delete::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-get"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_get(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_get::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-map-get"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_map_get(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_map_get::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-entries"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_entries(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_entries::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-map-entries"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_map_entries(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_map_entries::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-observe"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_observe(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_observe::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-observe-deep"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_map_observe_deep(arg0: i32, arg1: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_map_observe_deep::<
                WitImplementation,
            >(arg0, arg1)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-name"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_element_name(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_element_name::<
                WitImplementation,
            >(arg0)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-name"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_xml_element_name(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_xml_element_name::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-length"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_element_length(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_element_length::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-insert-xml-element"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_element_insert_xml_element(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
            arg6: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_element_insert_xml_element::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-insert-xml-text"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_element_insert_xml_text(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_element_insert_xml_text::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-delete"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_element_delete(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_element_delete::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3, arg4, arg5)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-name"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_fragment_name(arg0: i32) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_fragment_name::<
                WitImplementation,
            >(arg0)
        }
    };
    #[doc(hidden)]
    #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-name"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_y_xml_fragment_name(arg0: i32) {
        exports::y_crdt_namespace::y_crdt::y_doc_methods::post_return_y_xml_fragment_name::<
            WitImplementation,
        >(arg0)
    }
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-length"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_fragment_length(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_fragment_length::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
    const _: () = {
        #[doc(hidden)]
        #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-text-length"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __export_y_xml_text_length(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
        ) -> i32 {
            exports::y_crdt_namespace::y_crdt::y_doc_methods::call_y_xml_text_length::<
                WitImplementation,
            >(arg0, arg1, arg2, arg3)
        }
    };
};
fn parse_options(options: YDocOptions) -> Options {
    let mut opts = Options::default();
    options.client_id.map(|v| opts.client_id = v);
    options.guid.map(|v| opts.guid = v.into());
    opts.collection_id = options.collection_id;
    options
        .offset_kind
        .map(|v| {
            opts
                .offset_kind = match v {
                OffsetKind::Utf16 => yrs::OffsetKind::Utf16,
                OffsetKind::Utf32 => yrs::OffsetKind::Utf32,
                OffsetKind::Bytes => yrs::OffsetKind::Bytes,
            }
        });
    options.skip_gc.map(|v| opts.skip_gc = v);
    options.auto_load.map(|v| opts.auto_load = v);
    options.should_load.map(|v| opts.should_load = v);
    opts
}
impl YDocMethods for WitImplementation {
    fn y_doc_dispose(doc: YDoc) -> bool {
        with_mut(|state| state.docs.remove(&doc.ref_).is_some())
    }
    fn y_text_dispose(text: YText) -> bool {
        with_mut(|state| state.texts.remove(&text.ref_).is_some())
    }
    fn y_array_dispose(array: YArray) -> bool {
        with_mut(|state| state.arrays.remove(&array.ref_).is_some())
    }
    fn y_map_dispose(map: YMap) -> bool {
        with_mut(|state| state.maps.remove(&map.ref_).is_some())
    }
    fn y_xml_element_dispose(xml_element: YXmlElement) -> bool {
        with_mut(|state| state.xml_elements.remove(&xml_element.ref_).is_some())
    }
    fn y_xml_fragment_dispose(xml_fragment: YXmlFragment) -> bool {
        with_mut(|state| state.xml_fragments.remove(&xml_fragment.ref_).is_some())
    }
    fn y_xml_text_dispose(xml_text: YXmlText) -> bool {
        with_mut(|state| state.xml_texts.remove(&xml_text.ref_).is_some())
    }
    fn y_transaction_dispose(transaction: YTransaction) -> bool {
        with_txn_state(|state| match transaction {
            YTransaction::ReadTransaction(a) => {
                state.transactions.remove(&a.ref_).is_some()
            }
            YTransaction::WriteTransaction(a) => {
                state.transactions.remove(&a.ref_).is_some()
            }
        })
    }
    fn y_value_dispose(value: YValue) -> bool {
        match value {
            YValue::JsonValueItem(_) => false,
            YValue::YText(a) => Self::y_text_dispose(a),
            YValue::YArray(a) => Self::y_array_dispose(a),
            YValue::YMap(a) => Self::y_map_dispose(a),
            YValue::YXmlElement(a) => Self::y_xml_element_dispose(a),
            YValue::YXmlFragment(a) => Self::y_xml_fragment_dispose(a),
            YValue::YXmlText(a) => Self::y_xml_text_dispose(a),
            YValue::YDoc(a) => Self::y_doc_dispose(a),
        }
    }
    fn callback_dispose(obs: EventObserver) -> bool {
        with_mut(|state| state.callbacks.remove(&obs.ref_).is_some())
    }
    fn y_doc_new(options: Option<YDocOptions>) -> YDoc {
        let options = options.map(parse_options).unwrap_or_default();
        with_mut(|m| m.save_doc(Doc::with_options(options)))
    }
    fn y_doc_parent_doc(doc: YDoc) -> Option<YDoc> {
        with_mut(|state| {
            let img = &state.docs[&doc.ref_];
            img.parent_doc().map(|d| state.save_doc(d))
        })
    }
    fn y_doc_id(doc: YDoc) -> u64 {
        operation(doc, |doc| doc.client_id())
    }
    fn y_doc_guid(doc: YDoc) -> String {
        operation(doc, |doc| doc.guid().to_string())
    }
    fn y_doc_read_transaction(doc: YDoc) -> ReadTransaction {
        with_mut_all(|state, txs| {
            let d = unsafe { std::mem::transmute(state.docs[&doc.ref_].transact()) };
            txs.save_transaction(d)
        })
    }
    fn y_doc_write_transaction(doc: YDoc, origin: Vec<u8>) -> WriteTransaction {
        with_mut_all(|state, txs| {
            let d = unsafe { std::mem::transmute(state.docs[&doc.ref_].transact_mut()) };
            txs.save_transaction_mut(d)
        })
    }
    fn y_doc_text(doc: YDoc, name: String) -> YText {
        with_mut(|state| {
            let d = &state.docs[&doc.ref_];
            state.save_text(d.get_or_insert_text(&name))
        })
    }
    fn y_doc_array(doc: YDoc, name: String) -> YArray {
        with_mut(|state| {
            let d = &state.docs[&doc.ref_];
            state.save_array(d.get_or_insert_array(&name))
        })
    }
    fn y_doc_map(doc: YDoc, name: String) -> YMap {
        with_mut(|state| {
            let d = &state.docs[&doc.ref_];
            state.save_map(d.get_or_insert_map(&name))
        })
    }
    fn y_doc_xml_fragment(doc: YDoc, _: String) -> YXmlFragment {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_xml_element(doc: YDoc, _: String) -> YXmlElement {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_xml_text(doc: YDoc, _: String) -> YXmlText {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_on_update_v1(doc: YDoc, _: u32) -> EventObserver {
        ::core::panicking::panic("not yet implemented")
    }
    fn subdocs(doc: YDoc, txn: ImplicitTransaction) -> Vec<YDoc> {
        with_mut_all(|state, txs| {
            let doc = &state.docs[&doc.ref_];
            let list: Vec<_> = YTransactionInner::from_transact(txn, doc, txs)
                .subdocs()
                .into_iter()
                .map(|d| d.clone())
                .collect();
            list.into_iter().map(|d| state.save_doc(d.clone())).collect()
        })
    }
    fn subdoc_guids(doc: YDoc, txn: ImplicitTransaction) -> Vec<String> {
        with_mut_all(|state, txs| {
            let doc = &state.docs[&doc.ref_];
            YTransactionInner::from_transact(txn, doc, txs)
                .subdoc_guids()
                .into_iter()
                .map(|d| d.to_string())
                .collect()
        })
    }
    fn load(doc: YDoc, txn: ImplicitTransaction) {
        with_mut_all(|state, txs| {
            let d = &state.docs[&doc.ref_];
            if let Some(YTransaction::WriteTransaction(txn)) = txn {
                let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                d.load(txn)
            } else {
                if let Some(parent) = d.parent_doc() {
                    let mut txn = parent.transact_mut();
                    d.load(&mut txn)
                }
            }
        })
    }
    fn destroy(doc: YDoc, txn: ImplicitTransaction) {
        with_mut_all(|state, txs| {
            let d = state.docs.get_mut(&doc.ref_).unwrap();
            if let Some(YTransaction::WriteTransaction(txn)) = txn {
                let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                d.destroy(txn)
            } else {
                if let Some(parent) = d.parent_doc() {
                    let mut txn = parent.transact_mut();
                    d.destroy(&mut txn)
                }
            }
        })
    }
    fn y_text_to_delta(
        text: YText,
        snapshot: Option<YSnapshot>,
        prev_snapshot: Option<YSnapshot>,
        txn: ImplicitTransaction,
    ) -> Vec<YTextDelta> {
        with_mut_all(|state, txs| {
            let v = &state.texts[&text.ref_];
            YTransactionInner::from_transact_mut_f(
                txn,
                v,
                txs,
                |txn| {
                    let hi = snapshot.map(|s| state.snapshots.get(&s.ref_)).flatten();
                    let lo = prev_snapshot
                        .map(|s| state.snapshots.get(&s.ref_))
                        .flatten();
                    v.diff_range(txn, hi, lo, |change| change)
                        .into_iter()
                        .map(ytext_change_into_delta)
                        .collect()
                },
            )
        })
    }
    fn snapshot(doc: YDoc) -> YSnapshot {
        with_mut(|state| {
            let d = state.docs.get_mut(&doc.ref_).unwrap().transact().snapshot();
            state.save_snapshot(d)
        })
    }
    fn equal_snapshot(left: YSnapshot, right: YSnapshot) -> bool {
        with(|state| {
            let left = &state.snapshots[&left.ref_];
            let right = &state.snapshots[&right.ref_];
            left == right
        })
    }
    fn encode_snapshot_v1(snapshot: YSnapshot) -> Vec<u8> {
        with(|state| {
            let snapshot = &state.snapshots[&snapshot.ref_];
            snapshot.encode_v1()
        })
    }
    fn encode_snapshot_v2(snapshot: YSnapshot) -> Vec<u8> {
        with(|state| {
            let snapshot = &state.snapshots[&snapshot.ref_];
            snapshot.encode_v2()
        })
    }
    fn decode_snapshot_v1(snapshot: Vec<u8>) -> Result<YSnapshot, Error> {
        with_mut(|state| {
            let s = Snapshot::decode_v1(&snapshot)
                .map_err(|e| {
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "failed to deserialize snapshot using lib0 v1 decoding. {0}",
                                e
                            ),
                        );
                        res
                    }
                })?;
            Ok(state.save_snapshot(s))
        })
    }
    fn decode_snapshot_v2(snapshot: Vec<u8>) -> Result<YSnapshot, Error> {
        with_mut(|state| {
            let s = Snapshot::decode_v2(&snapshot)
                .map_err(|e| {
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "failed to deserialize snapshot using lib0 v2 decoding. {0}",
                                e
                            ),
                        );
                        res
                    }
                })?;
            Ok(state.save_snapshot(s))
        })
    }
    fn encode_state_from_snapshot_v1(
        doc: YDoc,
        snapshot: YSnapshot,
    ) -> Result<Vec<u8>, Error> {
        with_mut(|state| {
            let mut encoder = EncoderV1::new();
            let snapshot = &state.snapshots[&snapshot.ref_];
            match state
                .docs[&doc.ref_]
                .transact()
                .encode_state_from_snapshot(snapshot, &mut encoder)
            {
                Ok(_) => Ok(encoder.to_vec()),
                Err(e) => Err(e.to_string()),
            }
        })
    }
    fn encode_state_from_snapshot_v2(
        doc: YDoc,
        snapshot: YSnapshot,
    ) -> Result<Vec<u8>, Error> {
        with_mut(|state| {
            let mut encoder = EncoderV2::new();
            let snapshot = &state.snapshots[&snapshot.ref_];
            match state
                .docs[&doc.ref_]
                .transact()
                .encode_state_from_snapshot(snapshot, &mut encoder)
            {
                Ok(_) => Ok(encoder.to_vec()),
                Err(e) => Err(e.to_string()),
            }
        })
    }
    fn encode_state_vector(doc: YDoc) -> Vec<u8> {
        operation(doc, |doc| doc.transact().state_vector().encode_v1())
    }
    fn encode_state_as_update(
        doc: YDoc,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        operation(
            doc,
            |doc| {
                let s = doc.transact();
                diff_v1(&s, vector)
            },
        )
    }
    fn encode_state_as_update_v2(
        doc: YDoc,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        operation(
            doc,
            |doc| {
                let s = doc.transact();
                diff_v2(&s, vector)
            },
        )
    }
    fn apply_update(doc: YDoc, diff: Vec<u8>, origin: Vec<u8>) -> Result<(), String> {
        operation(
            doc,
            |doc| {
                let mut txn = doc.transact_mut();
                let mut decoder = DecoderV1::from(diff.as_slice());
                match Update::decode(&mut decoder) {
                    Ok(update) => Ok(txn.apply_update(update)),
                    Err(e) => Err(e.to_string()),
                }
            },
        )
    }
    fn apply_update_v2(doc: YDoc, diff: Vec<u8>, origin: Vec<u8>) -> Result<(), String> {
        operation(
            doc,
            |doc| {
                let mut txn = doc.transact_mut();
                match Update::decode_v2(&diff) {
                    Ok(update) => Ok(txn.apply_update(update)),
                    Err(e) => Err(e.to_string()),
                }
            },
        )
    }
    fn transaction_origin(t: YTransaction) -> Option<Vec<u8>> {
        with_txn_state(|state| match t {
            YTransaction::ReadTransaction(t) => None,
            YTransaction::WriteTransaction(t) => {
                state.transactions_mut[&t.ref_].origin().map(|r| r.as_ref().to_vec())
            }
        })
    }
    fn transaction_commit(t: YTransaction) {
        with_txn_state(|state| match &t {
            YTransaction::ReadTransaction(t) => {
                state.transactions.remove(&t.ref_);
            }
            YTransaction::WriteTransaction(t) => {
                state.transactions_mut.remove(&t.ref_).unwrap().commit()
            }
        })
    }
    fn transaction_state_vector_v1(t: YTransaction) -> Vec<u8> {
        with_txn(t, |t| t.state_vector().encode_v1().to_vec())
    }
    fn transaction_diff_v1(
        t: YTransaction,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        with_txn(t, |t| diff_v1(t, vector))
    }
    fn transaction_diff_v2(
        txn: YTransaction,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        with_txn(txn, |txn| diff_v2(txn, vector))
    }
    fn transaction_apply_v1(txn: YTransaction, diff: Vec<u8>) -> Result<(), Error> {
        match txn {
            YTransaction::ReadTransaction(_) => {
                Err("Cannot apply update to read transaction".to_string())
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|txs| {
                    let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                    let mut decoder = DecoderV1::from(diff.as_slice());
                    match Update::decode(&mut decoder) {
                        Ok(update) => Ok(txn.apply_update(update)),
                        Err(e) => Err(e.to_string()),
                    }
                })
            }
        }
    }
    fn transaction_apply_v2(txn: YTransaction, diff: Vec<u8>) -> Result<(), String> {
        match txn {
            YTransaction::ReadTransaction(_) => {
                Err("Cannot apply update to read transaction".to_string())
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|txs| {
                    let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                    match Update::decode_v2(diff.as_slice()) {
                        Ok(update) => Ok(txn.apply_update(update)),
                        Err(e) => Err(e.to_string()),
                    }
                })
            }
        }
    }
    fn transaction_encode_update(t: YTransaction) -> Vec<u8> {
        match t {
            YTransaction::ReadTransaction(_) => {
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0u8, 0u8]))
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|state| {
                    state.transactions_mut[&txn.ref_].encode_update_v1()
                })
            }
        }
    }
    fn transaction_encode_update_v2(t: YTransaction) -> Vec<u8> {
        match t {
            YTransaction::ReadTransaction(_) => {
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0u8, 0u8]))
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|state| {
                    state.transactions_mut[&txn.ref_].encode_update_v2()
                })
            }
        }
    }
    fn y_text_new(init: Option<String>) -> YText {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_text_prelim(text: YText) -> bool {
        false
    }
    fn y_text_length(text: YText, txn: ImplicitTransaction) -> u32 {
        with_mut_all(|state, txs| {
            let text = &state.texts[&text.ref_];
            let txn = YTransactionInner::from_transact(txn, text, txs);
            text.len(&txn) as u32
        })
    }
    fn y_text_to_string(text: YText, txn: ImplicitTransaction) -> String {
        with_mut_all(|state, txs| {
            let text = &state.texts[&text.ref_];
            let txn = YTransactionInner::from_transact(txn, text, txs);
            text.get_string(&txn)
        })
    }
    fn y_text_to_json(text: YText, txn: ImplicitTransaction) -> String {
        Self::y_text_to_string(text, txn)
    }
    fn y_text_insert(
        text: YText,
        index: u32,
        chunk: String,
        attributes: Option<JsonObject>,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let chunk = &chunk;
                if let Some(attrs) = attributes.map(parse_attrs) {
                    v.insert_with_attributes(txn, index, chunk, attrs)
                } else {
                    v.insert(txn, index, chunk)
                }
            },
        )
    }
    fn y_text_insert_embed(
        text: YText,
        index: u32,
        embed: JsonValueItem,
        attributes: Option<JsonObject>,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let embed = map_json_value_any(embed);
                if let Some(attrs) = attributes.map(parse_attrs) {
                    v.insert_embed_with_attributes(txn, index, embed, attrs);
                } else {
                    v.insert_embed(txn, index, embed);
                }
            },
        )
    }
    fn y_text_format(
        text: YText,
        index: u32,
        length: u32,
        attributes: JsonObject,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let attrs = parse_attrs(attributes);
                v.format(txn, index, length, attrs);
            },
        )
    }
    fn y_text_push(
        text: YText,
        chunk: String,
        attributes: Option<JsonObject>,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let chunk = &chunk;
                if let Some(attrs) = attributes.map(parse_attrs) {
                    let index = v.len(txn);
                    v.insert_with_attributes(txn, index, chunk, attrs)
                } else {
                    v.push(txn, chunk)
                }
            },
        )
    }
    fn y_text_delete(text: YText, index: u32, length: u32, txn: ImplicitTransaction) {
        with_text(
            text,
            txn,
            |v, txn| {
                v.remove_range(txn, index, length);
            },
        )
    }
    fn y_text_observe(text: YText, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.texts.get_mut(&text.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(
                    v
                        .observe(move |e_txn, e| {
                            let event = map_text_event(text.clone(), e_txn, e);
                            event_callback(function_id, event)
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
    fn y_text_observe_deep(text: YText, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.texts.get_mut(&text.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(
                    v
                        .observe_deep(move |e_txn, e| {
                            with_mut(|state| {
                                let events = e
                                    .iter()
                                    .map(|e| map_event(state, e_txn, e))
                                    .collect::<Vec<_>>();
                                event_deep_callback(function_id, &events)
                            })
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
    fn y_array_new(_: Option<JsonArray>) -> YArray {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_array_prelim(array: YArray) -> bool {
        false
    }
    fn y_array_length(array: YArray, txn: ImplicitTransaction) -> u32 {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.len(&txn)
        })
    }
    fn y_array_to_json(array: YArray, txn: ImplicitTransaction) -> JsonValueItem {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            map_any_json_value(v.to_json(&txn))
        })
    }
    fn y_array_insert(
        array: YArray,
        index: u32,
        items: JsonArray,
        txn: ImplicitTransaction,
    ) {
        with_array(
            array,
            txn,
            |v, txn| {
                let items = match map_json_value_any(items) {
                    Any::Array(items) => items,
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("expected array"));
                    }
                };
                insert_at(v, txn, index, items);
            },
        )
    }
    fn y_array_push(array: YArray, items: JsonArray, txn: ImplicitTransaction) {
        with_array(
            array,
            txn,
            |v, txn| {
                let index = v.len(txn);
                let items = match map_json_value_any(items) {
                    Any::Array(items) => items,
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("expected array"));
                    }
                };
                insert_at(v, txn, index, items);
            },
        )
    }
    fn y_array_delete(array: YArray, index: u32, length: u32, txn: ImplicitTransaction) {
        with_array(
            array,
            txn,
            |v, txn| {
                v.remove_range(txn, index, length);
            },
        )
    }
    fn y_array_move_content(
        array: YArray,
        source: u32,
        target: u32,
        txn: ImplicitTransaction,
    ) {
        with_array(array, txn, |v, txn| v.move_to(txn, source, target))
    }
    fn y_array_get(
        array: YArray,
        index: u32,
        txn: ImplicitTransaction,
    ) -> Result<YValue, String> {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            if let Some(value) = v.get(&txn, index) {
                Ok(map_y_value(value))
            } else {
                Err("Index outside the bounds of an YArray".to_string())
            }
        })
    }
    fn y_array_values(array: YArray, txn: ImplicitTransaction) -> Vec<YValue> {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.iter(&txn).map(map_y_value).collect()
        })
    }
    fn y_array_observe(array: YArray, function_id: u32) -> EventObserver {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_array_observe_deep(array: YArray, function_id: u32) -> EventObserver {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_map_new(_: Option<JsonObject>) -> YMap {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_map_prelim(map: YMap) -> bool {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_map_length(map: YMap, txn: ImplicitTransaction) -> u32 {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.len(&txn)
        })
    }
    fn y_map_to_json(map: YMap, txn: ImplicitTransaction) -> JsonValueItem {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            map_any_json_value(v.to_json(&txn))
        })
    }
    fn y_map_set(
        map: YMap,
        key: String,
        value: JsonValueItem,
        txn: ImplicitTransaction,
    ) {
        with_map(
            map,
            txn,
            |v, txn| {
                v.insert(txn, key, map_json_value_any(value));
            },
        )
    }
    fn y_map_delete(map: YMap, key: String, txn: ImplicitTransaction) {
        with_map(
            map,
            txn,
            |v, txn| {
                v.remove(txn, &key);
            },
        )
    }
    fn y_map_get(map: YMap, key: String, txn: ImplicitTransaction) -> Option<YValue> {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.get(&txn, &key).map(map_y_value)
        })
    }
    fn y_map_entries(map: YMap, txn: ImplicitTransaction) -> Vec<(String, YValue)> {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.iter(&txn).map(|(k, v)| (k.to_string(), map_y_value(v))).collect()
        })
    }
    fn y_map_observe(map: YMap, function_id: u32) -> EventObserver {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_map_observe_deep(map: YMap, function_id: u32) -> EventObserver {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_name(_: YXmlElement) -> Option<String> {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_length(_: YXmlElement, txn: ImplicitTransaction) -> u32 {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_insert_xml_element(
        _: YXmlElement,
        _: u32,
        _: String,
        txn: ImplicitTransaction,
    ) -> YXmlElement {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_insert_xml_text(
        _: YXmlElement,
        _: u32,
        txn: ImplicitTransaction,
    ) -> YXmlText {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_delete(_: YXmlElement, _: u32, _: u32, txn: ImplicitTransaction) {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_fragment_name(_: YXmlFragment) -> Option<String> {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_fragment_length(_: YXmlFragment, txn: ImplicitTransaction) -> u32 {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_text_length(_: YXmlText, txn: ImplicitTransaction) -> u32 {
        ::core::panicking::panic("not yet implemented")
    }
}
fn map_text_delta(d: &Delta) -> YTextDelta {
    match d {
        Delta::Inserted(v, attrs) => {
            YTextDelta::YTextDeltaInsert(YTextDeltaInsert {
                insert: string_from_value(v),
                attributes: None,
            })
        }
        Delta::Deleted(c) => {
            YTextDelta::YTextDeltaDelete(YTextDeltaDelete { delete: *c })
        }
        Delta::Retain(v, attrs) => {
            YTextDelta::YTextDeltaRetain(YTextDeltaRetain {
                retain: *v,
                attributes: None,
            })
        }
    }
}
fn map_array_delta(d: &Change) -> YArrayDeltaOwned {
    match d {
        Change::Added(v) => {
            let insert = v.iter().map(|v| map_y_value(v.clone())).collect::<Vec<_>>();
            let slice = unsafe {
                std::mem::transmute(insert.iter().collect::<Vec<_>>())
            };
            YArrayDeltaOwned::YArrayDeltaInsert(YArrayDeltaInsertOwned {
                insert,
                slice,
            })
        }
        Change::Removed(c) => {
            YArrayDeltaOwned::YArrayDeltaDelete(YArrayDeltaDelete { delete: *c })
        }
        Change::Retain(v) => {
            YArrayDeltaOwned::YArrayDeltaRetain(YArrayDeltaRetain { retain: *v })
        }
    }
}
pub enum YArrayDeltaOwned {
    YArrayDeltaInsert(YArrayDeltaInsertOwned),
    YArrayDeltaDelete(YArrayDeltaDelete),
    YArrayDeltaRetain(YArrayDeltaRetain),
}
pub struct YArrayDeltaInsertOwned {
    insert: Vec<YValue>,
    slice: Vec<&'static YValue>,
}
impl YArrayDeltaOwned {
    fn to_ref(&self) -> YArrayDelta {
        match self {
            YArrayDeltaOwned::YArrayDeltaInsert(v) => {
                YArrayDelta::YArrayDeltaInsert(YArrayDeltaInsert {
                    insert: &v.slice,
                })
            }
            YArrayDeltaOwned::YArrayDeltaDelete(v) => YArrayDelta::YArrayDeltaDelete(*v),
            YArrayDeltaOwned::YArrayDeltaRetain(v) => YArrayDelta::YArrayDeltaRetain(*v),
        }
    }
}
fn map_map_delta(d: &EntryChange) -> YMapDeltaOwned {
    match d {
        EntryChange::Inserted(v) => {
            YMapDeltaOwned {
                action: YMapDeltaAction::Insert,
                old_value: None,
                new_value: Some(map_y_value(v.clone())),
            }
        }
        EntryChange::Removed(c) => {
            YMapDeltaOwned {
                action: YMapDeltaAction::Delete,
                old_value: Some(map_y_value(c.clone())),
                new_value: None,
            }
        }
        EntryChange::Updated(v, v2) => {
            YMapDeltaOwned {
                action: YMapDeltaAction::Update,
                old_value: Some(map_y_value(v.clone())),
                new_value: Some(map_y_value(v2.clone())),
            }
        }
    }
}
fn ytext_change_into_delta(diff: Diff<YChange>) -> YTextDelta {
    YTextDelta::YTextDeltaInsert(YTextDeltaInsert {
        insert: string_from_value(&diff.insert),
        attributes: diff
            .attributes
            .map(|a| {
                map_any_json_value(
                    Any::Map(
                        Box::new(
                            a.into_iter().map(|(k, v)| (k.to_string(), v)).collect(),
                        ),
                    ),
                )
            }),
    })
}
fn string_from_value(v: &Value) -> String {
    match v {
        Value::YText(t) => t.get_string(&t.transact()),
        Value::Any(Any::String(s)) => s.to_string(),
        _ => "".to_string(),
    }
}
fn parse_attrs(attributes: JsonObject) -> HashMap<Arc<str>, Any> {
    match map_json_value_any(attributes) {
        Any::Map(m) => m.into_iter().map(|(k, v)| (k.into(), v)).collect(),
        _ => {
            ::core::panicking::panic_fmt(format_args!("Expected a map"));
        }
    }
}
fn map_y_value(v: Value) -> YValue {
    match v {
        Value::Any(a) => YValue::JsonValueItem(map_any_json_value(a)),
        Value::YText(a) => YValue::YText(with_mut(|state| state.save_text(a))),
        Value::YArray(a) => YValue::YArray(with_mut(|state| state.save_array(a))),
        Value::YMap(a) => YValue::YMap(with_mut(|state| state.save_map(a))),
        Value::YXmlElement(a) => {
            YValue::YXmlElement(with_mut(|state| state.save_xml_element(a)))
        }
        Value::YXmlFragment(a) => {
            YValue::YXmlFragment(with_mut(|state| state.save_xml_fragment(a)))
        }
        Value::YXmlText(a) => YValue::YXmlText(with_mut(|state| state.save_xml_text(a))),
        Value::YDoc(a) => YValue::YDoc(with_mut(|state| state.save_doc(a))),
    }
}
fn map_value(v: YValue) -> Value {
    match v {
        YValue::JsonValueItem(a) => Value::Any(map_json_value_any(a)),
        YValue::YText(a) => Value::YText(with_mut(|state| state.texts[&a.ref_].clone())),
        YValue::YArray(a) => {
            Value::YArray(with_mut(|state| state.arrays[&a.ref_].clone()))
        }
        YValue::YMap(a) => Value::YMap(with_mut(|state| state.maps[&a.ref_].clone())),
        YValue::YXmlElement(a) => {
            Value::YXmlElement(with_mut(|state| state.xml_elements[&a.ref_].clone()))
        }
        YValue::YXmlFragment(a) => {
            Value::YXmlFragment(with_mut(|state| state.xml_fragments[&a.ref_].clone()))
        }
        YValue::YXmlText(a) => {
            Value::YXmlText(with_mut(|state| state.xml_texts[&a.ref_].clone()))
        }
        YValue::YDoc(a) => Value::YDoc(with_mut(|state| state.docs[&a.ref_].clone())),
    }
}
fn map_json_value_any(v: JsonValueItem) -> Any {
    map_json_value_any_v(&v.item, &v)
}
fn map_json_value_any_v(item: &JsonValue, references: &JsonValueItem) -> Any {
    let map_ref = |a: &JsonValue| -> Any { map_json_value_any_v(a, references) };
    match item {
        JsonValue::Str(s) => Any::String(s.clone().into()),
        JsonValue::Number(n) => Any::Number(*n),
        JsonValue::Undefined => Any::Undefined,
        JsonValue::BigInt(n) => Any::BigInt(*n),
        JsonValue::Boolean(b) => Any::Bool(*b),
        JsonValue::Null => Any::Null,
        JsonValue::Buffer(v) => Any::Buffer(v.clone().into()),
        JsonValue::Array(a) => {
            Any::Array(
                references
                    .array_references[a.index as usize]
                    .iter()
                    .map(map_ref)
                    .collect(),
            )
        }
        JsonValue::Map(o) => {
            Any::Map(
                Box::new(
                    HashMap::from_iter(
                        references
                            .map_references[o.index as usize]
                            .iter()
                            .map(|(k, v)| (k.clone(), map_ref(&v))),
                    ),
                ),
            )
        }
    }
}
fn map_any_json_value(v: Any) -> JsonValueItem {
    let mut references = JsonValueItem {
        item: JsonValue::Undefined,
        map_references: ::alloc::vec::Vec::new(),
        array_references: ::alloc::vec::Vec::new(),
    };
    let item = map_any_json_value_ref(v, &mut references);
    references.item = item;
    references
}
fn map_any_json_value_ref(v: Any, references: &mut JsonValueItem) -> JsonValue {
    match v {
        Any::String(s) => JsonValue::Str(s.to_string()),
        Any::Number(n) => JsonValue::Number(n),
        Any::Undefined => JsonValue::Undefined,
        Any::BigInt(n) => JsonValue::BigInt(n),
        Any::Bool(b) => JsonValue::Boolean(b),
        Any::Null => JsonValue::Null,
        Any::Buffer(v) => JsonValue::Buffer(v.to_vec()),
        Any::Array(a) => {
            let m = Vec::from(a)
                .into_iter()
                .map(|v| map_any_json_value_ref(v, references))
                .collect();
            let index = references.array_references.len() as u32;
            references.array_references.push(m);
            JsonValue::Array(JsonArrayRef { index })
        }
        Any::Map(o) => {
            let m = o
                .into_iter()
                .map(|(k, v)| (k, map_any_json_value_ref(v, references)))
                .collect();
            let index = references.map_references.len() as u32;
            references.map_references.push(m);
            JsonValue::Map(JsonMapRef { index })
        }
    }
}
fn insert_at(dst: &ArrayRef, txn: &mut TransactionMut, index: u32, src: Box<[Any]>) {
    dst.insert_range(txn, index, src.into_vec());
}
fn diff_v1<T: ReadTxn>(txn: &T, vector: Option<Vec<u8>>) -> Result<Vec<u8>, String> {
    let mut encoder = EncoderV1::new();
    let sv = if let Some(vector) = vector {
        match StateVector::decode_v1(vector.to_vec().as_slice()) {
            Ok(sv) => sv,
            Err(e) => {
                return Err(e.to_string());
            }
        }
    } else {
        StateVector::default()
    };
    txn.encode_diff(&sv, &mut encoder);
    Ok(encoder.to_vec())
}
fn diff_v2<T: ReadTxn>(txn: &T, vector: Option<Vec<u8>>) -> Result<Vec<u8>, String> {
    let mut encoder = EncoderV2::new();
    let sv = if let Some(vector) = vector {
        match StateVector::decode_v1(vector.to_vec().as_slice()) {
            Ok(sv) => sv,
            Err(e) => {
                return Err(e.to_string());
            }
        }
    } else {
        StateVector::default()
    };
    txn.encode_diff(&sv, &mut encoder);
    Ok(encoder.to_vec())
}
fn map_event<'a>(
    state: &mut GlobalState,
    e_txn: &'a TransactionMut<'_>,
    e: &Event,
) -> YEvent<'a> {
    match e {
        Event::Text(e) => {
            let text = state.save_text(e.target().clone());
            map_text_event(text, e_txn, e)
        }
        Event::Map(e) => {
            let map = state.save_map(e.target().clone());
            map_map_event(map, e_txn, e)
        }
        Event::Array(e) => {
            let array = state.save_array(e.target().clone());
            map_array_event(array, e_txn, e)
        }
        _ => ::core::panicking::panic("not implemented"),
    }
}
fn map_text_event<'a>(
    text: YText,
    e_txn: &'a TransactionMut<'_>,
    e: &TextEvent,
) -> YEvent<'a> {
    let p = e.path();
    let path = p
        .iter()
        .map(|v| match v {
            PathSegment::Index(i) => EventPathItem::U32(*i),
            PathSegment::Key(k) => EventPathItem::String(k),
        })
        .collect::<Vec<EventPathItem>>();
    YEvent::YTextEvent(unsafe {
        std::mem::transmute(YTextEvent {
            path: &path,
            delta: e
                .delta(e_txn)
                .iter()
                .map(map_text_delta)
                .collect::<Vec<_>>()
                .iter()
                .collect::<Vec<_>>()
                .as_slice(),
            target: text,
        })
    })
}
fn map_path_segment<'a>(p: &VecDeque<PathSegment>) -> Vec<EventPathItem> {
    p.iter()
        .map(|v| match v {
            PathSegment::Index(i) => EventPathItem::U32(*i),
            PathSegment::Key(k) => EventPathItem::String(k),
        })
        .collect::<Vec<EventPathItem>>()
}
fn map_array_event<'a>(
    array: YArray,
    e_txn: &'a TransactionMut<'_>,
    e: &ArrayEvent,
) -> YEvent<'a> {
    let p = e.path();
    let path = map_path_segment(&p);
    YEvent::YArrayEvent(unsafe {
        std::mem::transmute(YArrayEvent {
            path: &path,
            delta: e
                .delta(e_txn)
                .iter()
                .map(map_array_delta)
                .collect::<Vec<_>>()
                .iter()
                .map(|a| a.to_ref())
                .collect::<Vec<_>>()
                .as_slice(),
            target: array,
        })
    })
}
struct YMapDeltaOwned {
    pub action: YMapDeltaAction,
    pub old_value: Option<YValue>,
    pub new_value: Option<YValue>,
}
impl YMapDeltaOwned {
    fn to_ref(&self) -> YMapDelta {
        YMapDelta {
            action: self.action,
            old_value: self.old_value.as_ref(),
            new_value: self.new_value.as_ref(),
        }
    }
}
fn map_map_event<'a>(
    map: YMap,
    e_txn: &'a TransactionMut<'_>,
    e: &MapEvent,
) -> YEvent<'a> {
    let p = e.path();
    let path = map_path_segment(&p);
    YEvent::YMapEvent(unsafe {
        std::mem::transmute(YMapEvent {
            path: &path,
            keys: e
                .keys(e_txn)
                .iter()
                .map(|(k, v)| (k.as_ref(), map_map_delta(v)))
                .collect::<Vec<_>>()
                .iter()
                .map(|(k, v)| (*k, v.to_ref()))
                .collect::<Vec<_>>()
                .as_slice(),
            target: map,
        })
    })
}
