#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub type YEvent = y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent;
pub type YUndoEvent = y_crdt_namespace::y_crdt::y_doc_methods_types::YUndoEvent;
#[allow(clippy::all)]
pub fn event_callback(function_id: u32, event: &YEvent) {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    unsafe {
        let mut cleanup_list = Vec::new();
        let (
            result157_0,
            result157_1,
            result157_2,
            result157_3,
            result157_4,
            result157_5,
        ) = match event {
            y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YArrayEvent(e) => {
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayEvent {
                    target: target0,
                    delta: delta0,
                    path: path0,
                } = e;
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                    ref_: ref_1,
                } = target0;
                let vec35 = delta0;
                let len35 = vec35.len() as i32;
                let layout35 = alloc::Layout::from_size_align_unchecked(
                    vec35.len() * 12,
                    4,
                );
                let result35 = if layout35.size() != 0 {
                    let ptr = alloc::alloc(layout35);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout35);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec35.into_iter().enumerate() {
                    let base = result35 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaInsert(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaInsert {
                                    insert: insert2,
                                } = e;
                                let vec32 = insert2;
                                let len32 = vec32.len() as i32;
                                let layout32 = alloc::Layout::from_size_align_unchecked(
                                    vec32.len() * 40,
                                    8,
                                );
                                let result32 = if layout32.size() != 0 {
                                    let ptr = alloc::alloc(layout32);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout32);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec32.into_iter().enumerate() {
                                    let base = result32 as i32 + (i as i32) * 40;
                                    {
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item3,
                                                    array_references: array_references3,
                                                    map_references: map_references3,
                                                } = e;
                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V8;
                                                match item3 {
                                                    V8::Null => {
                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V8::Undefined => {
                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V8::Boolean(e) => {
                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                        *((base + 16)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V8::Number(e) => {
                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V8::BigInt(e) => {
                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V8::Str(e) => {
                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                        let vec4 = e;
                                                        let ptr4 = vec4.as_ptr() as i32;
                                                        let len4 = vec4.len() as i32;
                                                        *((base + 20) as *mut i32) = len4;
                                                        *((base + 16) as *mut i32) = ptr4;
                                                    }
                                                    V8::Buffer(e) => {
                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                        let vec5 = e;
                                                        let ptr5 = vec5.as_ptr() as i32;
                                                        let len5 = vec5.len() as i32;
                                                        *((base + 20) as *mut i32) = len5;
                                                        *((base + 16) as *mut i32) = ptr5;
                                                    }
                                                    V8::Array(e) => {
                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index6,
                                                        } = e;
                                                        *((base + 16)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                                    }
                                                    V8::Map(e) => {
                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index7,
                                                        } = e;
                                                        *((base + 16)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                                    }
                                                }
                                                let vec15 = array_references3;
                                                let len15 = vec15.len() as i32;
                                                let layout15 = alloc::Layout::from_size_align_unchecked(
                                                    vec15.len() * 8,
                                                    4,
                                                );
                                                let result15 = if layout15.size() != 0 {
                                                    let ptr = alloc::alloc(layout15);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout15);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec15.into_iter().enumerate() {
                                                    let base = result15 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec14 = e;
                                                        let len14 = vec14.len() as i32;
                                                        let layout14 = alloc::Layout::from_size_align_unchecked(
                                                            vec14.len() * 16,
                                                            8,
                                                        );
                                                        let result14 = if layout14.size() != 0 {
                                                            let ptr = alloc::alloc(layout14);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout14);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec14.into_iter().enumerate() {
                                                            let base = result14 as i32 + (i as i32) * 16;
                                                            {
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V13;
                                                                match e {
                                                                    V13::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V13::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V13::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V13::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V13::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V13::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec9 = e;
                                                                        let ptr9 = vec9.as_ptr() as i32;
                                                                        let len9 = vec9.len() as i32;
                                                                        *((base + 12) as *mut i32) = len9;
                                                                        *((base + 8) as *mut i32) = ptr9;
                                                                    }
                                                                    V13::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec10 = e;
                                                                        let ptr10 = vec10.as_ptr() as i32;
                                                                        let len10 = vec10.len() as i32;
                                                                        *((base + 12) as *mut i32) = len10;
                                                                        *((base + 8) as *mut i32) = ptr10;
                                                                    }
                                                                    V13::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index11,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                                    }
                                                                    V13::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index12,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len14;
                                                        *((base + 0) as *mut i32) = result14 as i32;
                                                        cleanup_list.extend_from_slice(&[(result14, layout14)]);
                                                    }
                                                }
                                                *((base + 28) as *mut i32) = len15;
                                                *((base + 24) as *mut i32) = result15 as i32;
                                                let vec24 = map_references3;
                                                let len24 = vec24.len() as i32;
                                                let layout24 = alloc::Layout::from_size_align_unchecked(
                                                    vec24.len() * 8,
                                                    4,
                                                );
                                                let result24 = if layout24.size() != 0 {
                                                    let ptr = alloc::alloc(layout24);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout24);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec24.into_iter().enumerate() {
                                                    let base = result24 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec23 = e;
                                                        let len23 = vec23.len() as i32;
                                                        let layout23 = alloc::Layout::from_size_align_unchecked(
                                                            vec23.len() * 24,
                                                            8,
                                                        );
                                                        let result23 = if layout23.size() != 0 {
                                                            let ptr = alloc::alloc(layout23);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout23);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec23.into_iter().enumerate() {
                                                            let base = result23 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t16_0, t16_1) = e;
                                                                let vec17 = t16_0;
                                                                let ptr17 = vec17.as_ptr() as i32;
                                                                let len17 = vec17.len() as i32;
                                                                *((base + 4) as *mut i32) = len17;
                                                                *((base + 0) as *mut i32) = ptr17;
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V22;
                                                                match t16_1 {
                                                                    V22::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V22::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V22::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V22::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V22::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V22::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec18 = e;
                                                                        let ptr18 = vec18.as_ptr() as i32;
                                                                        let len18 = vec18.len() as i32;
                                                                        *((base + 20) as *mut i32) = len18;
                                                                        *((base + 16) as *mut i32) = ptr18;
                                                                    }
                                                                    V22::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec19 = e;
                                                                        let ptr19 = vec19.as_ptr() as i32;
                                                                        let len19 = vec19.len() as i32;
                                                                        *((base + 20) as *mut i32) = len19;
                                                                        *((base + 16) as *mut i32) = ptr19;
                                                                    }
                                                                    V22::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index20,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                                                    }
                                                                    V22::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index21,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len23;
                                                        *((base + 0) as *mut i32) = result23 as i32;
                                                        cleanup_list.extend_from_slice(&[(result23, layout23)]);
                                                    }
                                                }
                                                *((base + 36) as *mut i32) = len24;
                                                *((base + 32) as *mut i32) = result24 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result15, layout15), (result24, layout24)],
                                                    );
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                    ref_: ref_25,
                                                } = e;
                                                *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                                e,
                                            ) => {
                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                match e {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                            ref_: ref_26,
                                                        } = e;
                                                        *((base + 12)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                            ref_: ref_27,
                                                        } = e;
                                                        *((base + 12)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                            ref_: ref_28,
                                                        } = e;
                                                        *((base + 12)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                            ref_: ref_29,
                                                        } = e;
                                                        *((base + 12)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                            ref_: ref_30,
                                                        } = e;
                                                        *((base + 12)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_30);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                        e,
                                                    ) => {
                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                            ref_: ref_31,
                                                        } = e;
                                                        *((base + 12)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_31);
                                                    }
                                                };
                                            }
                                        };
                                    }
                                }
                                *((base + 8) as *mut i32) = len32;
                                *((base + 4) as *mut i32) = result32 as i32;
                                cleanup_list.extend_from_slice(&[(result32, layout32)]);
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaDelete(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaDelete {
                                    delete: delete33,
                                } = e;
                                *((base + 4)
                                    as *mut i32) = wit_bindgen::rt::as_i32(delete33);
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaRetain(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (2i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaRetain {
                                    retain: retain34,
                                } = e;
                                *((base + 4)
                                    as *mut i32) = wit_bindgen::rt::as_i32(retain34);
                            }
                        };
                    }
                }
                let vec37 = path0;
                let len37 = vec37.len() as i32;
                let layout37 = alloc::Layout::from_size_align_unchecked(
                    vec37.len() * 12,
                    4,
                );
                let result37 = if layout37.size() != 0 {
                    let ptr = alloc::alloc(layout37);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout37);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec37.into_iter().enumerate() {
                    let base = result37 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let vec36 = e;
                                let ptr36 = vec36.as_ptr() as i32;
                                let len36 = vec36.len() as i32;
                                *((base + 8) as *mut i32) = len36;
                                *((base + 4) as *mut i32) = ptr36;
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            }
                        };
                    }
                }
                cleanup_list
                    .extend_from_slice(&[(result35, layout35), (result37, layout37)]);
                (
                    0i32,
                    wit_bindgen::rt::as_i32(ref_1),
                    result35 as i32,
                    len35,
                    result37 as i32,
                    len37,
                )
            }
            y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YMapEvent(e) => {
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapEvent {
                    target: target38,
                    keys: keys38,
                    path: path38,
                } = e;
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                    ref_: ref_39,
                } = target38;
                let vec101 = keys38;
                let len101 = vec101.len() as i32;
                let layout101 = alloc::Layout::from_size_align_unchecked(
                    vec101.len() * 112,
                    8,
                );
                let result101 = if layout101.size() != 0 {
                    let ptr = alloc::alloc(layout101);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout101);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec101.into_iter().enumerate() {
                    let base = result101 as i32 + (i as i32) * 112;
                    {
                        let (t40_0, t40_1) = e;
                        let vec41 = t40_0;
                        let ptr41 = vec41.as_ptr() as i32;
                        let len41 = vec41.len() as i32;
                        *((base + 4) as *mut i32) = len41;
                        *((base + 0) as *mut i32) = ptr41;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDelta {
                            action: action42,
                            old_value: old_value42,
                            new_value: new_value42,
                        } = t40_1;
                        *((base + 8) as *mut u8) = (action42.clone() as i32) as u8;
                        match old_value42 {
                            Some(e) => {
                                *((base + 16) as *mut u8) = (1i32) as u8;
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item43,
                                            array_references: array_references43,
                                            map_references: map_references43,
                                        } = e;
                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V48;
                                        match item43 {
                                            V48::Null => {
                                                *((base + 32) as *mut u8) = (0i32) as u8;
                                            }
                                            V48::Undefined => {
                                                *((base + 32) as *mut u8) = (1i32) as u8;
                                            }
                                            V48::Boolean(e) => {
                                                *((base + 32) as *mut u8) = (2i32) as u8;
                                                *((base + 40)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V48::Number(e) => {
                                                *((base + 32) as *mut u8) = (3i32) as u8;
                                                *((base + 40) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V48::BigInt(e) => {
                                                *((base + 32) as *mut u8) = (4i32) as u8;
                                                *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V48::Str(e) => {
                                                *((base + 32) as *mut u8) = (5i32) as u8;
                                                let vec44 = e;
                                                let ptr44 = vec44.as_ptr() as i32;
                                                let len44 = vec44.len() as i32;
                                                *((base + 44) as *mut i32) = len44;
                                                *((base + 40) as *mut i32) = ptr44;
                                            }
                                            V48::Buffer(e) => {
                                                *((base + 32) as *mut u8) = (6i32) as u8;
                                                let vec45 = e;
                                                let ptr45 = vec45.as_ptr() as i32;
                                                let len45 = vec45.len() as i32;
                                                *((base + 44) as *mut i32) = len45;
                                                *((base + 40) as *mut i32) = ptr45;
                                            }
                                            V48::Array(e) => {
                                                *((base + 32) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index46,
                                                } = e;
                                                *((base + 40)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index46);
                                            }
                                            V48::Map(e) => {
                                                *((base + 32) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index47,
                                                } = e;
                                                *((base + 40)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index47);
                                            }
                                        }
                                        let vec55 = array_references43;
                                        let len55 = vec55.len() as i32;
                                        let layout55 = alloc::Layout::from_size_align_unchecked(
                                            vec55.len() * 8,
                                            4,
                                        );
                                        let result55 = if layout55.size() != 0 {
                                            let ptr = alloc::alloc(layout55);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout55);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec55.into_iter().enumerate() {
                                            let base = result55 as i32 + (i as i32) * 8;
                                            {
                                                let vec54 = e;
                                                let len54 = vec54.len() as i32;
                                                let layout54 = alloc::Layout::from_size_align_unchecked(
                                                    vec54.len() * 16,
                                                    8,
                                                );
                                                let result54 = if layout54.size() != 0 {
                                                    let ptr = alloc::alloc(layout54);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout54);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec54.into_iter().enumerate() {
                                                    let base = result54 as i32 + (i as i32) * 16;
                                                    {
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V53;
                                                        match e {
                                                            V53::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V53::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V53::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V53::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V53::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V53::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec49 = e;
                                                                let ptr49 = vec49.as_ptr() as i32;
                                                                let len49 = vec49.len() as i32;
                                                                *((base + 12) as *mut i32) = len49;
                                                                *((base + 8) as *mut i32) = ptr49;
                                                            }
                                                            V53::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec50 = e;
                                                                let ptr50 = vec50.as_ptr() as i32;
                                                                let len50 = vec50.len() as i32;
                                                                *((base + 12) as *mut i32) = len50;
                                                                *((base + 8) as *mut i32) = ptr50;
                                                            }
                                                            V53::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index51,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index51);
                                                            }
                                                            V53::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index52,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index52);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len54;
                                                *((base + 0) as *mut i32) = result54 as i32;
                                                cleanup_list.extend_from_slice(&[(result54, layout54)]);
                                            }
                                        }
                                        *((base + 52) as *mut i32) = len55;
                                        *((base + 48) as *mut i32) = result55 as i32;
                                        let vec64 = map_references43;
                                        let len64 = vec64.len() as i32;
                                        let layout64 = alloc::Layout::from_size_align_unchecked(
                                            vec64.len() * 8,
                                            4,
                                        );
                                        let result64 = if layout64.size() != 0 {
                                            let ptr = alloc::alloc(layout64);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout64);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec64.into_iter().enumerate() {
                                            let base = result64 as i32 + (i as i32) * 8;
                                            {
                                                let vec63 = e;
                                                let len63 = vec63.len() as i32;
                                                let layout63 = alloc::Layout::from_size_align_unchecked(
                                                    vec63.len() * 24,
                                                    8,
                                                );
                                                let result63 = if layout63.size() != 0 {
                                                    let ptr = alloc::alloc(layout63);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout63);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec63.into_iter().enumerate() {
                                                    let base = result63 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t56_0, t56_1) = e;
                                                        let vec57 = t56_0;
                                                        let ptr57 = vec57.as_ptr() as i32;
                                                        let len57 = vec57.len() as i32;
                                                        *((base + 4) as *mut i32) = len57;
                                                        *((base + 0) as *mut i32) = ptr57;
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V62;
                                                        match t56_1 {
                                                            V62::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V62::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V62::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V62::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V62::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V62::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec58 = e;
                                                                let ptr58 = vec58.as_ptr() as i32;
                                                                let len58 = vec58.len() as i32;
                                                                *((base + 20) as *mut i32) = len58;
                                                                *((base + 16) as *mut i32) = ptr58;
                                                            }
                                                            V62::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec59 = e;
                                                                let ptr59 = vec59.as_ptr() as i32;
                                                                let len59 = vec59.len() as i32;
                                                                *((base + 20) as *mut i32) = len59;
                                                                *((base + 16) as *mut i32) = ptr59;
                                                            }
                                                            V62::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index60,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index60);
                                                            }
                                                            V62::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index61,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index61);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len63;
                                                *((base + 0) as *mut i32) = result63 as i32;
                                                cleanup_list.extend_from_slice(&[(result63, layout63)]);
                                            }
                                        }
                                        *((base + 60) as *mut i32) = len64;
                                        *((base + 56) as *mut i32) = result64 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result55, layout55), (result64, layout64)],
                                            );
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_65,
                                        } = e;
                                        *((base + 32)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_65);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                        e,
                                    ) => {
                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_66,
                                                } = e;
                                                *((base + 36)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_66);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_67,
                                                } = e;
                                                *((base + 36)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_67);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (2i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_68,
                                                } = e;
                                                *((base + 36)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_68);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (3i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_69,
                                                } = e;
                                                *((base + 36)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_69);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (4i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_70,
                                                } = e;
                                                *((base + 36)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_70);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 32) as *mut u8) = (5i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_71,
                                                } = e;
                                                *((base + 36)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_71);
                                            }
                                        };
                                    }
                                };
                            }
                            None => {
                                *((base + 16) as *mut u8) = (0i32) as u8;
                            }
                        };
                        match new_value42 {
                            Some(e) => {
                                *((base + 64) as *mut u8) = (1i32) as u8;
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item72,
                                            array_references: array_references72,
                                            map_references: map_references72,
                                        } = e;
                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V77;
                                        match item72 {
                                            V77::Null => {
                                                *((base + 80) as *mut u8) = (0i32) as u8;
                                            }
                                            V77::Undefined => {
                                                *((base + 80) as *mut u8) = (1i32) as u8;
                                            }
                                            V77::Boolean(e) => {
                                                *((base + 80) as *mut u8) = (2i32) as u8;
                                                *((base + 88)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V77::Number(e) => {
                                                *((base + 80) as *mut u8) = (3i32) as u8;
                                                *((base + 88) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V77::BigInt(e) => {
                                                *((base + 80) as *mut u8) = (4i32) as u8;
                                                *((base + 88) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V77::Str(e) => {
                                                *((base + 80) as *mut u8) = (5i32) as u8;
                                                let vec73 = e;
                                                let ptr73 = vec73.as_ptr() as i32;
                                                let len73 = vec73.len() as i32;
                                                *((base + 92) as *mut i32) = len73;
                                                *((base + 88) as *mut i32) = ptr73;
                                            }
                                            V77::Buffer(e) => {
                                                *((base + 80) as *mut u8) = (6i32) as u8;
                                                let vec74 = e;
                                                let ptr74 = vec74.as_ptr() as i32;
                                                let len74 = vec74.len() as i32;
                                                *((base + 92) as *mut i32) = len74;
                                                *((base + 88) as *mut i32) = ptr74;
                                            }
                                            V77::Array(e) => {
                                                *((base + 80) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index75,
                                                } = e;
                                                *((base + 88)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index75);
                                            }
                                            V77::Map(e) => {
                                                *((base + 80) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index76,
                                                } = e;
                                                *((base + 88)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index76);
                                            }
                                        }
                                        let vec84 = array_references72;
                                        let len84 = vec84.len() as i32;
                                        let layout84 = alloc::Layout::from_size_align_unchecked(
                                            vec84.len() * 8,
                                            4,
                                        );
                                        let result84 = if layout84.size() != 0 {
                                            let ptr = alloc::alloc(layout84);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout84);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec84.into_iter().enumerate() {
                                            let base = result84 as i32 + (i as i32) * 8;
                                            {
                                                let vec83 = e;
                                                let len83 = vec83.len() as i32;
                                                let layout83 = alloc::Layout::from_size_align_unchecked(
                                                    vec83.len() * 16,
                                                    8,
                                                );
                                                let result83 = if layout83.size() != 0 {
                                                    let ptr = alloc::alloc(layout83);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout83);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec83.into_iter().enumerate() {
                                                    let base = result83 as i32 + (i as i32) * 16;
                                                    {
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V82;
                                                        match e {
                                                            V82::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V82::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V82::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V82::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V82::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V82::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec78 = e;
                                                                let ptr78 = vec78.as_ptr() as i32;
                                                                let len78 = vec78.len() as i32;
                                                                *((base + 12) as *mut i32) = len78;
                                                                *((base + 8) as *mut i32) = ptr78;
                                                            }
                                                            V82::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec79 = e;
                                                                let ptr79 = vec79.as_ptr() as i32;
                                                                let len79 = vec79.len() as i32;
                                                                *((base + 12) as *mut i32) = len79;
                                                                *((base + 8) as *mut i32) = ptr79;
                                                            }
                                                            V82::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index80,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index80);
                                                            }
                                                            V82::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index81,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index81);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len83;
                                                *((base + 0) as *mut i32) = result83 as i32;
                                                cleanup_list.extend_from_slice(&[(result83, layout83)]);
                                            }
                                        }
                                        *((base + 100) as *mut i32) = len84;
                                        *((base + 96) as *mut i32) = result84 as i32;
                                        let vec93 = map_references72;
                                        let len93 = vec93.len() as i32;
                                        let layout93 = alloc::Layout::from_size_align_unchecked(
                                            vec93.len() * 8,
                                            4,
                                        );
                                        let result93 = if layout93.size() != 0 {
                                            let ptr = alloc::alloc(layout93);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout93);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec93.into_iter().enumerate() {
                                            let base = result93 as i32 + (i as i32) * 8;
                                            {
                                                let vec92 = e;
                                                let len92 = vec92.len() as i32;
                                                let layout92 = alloc::Layout::from_size_align_unchecked(
                                                    vec92.len() * 24,
                                                    8,
                                                );
                                                let result92 = if layout92.size() != 0 {
                                                    let ptr = alloc::alloc(layout92);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout92);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec92.into_iter().enumerate() {
                                                    let base = result92 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t85_0, t85_1) = e;
                                                        let vec86 = t85_0;
                                                        let ptr86 = vec86.as_ptr() as i32;
                                                        let len86 = vec86.len() as i32;
                                                        *((base + 4) as *mut i32) = len86;
                                                        *((base + 0) as *mut i32) = ptr86;
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V91;
                                                        match t85_1 {
                                                            V91::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V91::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V91::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V91::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V91::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V91::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec87 = e;
                                                                let ptr87 = vec87.as_ptr() as i32;
                                                                let len87 = vec87.len() as i32;
                                                                *((base + 20) as *mut i32) = len87;
                                                                *((base + 16) as *mut i32) = ptr87;
                                                            }
                                                            V91::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec88 = e;
                                                                let ptr88 = vec88.as_ptr() as i32;
                                                                let len88 = vec88.len() as i32;
                                                                *((base + 20) as *mut i32) = len88;
                                                                *((base + 16) as *mut i32) = ptr88;
                                                            }
                                                            V91::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index89,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index89);
                                                            }
                                                            V91::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index90,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index90);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len92;
                                                *((base + 0) as *mut i32) = result92 as i32;
                                                cleanup_list.extend_from_slice(&[(result92, layout92)]);
                                            }
                                        }
                                        *((base + 108) as *mut i32) = len93;
                                        *((base + 104) as *mut i32) = result93 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result84, layout84), (result93, layout93)],
                                            );
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_94,
                                        } = e;
                                        *((base + 80)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_94);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                        e,
                                    ) => {
                                        *((base + 72) as *mut u8) = (2i32) as u8;
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_95,
                                                } = e;
                                                *((base + 84)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_95);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_96,
                                                } = e;
                                                *((base + 84)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_96);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (2i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_97,
                                                } = e;
                                                *((base + 84)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_97);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (3i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_98,
                                                } = e;
                                                *((base + 84)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_98);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (4i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_99,
                                                } = e;
                                                *((base + 84)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_99);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 80) as *mut u8) = (5i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_100,
                                                } = e;
                                                *((base + 84)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_100);
                                            }
                                        };
                                    }
                                };
                            }
                            None => {
                                *((base + 64) as *mut u8) = (0i32) as u8;
                            }
                        };
                    }
                }
                let vec103 = path38;
                let len103 = vec103.len() as i32;
                let layout103 = alloc::Layout::from_size_align_unchecked(
                    vec103.len() * 12,
                    4,
                );
                let result103 = if layout103.size() != 0 {
                    let ptr = alloc::alloc(layout103);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout103);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec103.into_iter().enumerate() {
                    let base = result103 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let vec102 = e;
                                let ptr102 = vec102.as_ptr() as i32;
                                let len102 = vec102.len() as i32;
                                *((base + 8) as *mut i32) = len102;
                                *((base + 4) as *mut i32) = ptr102;
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            }
                        };
                    }
                }
                cleanup_list
                    .extend_from_slice(
                        &[(result101, layout101), (result103, layout103)],
                    );
                (
                    1i32,
                    wit_bindgen::rt::as_i32(ref_39),
                    result101 as i32,
                    len101,
                    result103 as i32,
                    len103,
                )
            }
            y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YTextEvent(e) => {
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextEvent {
                    target: target104,
                    delta: delta104,
                    path: path104,
                } = e;
                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                    ref_: ref_105,
                } = target104;
                let vec154 = delta104;
                let len154 = vec154.len() as i32;
                let layout154 = alloc::Layout::from_size_align_unchecked(
                    vec154.len() * 56,
                    8,
                );
                let result154 = if layout154.size() != 0 {
                    let ptr = alloc::alloc(layout154);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout154);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec154.into_iter().enumerate() {
                    let base = result154 as i32 + (i as i32) * 56;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaInsert(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaInsert {
                                    insert: insert106,
                                    attributes: attributes106,
                                } = e;
                                let vec107 = insert106;
                                let ptr107 = vec107.as_ptr() as i32;
                                let len107 = vec107.len() as i32;
                                *((base + 12) as *mut i32) = len107;
                                *((base + 8) as *mut i32) = ptr107;
                                match attributes106 {
                                    Some(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item108,
                                            array_references: array_references108,
                                            map_references: map_references108,
                                        } = e;
                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V113;
                                        match item108 {
                                            V113::Null => {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                            }
                                            V113::Undefined => {
                                                *((base + 24) as *mut u8) = (1i32) as u8;
                                            }
                                            V113::Boolean(e) => {
                                                *((base + 24) as *mut u8) = (2i32) as u8;
                                                *((base + 32)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V113::Number(e) => {
                                                *((base + 24) as *mut u8) = (3i32) as u8;
                                                *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V113::BigInt(e) => {
                                                *((base + 24) as *mut u8) = (4i32) as u8;
                                                *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V113::Str(e) => {
                                                *((base + 24) as *mut u8) = (5i32) as u8;
                                                let vec109 = e;
                                                let ptr109 = vec109.as_ptr() as i32;
                                                let len109 = vec109.len() as i32;
                                                *((base + 36) as *mut i32) = len109;
                                                *((base + 32) as *mut i32) = ptr109;
                                            }
                                            V113::Buffer(e) => {
                                                *((base + 24) as *mut u8) = (6i32) as u8;
                                                let vec110 = e;
                                                let ptr110 = vec110.as_ptr() as i32;
                                                let len110 = vec110.len() as i32;
                                                *((base + 36) as *mut i32) = len110;
                                                *((base + 32) as *mut i32) = ptr110;
                                            }
                                            V113::Array(e) => {
                                                *((base + 24) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index111,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index111);
                                            }
                                            V113::Map(e) => {
                                                *((base + 24) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index112,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index112);
                                            }
                                        }
                                        let vec120 = array_references108;
                                        let len120 = vec120.len() as i32;
                                        let layout120 = alloc::Layout::from_size_align_unchecked(
                                            vec120.len() * 8,
                                            4,
                                        );
                                        let result120 = if layout120.size() != 0 {
                                            let ptr = alloc::alloc(layout120);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout120);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec120.into_iter().enumerate() {
                                            let base = result120 as i32 + (i as i32) * 8;
                                            {
                                                let vec119 = e;
                                                let len119 = vec119.len() as i32;
                                                let layout119 = alloc::Layout::from_size_align_unchecked(
                                                    vec119.len() * 16,
                                                    8,
                                                );
                                                let result119 = if layout119.size() != 0 {
                                                    let ptr = alloc::alloc(layout119);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout119);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec119.into_iter().enumerate() {
                                                    let base = result119 as i32 + (i as i32) * 16;
                                                    {
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V118;
                                                        match e {
                                                            V118::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V118::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V118::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V118::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V118::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V118::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec114 = e;
                                                                let ptr114 = vec114.as_ptr() as i32;
                                                                let len114 = vec114.len() as i32;
                                                                *((base + 12) as *mut i32) = len114;
                                                                *((base + 8) as *mut i32) = ptr114;
                                                            }
                                                            V118::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec115 = e;
                                                                let ptr115 = vec115.as_ptr() as i32;
                                                                let len115 = vec115.len() as i32;
                                                                *((base + 12) as *mut i32) = len115;
                                                                *((base + 8) as *mut i32) = ptr115;
                                                            }
                                                            V118::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index116,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index116);
                                                            }
                                                            V118::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index117,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index117);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len119;
                                                *((base + 0) as *mut i32) = result119 as i32;
                                                cleanup_list.extend_from_slice(&[(result119, layout119)]);
                                            }
                                        }
                                        *((base + 44) as *mut i32) = len120;
                                        *((base + 40) as *mut i32) = result120 as i32;
                                        let vec129 = map_references108;
                                        let len129 = vec129.len() as i32;
                                        let layout129 = alloc::Layout::from_size_align_unchecked(
                                            vec129.len() * 8,
                                            4,
                                        );
                                        let result129 = if layout129.size() != 0 {
                                            let ptr = alloc::alloc(layout129);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout129);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec129.into_iter().enumerate() {
                                            let base = result129 as i32 + (i as i32) * 8;
                                            {
                                                let vec128 = e;
                                                let len128 = vec128.len() as i32;
                                                let layout128 = alloc::Layout::from_size_align_unchecked(
                                                    vec128.len() * 24,
                                                    8,
                                                );
                                                let result128 = if layout128.size() != 0 {
                                                    let ptr = alloc::alloc(layout128);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout128);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec128.into_iter().enumerate() {
                                                    let base = result128 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t121_0, t121_1) = e;
                                                        let vec122 = t121_0;
                                                        let ptr122 = vec122.as_ptr() as i32;
                                                        let len122 = vec122.len() as i32;
                                                        *((base + 4) as *mut i32) = len122;
                                                        *((base + 0) as *mut i32) = ptr122;
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V127;
                                                        match t121_1 {
                                                            V127::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V127::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V127::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V127::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V127::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V127::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec123 = e;
                                                                let ptr123 = vec123.as_ptr() as i32;
                                                                let len123 = vec123.len() as i32;
                                                                *((base + 20) as *mut i32) = len123;
                                                                *((base + 16) as *mut i32) = ptr123;
                                                            }
                                                            V127::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec124 = e;
                                                                let ptr124 = vec124.as_ptr() as i32;
                                                                let len124 = vec124.len() as i32;
                                                                *((base + 20) as *mut i32) = len124;
                                                                *((base + 16) as *mut i32) = ptr124;
                                                            }
                                                            V127::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index125,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index125);
                                                            }
                                                            V127::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index126,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index126);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len128;
                                                *((base + 0) as *mut i32) = result128 as i32;
                                                cleanup_list.extend_from_slice(&[(result128, layout128)]);
                                            }
                                        }
                                        *((base + 52) as *mut i32) = len129;
                                        *((base + 48) as *mut i32) = result129 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result120, layout120), (result129, layout129)],
                                            );
                                    }
                                    None => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                    }
                                };
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaDelete(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaDelete {
                                    delete: delete130,
                                } = e;
                                *((base + 8)
                                    as *mut i32) = wit_bindgen::rt::as_i32(delete130);
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaRetain(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (2i32) as u8;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaRetain {
                                    retain: retain131,
                                    attributes: attributes131,
                                } = e;
                                *((base + 8)
                                    as *mut i32) = wit_bindgen::rt::as_i32(retain131);
                                match attributes131 {
                                    Some(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item132,
                                            array_references: array_references132,
                                            map_references: map_references132,
                                        } = e;
                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V137;
                                        match item132 {
                                            V137::Null => {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                            }
                                            V137::Undefined => {
                                                *((base + 24) as *mut u8) = (1i32) as u8;
                                            }
                                            V137::Boolean(e) => {
                                                *((base + 24) as *mut u8) = (2i32) as u8;
                                                *((base + 32)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V137::Number(e) => {
                                                *((base + 24) as *mut u8) = (3i32) as u8;
                                                *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V137::BigInt(e) => {
                                                *((base + 24) as *mut u8) = (4i32) as u8;
                                                *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V137::Str(e) => {
                                                *((base + 24) as *mut u8) = (5i32) as u8;
                                                let vec133 = e;
                                                let ptr133 = vec133.as_ptr() as i32;
                                                let len133 = vec133.len() as i32;
                                                *((base + 36) as *mut i32) = len133;
                                                *((base + 32) as *mut i32) = ptr133;
                                            }
                                            V137::Buffer(e) => {
                                                *((base + 24) as *mut u8) = (6i32) as u8;
                                                let vec134 = e;
                                                let ptr134 = vec134.as_ptr() as i32;
                                                let len134 = vec134.len() as i32;
                                                *((base + 36) as *mut i32) = len134;
                                                *((base + 32) as *mut i32) = ptr134;
                                            }
                                            V137::Array(e) => {
                                                *((base + 24) as *mut u8) = (7i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index135,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index135);
                                            }
                                            V137::Map(e) => {
                                                *((base + 24) as *mut u8) = (8i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index136,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index136);
                                            }
                                        }
                                        let vec144 = array_references132;
                                        let len144 = vec144.len() as i32;
                                        let layout144 = alloc::Layout::from_size_align_unchecked(
                                            vec144.len() * 8,
                                            4,
                                        );
                                        let result144 = if layout144.size() != 0 {
                                            let ptr = alloc::alloc(layout144);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout144);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec144.into_iter().enumerate() {
                                            let base = result144 as i32 + (i as i32) * 8;
                                            {
                                                let vec143 = e;
                                                let len143 = vec143.len() as i32;
                                                let layout143 = alloc::Layout::from_size_align_unchecked(
                                                    vec143.len() * 16,
                                                    8,
                                                );
                                                let result143 = if layout143.size() != 0 {
                                                    let ptr = alloc::alloc(layout143);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout143);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec143.into_iter().enumerate() {
                                                    let base = result143 as i32 + (i as i32) * 16;
                                                    {
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V142;
                                                        match e {
                                                            V142::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V142::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V142::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V142::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V142::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V142::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec138 = e;
                                                                let ptr138 = vec138.as_ptr() as i32;
                                                                let len138 = vec138.len() as i32;
                                                                *((base + 12) as *mut i32) = len138;
                                                                *((base + 8) as *mut i32) = ptr138;
                                                            }
                                                            V142::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec139 = e;
                                                                let ptr139 = vec139.as_ptr() as i32;
                                                                let len139 = vec139.len() as i32;
                                                                *((base + 12) as *mut i32) = len139;
                                                                *((base + 8) as *mut i32) = ptr139;
                                                            }
                                                            V142::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index140,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index140);
                                                            }
                                                            V142::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index141,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index141);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len143;
                                                *((base + 0) as *mut i32) = result143 as i32;
                                                cleanup_list.extend_from_slice(&[(result143, layout143)]);
                                            }
                                        }
                                        *((base + 44) as *mut i32) = len144;
                                        *((base + 40) as *mut i32) = result144 as i32;
                                        let vec153 = map_references132;
                                        let len153 = vec153.len() as i32;
                                        let layout153 = alloc::Layout::from_size_align_unchecked(
                                            vec153.len() * 8,
                                            4,
                                        );
                                        let result153 = if layout153.size() != 0 {
                                            let ptr = alloc::alloc(layout153);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout153);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec153.into_iter().enumerate() {
                                            let base = result153 as i32 + (i as i32) * 8;
                                            {
                                                let vec152 = e;
                                                let len152 = vec152.len() as i32;
                                                let layout152 = alloc::Layout::from_size_align_unchecked(
                                                    vec152.len() * 24,
                                                    8,
                                                );
                                                let result152 = if layout152.size() != 0 {
                                                    let ptr = alloc::alloc(layout152);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout152);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec152.into_iter().enumerate() {
                                                    let base = result152 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t145_0, t145_1) = e;
                                                        let vec146 = t145_0;
                                                        let ptr146 = vec146.as_ptr() as i32;
                                                        let len146 = vec146.len() as i32;
                                                        *((base + 4) as *mut i32) = len146;
                                                        *((base + 0) as *mut i32) = ptr146;
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V151;
                                                        match t145_1 {
                                                            V151::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V151::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V151::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V151::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V151::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V151::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec147 = e;
                                                                let ptr147 = vec147.as_ptr() as i32;
                                                                let len147 = vec147.len() as i32;
                                                                *((base + 20) as *mut i32) = len147;
                                                                *((base + 16) as *mut i32) = ptr147;
                                                            }
                                                            V151::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec148 = e;
                                                                let ptr148 = vec148.as_ptr() as i32;
                                                                let len148 = vec148.len() as i32;
                                                                *((base + 20) as *mut i32) = len148;
                                                                *((base + 16) as *mut i32) = ptr148;
                                                            }
                                                            V151::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index149,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index149);
                                                            }
                                                            V151::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index150,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index150);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len152;
                                                *((base + 0) as *mut i32) = result152 as i32;
                                                cleanup_list.extend_from_slice(&[(result152, layout152)]);
                                            }
                                        }
                                        *((base + 52) as *mut i32) = len153;
                                        *((base + 48) as *mut i32) = result153 as i32;
                                        cleanup_list
                                            .extend_from_slice(
                                                &[(result144, layout144), (result153, layout153)],
                                            );
                                    }
                                    None => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                    }
                                };
                            }
                        };
                    }
                }
                let vec156 = path104;
                let len156 = vec156.len() as i32;
                let layout156 = alloc::Layout::from_size_align_unchecked(
                    vec156.len() * 12,
                    4,
                );
                let result156 = if layout156.size() != 0 {
                    let ptr = alloc::alloc(layout156);
                    if ptr.is_null() {
                        alloc::handle_alloc_error(layout156);
                    }
                    ptr
                } else {
                    ::core::ptr::null_mut()
                };
                for (i, e) in vec156.into_iter().enumerate() {
                    let base = result156 as i32 + (i as i32) * 12;
                    {
                        match e {
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (0i32) as u8;
                                let vec155 = e;
                                let ptr155 = vec155.as_ptr() as i32;
                                let len155 = vec155.len() as i32;
                                *((base + 8) as *mut i32) = len155;
                                *((base + 4) as *mut i32) = ptr155;
                            }
                            y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                e,
                            ) => {
                                *((base + 0) as *mut u8) = (1i32) as u8;
                                *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            }
                        };
                    }
                }
                cleanup_list
                    .extend_from_slice(
                        &[(result154, layout154), (result156, layout156)],
                    );
                (
                    2i32,
                    wit_bindgen::rt::as_i32(ref_105),
                    result154 as i32,
                    len154,
                    result156 as i32,
                    len156,
                )
            }
        };
        #[cfg(not(target_arch = "wasm32"))]
        fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32) {
            ::core::panicking::panic("internal error: entered unreachable code")
        }
        wit_import(
            wit_bindgen::rt::as_i32(function_id),
            result157_0,
            result157_1,
            result157_2,
            result157_3,
            result157_4,
            result157_5,
        );
        for (ptr, layout) in cleanup_list {
            if layout.size() != 0 {
                alloc::dealloc(ptr, layout);
            }
        }
    }
}
#[allow(clippy::all)]
pub fn event_deep_callback(function_id: u32, event: &[YEvent]) {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    unsafe {
        let mut cleanup_list = Vec::new();
        let vec157 = event;
        let len157 = vec157.len() as i32;
        let layout157 = alloc::Layout::from_size_align_unchecked(vec157.len() * 24, 4);
        let result157 = if layout157.size() != 0 {
            let ptr = alloc::alloc(layout157);
            if ptr.is_null() {
                alloc::handle_alloc_error(layout157);
            }
            ptr
        } else {
            ::core::ptr::null_mut()
        };
        for (i, e) in vec157.into_iter().enumerate() {
            let base = result157 as i32 + (i as i32) * 24;
            {
                match e {
                    y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YArrayEvent(
                        e,
                    ) => {
                        *((base + 0) as *mut u8) = (0i32) as u8;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayEvent {
                            target: target0,
                            delta: delta0,
                            path: path0,
                        } = e;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: ref_1,
                        } = target0;
                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_1);
                        let vec35 = delta0;
                        let len35 = vec35.len() as i32;
                        let layout35 = alloc::Layout::from_size_align_unchecked(
                            vec35.len() * 12,
                            4,
                        );
                        let result35 = if layout35.size() != 0 {
                            let ptr = alloc::alloc(layout35);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout35);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec35.into_iter().enumerate() {
                            let base = result35 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaInsert(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaInsert {
                                            insert: insert2,
                                        } = e;
                                        let vec32 = insert2;
                                        let len32 = vec32.len() as i32;
                                        let layout32 = alloc::Layout::from_size_align_unchecked(
                                            vec32.len() * 40,
                                            8,
                                        );
                                        let result32 = if layout32.size() != 0 {
                                            let ptr = alloc::alloc(layout32);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout32);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec32.into_iter().enumerate() {
                                            let base = result32 as i32 + (i as i32) * 40;
                                            {
                                                match e {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                            item: item3,
                                                            array_references: array_references3,
                                                            map_references: map_references3,
                                                        } = e;
                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V8;
                                                        match item3 {
                                                            V8::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V8::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V8::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V8::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V8::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V8::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec4 = e;
                                                                let ptr4 = vec4.as_ptr() as i32;
                                                                let len4 = vec4.len() as i32;
                                                                *((base + 20) as *mut i32) = len4;
                                                                *((base + 16) as *mut i32) = ptr4;
                                                            }
                                                            V8::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec5 = e;
                                                                let ptr5 = vec5.as_ptr() as i32;
                                                                let len5 = vec5.len() as i32;
                                                                *((base + 20) as *mut i32) = len5;
                                                                *((base + 16) as *mut i32) = ptr5;
                                                            }
                                                            V8::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index6,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                                            }
                                                            V8::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index7,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                                            }
                                                        }
                                                        let vec15 = array_references3;
                                                        let len15 = vec15.len() as i32;
                                                        let layout15 = alloc::Layout::from_size_align_unchecked(
                                                            vec15.len() * 8,
                                                            4,
                                                        );
                                                        let result15 = if layout15.size() != 0 {
                                                            let ptr = alloc::alloc(layout15);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout15);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec15.into_iter().enumerate() {
                                                            let base = result15 as i32 + (i as i32) * 8;
                                                            {
                                                                let vec14 = e;
                                                                let len14 = vec14.len() as i32;
                                                                let layout14 = alloc::Layout::from_size_align_unchecked(
                                                                    vec14.len() * 16,
                                                                    8,
                                                                );
                                                                let result14 = if layout14.size() != 0 {
                                                                    let ptr = alloc::alloc(layout14);
                                                                    if ptr.is_null() {
                                                                        alloc::handle_alloc_error(layout14);
                                                                    }
                                                                    ptr
                                                                } else {
                                                                    ::core::ptr::null_mut()
                                                                };
                                                                for (i, e) in vec14.into_iter().enumerate() {
                                                                    let base = result14 as i32 + (i as i32) * 16;
                                                                    {
                                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V13;
                                                                        match e {
                                                                            V13::Null => {
                                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                                            }
                                                                            V13::Undefined => {
                                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                                            }
                                                                            V13::Boolean(e) => {
                                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                                *((base + 8)
                                                                                    as *mut u8) = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V13::Number(e) => {
                                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                            }
                                                                            V13::BigInt(e) => {
                                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                            }
                                                                            V13::Str(e) => {
                                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                                let vec9 = e;
                                                                                let ptr9 = vec9.as_ptr() as i32;
                                                                                let len9 = vec9.len() as i32;
                                                                                *((base + 12) as *mut i32) = len9;
                                                                                *((base + 8) as *mut i32) = ptr9;
                                                                            }
                                                                            V13::Buffer(e) => {
                                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                                let vec10 = e;
                                                                                let ptr10 = vec10.as_ptr() as i32;
                                                                                let len10 = vec10.len() as i32;
                                                                                *((base + 12) as *mut i32) = len10;
                                                                                *((base + 8) as *mut i32) = ptr10;
                                                                            }
                                                                            V13::Array(e) => {
                                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: index11,
                                                                                } = e;
                                                                                *((base + 8)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                                            }
                                                                            V13::Map(e) => {
                                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: index12,
                                                                                } = e;
                                                                                *((base + 8)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *((base + 4) as *mut i32) = len14;
                                                                *((base + 0) as *mut i32) = result14 as i32;
                                                                cleanup_list.extend_from_slice(&[(result14, layout14)]);
                                                            }
                                                        }
                                                        *((base + 28) as *mut i32) = len15;
                                                        *((base + 24) as *mut i32) = result15 as i32;
                                                        let vec24 = map_references3;
                                                        let len24 = vec24.len() as i32;
                                                        let layout24 = alloc::Layout::from_size_align_unchecked(
                                                            vec24.len() * 8,
                                                            4,
                                                        );
                                                        let result24 = if layout24.size() != 0 {
                                                            let ptr = alloc::alloc(layout24);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout24);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec24.into_iter().enumerate() {
                                                            let base = result24 as i32 + (i as i32) * 8;
                                                            {
                                                                let vec23 = e;
                                                                let len23 = vec23.len() as i32;
                                                                let layout23 = alloc::Layout::from_size_align_unchecked(
                                                                    vec23.len() * 24,
                                                                    8,
                                                                );
                                                                let result23 = if layout23.size() != 0 {
                                                                    let ptr = alloc::alloc(layout23);
                                                                    if ptr.is_null() {
                                                                        alloc::handle_alloc_error(layout23);
                                                                    }
                                                                    ptr
                                                                } else {
                                                                    ::core::ptr::null_mut()
                                                                };
                                                                for (i, e) in vec23.into_iter().enumerate() {
                                                                    let base = result23 as i32 + (i as i32) * 24;
                                                                    {
                                                                        let (t16_0, t16_1) = e;
                                                                        let vec17 = t16_0;
                                                                        let ptr17 = vec17.as_ptr() as i32;
                                                                        let len17 = vec17.len() as i32;
                                                                        *((base + 4) as *mut i32) = len17;
                                                                        *((base + 0) as *mut i32) = ptr17;
                                                                        use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V22;
                                                                        match t16_1 {
                                                                            V22::Null => {
                                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                                            }
                                                                            V22::Undefined => {
                                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                                            }
                                                                            V22::Boolean(e) => {
                                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                                *((base + 16)
                                                                                    as *mut u8) = (match e {
                                                                                    true => 1,
                                                                                    false => 0,
                                                                                }) as u8;
                                                                            }
                                                                            V22::Number(e) => {
                                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                            }
                                                                            V22::BigInt(e) => {
                                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                            }
                                                                            V22::Str(e) => {
                                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                                let vec18 = e;
                                                                                let ptr18 = vec18.as_ptr() as i32;
                                                                                let len18 = vec18.len() as i32;
                                                                                *((base + 20) as *mut i32) = len18;
                                                                                *((base + 16) as *mut i32) = ptr18;
                                                                            }
                                                                            V22::Buffer(e) => {
                                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                                let vec19 = e;
                                                                                let ptr19 = vec19.as_ptr() as i32;
                                                                                let len19 = vec19.len() as i32;
                                                                                *((base + 20) as *mut i32) = len19;
                                                                                *((base + 16) as *mut i32) = ptr19;
                                                                            }
                                                                            V22::Array(e) => {
                                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                                    index: index20,
                                                                                } = e;
                                                                                *((base + 16)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                                                            }
                                                                            V22::Map(e) => {
                                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                                    index: index21,
                                                                                } = e;
                                                                                *((base + 16)
                                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                *((base + 4) as *mut i32) = len23;
                                                                *((base + 0) as *mut i32) = result23 as i32;
                                                                cleanup_list.extend_from_slice(&[(result23, layout23)]);
                                                            }
                                                        }
                                                        *((base + 36) as *mut i32) = len24;
                                                        *((base + 32) as *mut i32) = result24 as i32;
                                                        cleanup_list
                                                            .extend_from_slice(
                                                                &[(result15, layout15), (result24, layout24)],
                                                            );
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                            ref_: ref_25,
                                                        } = e;
                                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                                        e,
                                                    ) => {
                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                        match e {
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                                    ref_: ref_26,
                                                                } = e;
                                                                *((base + 12)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                                    ref_: ref_27,
                                                                } = e;
                                                                *((base + 12)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                                    ref_: ref_28,
                                                                } = e;
                                                                *((base + 12)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                                    ref_: ref_29,
                                                                } = e;
                                                                *((base + 12)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                                    ref_: ref_30,
                                                                } = e;
                                                                *((base + 12)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_30);
                                                            }
                                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                                e,
                                                            ) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                                    ref_: ref_31,
                                                                } = e;
                                                                *((base + 12)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_31);
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                        }
                                        *((base + 8) as *mut i32) = len32;
                                        *((base + 4) as *mut i32) = result32 as i32;
                                        cleanup_list.extend_from_slice(&[(result32, layout32)]);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaDelete(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaDelete {
                                            delete: delete33,
                                        } = e;
                                        *((base + 4)
                                            as *mut i32) = wit_bindgen::rt::as_i32(delete33);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDelta::YArrayDeltaRetain(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArrayDeltaRetain {
                                            retain: retain34,
                                        } = e;
                                        *((base + 4)
                                            as *mut i32) = wit_bindgen::rt::as_i32(retain34);
                                    }
                                };
                            }
                        }
                        *((base + 12) as *mut i32) = len35;
                        *((base + 8) as *mut i32) = result35 as i32;
                        let vec37 = path0;
                        let len37 = vec37.len() as i32;
                        let layout37 = alloc::Layout::from_size_align_unchecked(
                            vec37.len() * 12,
                            4,
                        );
                        let result37 = if layout37.size() != 0 {
                            let ptr = alloc::alloc(layout37);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout37);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec37.into_iter().enumerate() {
                            let base = result37 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let vec36 = e;
                                        let ptr36 = vec36.as_ptr() as i32;
                                        let len36 = vec36.len() as i32;
                                        *((base + 8) as *mut i32) = len36;
                                        *((base + 4) as *mut i32) = ptr36;
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    }
                                };
                            }
                        }
                        *((base + 20) as *mut i32) = len37;
                        *((base + 16) as *mut i32) = result37 as i32;
                        cleanup_list
                            .extend_from_slice(
                                &[(result35, layout35), (result37, layout37)],
                            );
                    }
                    y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YMapEvent(
                        e,
                    ) => {
                        *((base + 0) as *mut u8) = (1i32) as u8;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapEvent {
                            target: target38,
                            keys: keys38,
                            path: path38,
                        } = e;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: ref_39,
                        } = target38;
                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_39);
                        let vec101 = keys38;
                        let len101 = vec101.len() as i32;
                        let layout101 = alloc::Layout::from_size_align_unchecked(
                            vec101.len() * 112,
                            8,
                        );
                        let result101 = if layout101.size() != 0 {
                            let ptr = alloc::alloc(layout101);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout101);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec101.into_iter().enumerate() {
                            let base = result101 as i32 + (i as i32) * 112;
                            {
                                let (t40_0, t40_1) = e;
                                let vec41 = t40_0;
                                let ptr41 = vec41.as_ptr() as i32;
                                let len41 = vec41.len() as i32;
                                *((base + 4) as *mut i32) = len41;
                                *((base + 0) as *mut i32) = ptr41;
                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YMapDelta {
                                    action: action42,
                                    old_value: old_value42,
                                    new_value: new_value42,
                                } = t40_1;
                                *((base + 8) as *mut u8) = (action42.clone() as i32) as u8;
                                match old_value42 {
                                    Some(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item43,
                                                    array_references: array_references43,
                                                    map_references: map_references43,
                                                } = e;
                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V48;
                                                match item43 {
                                                    V48::Null => {
                                                        *((base + 32) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V48::Undefined => {
                                                        *((base + 32) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V48::Boolean(e) => {
                                                        *((base + 32) as *mut u8) = (2i32) as u8;
                                                        *((base + 40)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V48::Number(e) => {
                                                        *((base + 32) as *mut u8) = (3i32) as u8;
                                                        *((base + 40) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V48::BigInt(e) => {
                                                        *((base + 32) as *mut u8) = (4i32) as u8;
                                                        *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V48::Str(e) => {
                                                        *((base + 32) as *mut u8) = (5i32) as u8;
                                                        let vec44 = e;
                                                        let ptr44 = vec44.as_ptr() as i32;
                                                        let len44 = vec44.len() as i32;
                                                        *((base + 44) as *mut i32) = len44;
                                                        *((base + 40) as *mut i32) = ptr44;
                                                    }
                                                    V48::Buffer(e) => {
                                                        *((base + 32) as *mut u8) = (6i32) as u8;
                                                        let vec45 = e;
                                                        let ptr45 = vec45.as_ptr() as i32;
                                                        let len45 = vec45.len() as i32;
                                                        *((base + 44) as *mut i32) = len45;
                                                        *((base + 40) as *mut i32) = ptr45;
                                                    }
                                                    V48::Array(e) => {
                                                        *((base + 32) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index46,
                                                        } = e;
                                                        *((base + 40)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index46);
                                                    }
                                                    V48::Map(e) => {
                                                        *((base + 32) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index47,
                                                        } = e;
                                                        *((base + 40)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index47);
                                                    }
                                                }
                                                let vec55 = array_references43;
                                                let len55 = vec55.len() as i32;
                                                let layout55 = alloc::Layout::from_size_align_unchecked(
                                                    vec55.len() * 8,
                                                    4,
                                                );
                                                let result55 = if layout55.size() != 0 {
                                                    let ptr = alloc::alloc(layout55);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout55);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec55.into_iter().enumerate() {
                                                    let base = result55 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec54 = e;
                                                        let len54 = vec54.len() as i32;
                                                        let layout54 = alloc::Layout::from_size_align_unchecked(
                                                            vec54.len() * 16,
                                                            8,
                                                        );
                                                        let result54 = if layout54.size() != 0 {
                                                            let ptr = alloc::alloc(layout54);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout54);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec54.into_iter().enumerate() {
                                                            let base = result54 as i32 + (i as i32) * 16;
                                                            {
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V53;
                                                                match e {
                                                                    V53::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V53::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V53::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V53::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V53::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V53::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec49 = e;
                                                                        let ptr49 = vec49.as_ptr() as i32;
                                                                        let len49 = vec49.len() as i32;
                                                                        *((base + 12) as *mut i32) = len49;
                                                                        *((base + 8) as *mut i32) = ptr49;
                                                                    }
                                                                    V53::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec50 = e;
                                                                        let ptr50 = vec50.as_ptr() as i32;
                                                                        let len50 = vec50.len() as i32;
                                                                        *((base + 12) as *mut i32) = len50;
                                                                        *((base + 8) as *mut i32) = ptr50;
                                                                    }
                                                                    V53::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index51,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index51);
                                                                    }
                                                                    V53::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index52,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index52);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len54;
                                                        *((base + 0) as *mut i32) = result54 as i32;
                                                        cleanup_list.extend_from_slice(&[(result54, layout54)]);
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len55;
                                                *((base + 48) as *mut i32) = result55 as i32;
                                                let vec64 = map_references43;
                                                let len64 = vec64.len() as i32;
                                                let layout64 = alloc::Layout::from_size_align_unchecked(
                                                    vec64.len() * 8,
                                                    4,
                                                );
                                                let result64 = if layout64.size() != 0 {
                                                    let ptr = alloc::alloc(layout64);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout64);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec64.into_iter().enumerate() {
                                                    let base = result64 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec63 = e;
                                                        let len63 = vec63.len() as i32;
                                                        let layout63 = alloc::Layout::from_size_align_unchecked(
                                                            vec63.len() * 24,
                                                            8,
                                                        );
                                                        let result63 = if layout63.size() != 0 {
                                                            let ptr = alloc::alloc(layout63);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout63);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec63.into_iter().enumerate() {
                                                            let base = result63 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t56_0, t56_1) = e;
                                                                let vec57 = t56_0;
                                                                let ptr57 = vec57.as_ptr() as i32;
                                                                let len57 = vec57.len() as i32;
                                                                *((base + 4) as *mut i32) = len57;
                                                                *((base + 0) as *mut i32) = ptr57;
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V62;
                                                                match t56_1 {
                                                                    V62::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V62::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V62::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V62::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V62::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V62::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec58 = e;
                                                                        let ptr58 = vec58.as_ptr() as i32;
                                                                        let len58 = vec58.len() as i32;
                                                                        *((base + 20) as *mut i32) = len58;
                                                                        *((base + 16) as *mut i32) = ptr58;
                                                                    }
                                                                    V62::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec59 = e;
                                                                        let ptr59 = vec59.as_ptr() as i32;
                                                                        let len59 = vec59.len() as i32;
                                                                        *((base + 20) as *mut i32) = len59;
                                                                        *((base + 16) as *mut i32) = ptr59;
                                                                    }
                                                                    V62::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index60,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index60);
                                                                    }
                                                                    V62::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index61,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index61);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len63;
                                                        *((base + 0) as *mut i32) = result63 as i32;
                                                        cleanup_list.extend_from_slice(&[(result63, layout63)]);
                                                    }
                                                }
                                                *((base + 60) as *mut i32) = len64;
                                                *((base + 56) as *mut i32) = result64 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result55, layout55), (result64, layout64)],
                                                    );
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                    ref_: ref_65,
                                                } = e;
                                                *((base + 32)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_65);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                                e,
                                            ) => {
                                                *((base + 24) as *mut u8) = (2i32) as u8;
                                                match e {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (0i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                            ref_: ref_66,
                                                        } = e;
                                                        *((base + 36)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_66);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (1i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                            ref_: ref_67,
                                                        } = e;
                                                        *((base + 36)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_67);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (2i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                            ref_: ref_68,
                                                        } = e;
                                                        *((base + 36)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_68);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (3i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                            ref_: ref_69,
                                                        } = e;
                                                        *((base + 36)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_69);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (4i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                            ref_: ref_70,
                                                        } = e;
                                                        *((base + 36)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_70);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                        e,
                                                    ) => {
                                                        *((base + 32) as *mut u8) = (5i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                            ref_: ref_71,
                                                        } = e;
                                                        *((base + 36)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_71);
                                                    }
                                                };
                                            }
                                        };
                                    }
                                    None => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                    }
                                };
                                match new_value42 {
                                    Some(e) => {
                                        *((base + 64) as *mut u8) = (1i32) as u8;
                                        match e {
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (0i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item72,
                                                    array_references: array_references72,
                                                    map_references: map_references72,
                                                } = e;
                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V77;
                                                match item72 {
                                                    V77::Null => {
                                                        *((base + 80) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V77::Undefined => {
                                                        *((base + 80) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V77::Boolean(e) => {
                                                        *((base + 80) as *mut u8) = (2i32) as u8;
                                                        *((base + 88)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V77::Number(e) => {
                                                        *((base + 80) as *mut u8) = (3i32) as u8;
                                                        *((base + 88) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V77::BigInt(e) => {
                                                        *((base + 80) as *mut u8) = (4i32) as u8;
                                                        *((base + 88) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V77::Str(e) => {
                                                        *((base + 80) as *mut u8) = (5i32) as u8;
                                                        let vec73 = e;
                                                        let ptr73 = vec73.as_ptr() as i32;
                                                        let len73 = vec73.len() as i32;
                                                        *((base + 92) as *mut i32) = len73;
                                                        *((base + 88) as *mut i32) = ptr73;
                                                    }
                                                    V77::Buffer(e) => {
                                                        *((base + 80) as *mut u8) = (6i32) as u8;
                                                        let vec74 = e;
                                                        let ptr74 = vec74.as_ptr() as i32;
                                                        let len74 = vec74.len() as i32;
                                                        *((base + 92) as *mut i32) = len74;
                                                        *((base + 88) as *mut i32) = ptr74;
                                                    }
                                                    V77::Array(e) => {
                                                        *((base + 80) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index75,
                                                        } = e;
                                                        *((base + 88)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index75);
                                                    }
                                                    V77::Map(e) => {
                                                        *((base + 80) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index76,
                                                        } = e;
                                                        *((base + 88)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index76);
                                                    }
                                                }
                                                let vec84 = array_references72;
                                                let len84 = vec84.len() as i32;
                                                let layout84 = alloc::Layout::from_size_align_unchecked(
                                                    vec84.len() * 8,
                                                    4,
                                                );
                                                let result84 = if layout84.size() != 0 {
                                                    let ptr = alloc::alloc(layout84);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout84);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec84.into_iter().enumerate() {
                                                    let base = result84 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec83 = e;
                                                        let len83 = vec83.len() as i32;
                                                        let layout83 = alloc::Layout::from_size_align_unchecked(
                                                            vec83.len() * 16,
                                                            8,
                                                        );
                                                        let result83 = if layout83.size() != 0 {
                                                            let ptr = alloc::alloc(layout83);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout83);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec83.into_iter().enumerate() {
                                                            let base = result83 as i32 + (i as i32) * 16;
                                                            {
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V82;
                                                                match e {
                                                                    V82::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V82::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V82::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V82::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V82::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V82::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec78 = e;
                                                                        let ptr78 = vec78.as_ptr() as i32;
                                                                        let len78 = vec78.len() as i32;
                                                                        *((base + 12) as *mut i32) = len78;
                                                                        *((base + 8) as *mut i32) = ptr78;
                                                                    }
                                                                    V82::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec79 = e;
                                                                        let ptr79 = vec79.as_ptr() as i32;
                                                                        let len79 = vec79.len() as i32;
                                                                        *((base + 12) as *mut i32) = len79;
                                                                        *((base + 8) as *mut i32) = ptr79;
                                                                    }
                                                                    V82::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index80,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index80);
                                                                    }
                                                                    V82::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index81,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index81);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len83;
                                                        *((base + 0) as *mut i32) = result83 as i32;
                                                        cleanup_list.extend_from_slice(&[(result83, layout83)]);
                                                    }
                                                }
                                                *((base + 100) as *mut i32) = len84;
                                                *((base + 96) as *mut i32) = result84 as i32;
                                                let vec93 = map_references72;
                                                let len93 = vec93.len() as i32;
                                                let layout93 = alloc::Layout::from_size_align_unchecked(
                                                    vec93.len() * 8,
                                                    4,
                                                );
                                                let result93 = if layout93.size() != 0 {
                                                    let ptr = alloc::alloc(layout93);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout93);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec93.into_iter().enumerate() {
                                                    let base = result93 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec92 = e;
                                                        let len92 = vec92.len() as i32;
                                                        let layout92 = alloc::Layout::from_size_align_unchecked(
                                                            vec92.len() * 24,
                                                            8,
                                                        );
                                                        let result92 = if layout92.size() != 0 {
                                                            let ptr = alloc::alloc(layout92);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout92);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec92.into_iter().enumerate() {
                                                            let base = result92 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t85_0, t85_1) = e;
                                                                let vec86 = t85_0;
                                                                let ptr86 = vec86.as_ptr() as i32;
                                                                let len86 = vec86.len() as i32;
                                                                *((base + 4) as *mut i32) = len86;
                                                                *((base + 0) as *mut i32) = ptr86;
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V91;
                                                                match t85_1 {
                                                                    V91::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V91::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V91::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V91::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V91::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V91::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec87 = e;
                                                                        let ptr87 = vec87.as_ptr() as i32;
                                                                        let len87 = vec87.len() as i32;
                                                                        *((base + 20) as *mut i32) = len87;
                                                                        *((base + 16) as *mut i32) = ptr87;
                                                                    }
                                                                    V91::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec88 = e;
                                                                        let ptr88 = vec88.as_ptr() as i32;
                                                                        let len88 = vec88.len() as i32;
                                                                        *((base + 20) as *mut i32) = len88;
                                                                        *((base + 16) as *mut i32) = ptr88;
                                                                    }
                                                                    V91::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index89,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index89);
                                                                    }
                                                                    V91::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index90,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index90);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len92;
                                                        *((base + 0) as *mut i32) = result92 as i32;
                                                        cleanup_list.extend_from_slice(&[(result92, layout92)]);
                                                    }
                                                }
                                                *((base + 108) as *mut i32) = len93;
                                                *((base + 104) as *mut i32) = result93 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result84, layout84), (result93, layout93)],
                                                    );
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                                    ref_: ref_94,
                                                } = e;
                                                *((base + 80)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_94);
                                            }
                                            y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                                e,
                                            ) => {
                                                *((base + 72) as *mut u8) = (2i32) as u8;
                                                match e {
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (0i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                            ref_: ref_95,
                                                        } = e;
                                                        *((base + 84)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_95);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (1i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                            ref_: ref_96,
                                                        } = e;
                                                        *((base + 84)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_96);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (2i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                            ref_: ref_97,
                                                        } = e;
                                                        *((base + 84)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_97);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (3i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                            ref_: ref_98,
                                                        } = e;
                                                        *((base + 84)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_98);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (4i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                            ref_: ref_99,
                                                        } = e;
                                                        *((base + 84)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_99);
                                                    }
                                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                        e,
                                                    ) => {
                                                        *((base + 80) as *mut u8) = (5i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                            ref_: ref_100,
                                                        } = e;
                                                        *((base + 84)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_100);
                                                    }
                                                };
                                            }
                                        };
                                    }
                                    None => {
                                        *((base + 64) as *mut u8) = (0i32) as u8;
                                    }
                                };
                            }
                        }
                        *((base + 12) as *mut i32) = len101;
                        *((base + 8) as *mut i32) = result101 as i32;
                        let vec103 = path38;
                        let len103 = vec103.len() as i32;
                        let layout103 = alloc::Layout::from_size_align_unchecked(
                            vec103.len() * 12,
                            4,
                        );
                        let result103 = if layout103.size() != 0 {
                            let ptr = alloc::alloc(layout103);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout103);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec103.into_iter().enumerate() {
                            let base = result103 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let vec102 = e;
                                        let ptr102 = vec102.as_ptr() as i32;
                                        let len102 = vec102.len() as i32;
                                        *((base + 8) as *mut i32) = len102;
                                        *((base + 4) as *mut i32) = ptr102;
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    }
                                };
                            }
                        }
                        *((base + 20) as *mut i32) = len103;
                        *((base + 16) as *mut i32) = result103 as i32;
                        cleanup_list
                            .extend_from_slice(
                                &[(result101, layout101), (result103, layout103)],
                            );
                    }
                    y_crdt_namespace::y_crdt::y_doc_methods_types::YEvent::YTextEvent(
                        e,
                    ) => {
                        *((base + 0) as *mut u8) = (2i32) as u8;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextEvent {
                            target: target104,
                            delta: delta104,
                            path: path104,
                        } = e;
                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: ref_105,
                        } = target104;
                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_105);
                        let vec154 = delta104;
                        let len154 = vec154.len() as i32;
                        let layout154 = alloc::Layout::from_size_align_unchecked(
                            vec154.len() * 56,
                            8,
                        );
                        let result154 = if layout154.size() != 0 {
                            let ptr = alloc::alloc(layout154);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout154);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec154.into_iter().enumerate() {
                            let base = result154 as i32 + (i as i32) * 56;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaInsert(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaInsert {
                                            insert: insert106,
                                            attributes: attributes106,
                                        } = e;
                                        let vec107 = insert106;
                                        let ptr107 = vec107.as_ptr() as i32;
                                        let len107 = vec107.len() as i32;
                                        *((base + 12) as *mut i32) = len107;
                                        *((base + 8) as *mut i32) = ptr107;
                                        match attributes106 {
                                            Some(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item108,
                                                    array_references: array_references108,
                                                    map_references: map_references108,
                                                } = e;
                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V113;
                                                match item108 {
                                                    V113::Null => {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V113::Undefined => {
                                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V113::Boolean(e) => {
                                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                                        *((base + 32)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V113::Number(e) => {
                                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V113::BigInt(e) => {
                                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V113::Str(e) => {
                                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                                        let vec109 = e;
                                                        let ptr109 = vec109.as_ptr() as i32;
                                                        let len109 = vec109.len() as i32;
                                                        *((base + 36) as *mut i32) = len109;
                                                        *((base + 32) as *mut i32) = ptr109;
                                                    }
                                                    V113::Buffer(e) => {
                                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                                        let vec110 = e;
                                                        let ptr110 = vec110.as_ptr() as i32;
                                                        let len110 = vec110.len() as i32;
                                                        *((base + 36) as *mut i32) = len110;
                                                        *((base + 32) as *mut i32) = ptr110;
                                                    }
                                                    V113::Array(e) => {
                                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index111,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index111);
                                                    }
                                                    V113::Map(e) => {
                                                        *((base + 24) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index112,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index112);
                                                    }
                                                }
                                                let vec120 = array_references108;
                                                let len120 = vec120.len() as i32;
                                                let layout120 = alloc::Layout::from_size_align_unchecked(
                                                    vec120.len() * 8,
                                                    4,
                                                );
                                                let result120 = if layout120.size() != 0 {
                                                    let ptr = alloc::alloc(layout120);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout120);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec120.into_iter().enumerate() {
                                                    let base = result120 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec119 = e;
                                                        let len119 = vec119.len() as i32;
                                                        let layout119 = alloc::Layout::from_size_align_unchecked(
                                                            vec119.len() * 16,
                                                            8,
                                                        );
                                                        let result119 = if layout119.size() != 0 {
                                                            let ptr = alloc::alloc(layout119);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout119);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec119.into_iter().enumerate() {
                                                            let base = result119 as i32 + (i as i32) * 16;
                                                            {
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V118;
                                                                match e {
                                                                    V118::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V118::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V118::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V118::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V118::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V118::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec114 = e;
                                                                        let ptr114 = vec114.as_ptr() as i32;
                                                                        let len114 = vec114.len() as i32;
                                                                        *((base + 12) as *mut i32) = len114;
                                                                        *((base + 8) as *mut i32) = ptr114;
                                                                    }
                                                                    V118::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec115 = e;
                                                                        let ptr115 = vec115.as_ptr() as i32;
                                                                        let len115 = vec115.len() as i32;
                                                                        *((base + 12) as *mut i32) = len115;
                                                                        *((base + 8) as *mut i32) = ptr115;
                                                                    }
                                                                    V118::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index116,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index116);
                                                                    }
                                                                    V118::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index117,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index117);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len119;
                                                        *((base + 0) as *mut i32) = result119 as i32;
                                                        cleanup_list.extend_from_slice(&[(result119, layout119)]);
                                                    }
                                                }
                                                *((base + 44) as *mut i32) = len120;
                                                *((base + 40) as *mut i32) = result120 as i32;
                                                let vec129 = map_references108;
                                                let len129 = vec129.len() as i32;
                                                let layout129 = alloc::Layout::from_size_align_unchecked(
                                                    vec129.len() * 8,
                                                    4,
                                                );
                                                let result129 = if layout129.size() != 0 {
                                                    let ptr = alloc::alloc(layout129);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout129);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec129.into_iter().enumerate() {
                                                    let base = result129 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec128 = e;
                                                        let len128 = vec128.len() as i32;
                                                        let layout128 = alloc::Layout::from_size_align_unchecked(
                                                            vec128.len() * 24,
                                                            8,
                                                        );
                                                        let result128 = if layout128.size() != 0 {
                                                            let ptr = alloc::alloc(layout128);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout128);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec128.into_iter().enumerate() {
                                                            let base = result128 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t121_0, t121_1) = e;
                                                                let vec122 = t121_0;
                                                                let ptr122 = vec122.as_ptr() as i32;
                                                                let len122 = vec122.len() as i32;
                                                                *((base + 4) as *mut i32) = len122;
                                                                *((base + 0) as *mut i32) = ptr122;
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V127;
                                                                match t121_1 {
                                                                    V127::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V127::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V127::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V127::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V127::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V127::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec123 = e;
                                                                        let ptr123 = vec123.as_ptr() as i32;
                                                                        let len123 = vec123.len() as i32;
                                                                        *((base + 20) as *mut i32) = len123;
                                                                        *((base + 16) as *mut i32) = ptr123;
                                                                    }
                                                                    V127::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec124 = e;
                                                                        let ptr124 = vec124.as_ptr() as i32;
                                                                        let len124 = vec124.len() as i32;
                                                                        *((base + 20) as *mut i32) = len124;
                                                                        *((base + 16) as *mut i32) = ptr124;
                                                                    }
                                                                    V127::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index125,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index125);
                                                                    }
                                                                    V127::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index126,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index126);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len128;
                                                        *((base + 0) as *mut i32) = result128 as i32;
                                                        cleanup_list.extend_from_slice(&[(result128, layout128)]);
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len129;
                                                *((base + 48) as *mut i32) = result129 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result120, layout120), (result129, layout129)],
                                                    );
                                            }
                                            None => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                        };
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaDelete(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaDelete {
                                            delete: delete130,
                                        } = e;
                                        *((base + 8)
                                            as *mut i32) = wit_bindgen::rt::as_i32(delete130);
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaRetain(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaRetain {
                                            retain: retain131,
                                            attributes: attributes131,
                                        } = e;
                                        *((base + 8)
                                            as *mut i32) = wit_bindgen::rt::as_i32(retain131);
                                        match attributes131 {
                                            Some(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item132,
                                                    array_references: array_references132,
                                                    map_references: map_references132,
                                                } = e;
                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V137;
                                                match item132 {
                                                    V137::Null => {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V137::Undefined => {
                                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V137::Boolean(e) => {
                                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                                        *((base + 32)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V137::Number(e) => {
                                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V137::BigInt(e) => {
                                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V137::Str(e) => {
                                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                                        let vec133 = e;
                                                        let ptr133 = vec133.as_ptr() as i32;
                                                        let len133 = vec133.len() as i32;
                                                        *((base + 36) as *mut i32) = len133;
                                                        *((base + 32) as *mut i32) = ptr133;
                                                    }
                                                    V137::Buffer(e) => {
                                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                                        let vec134 = e;
                                                        let ptr134 = vec134.as_ptr() as i32;
                                                        let len134 = vec134.len() as i32;
                                                        *((base + 36) as *mut i32) = len134;
                                                        *((base + 32) as *mut i32) = ptr134;
                                                    }
                                                    V137::Array(e) => {
                                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index135,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index135);
                                                    }
                                                    V137::Map(e) => {
                                                        *((base + 24) as *mut u8) = (8i32) as u8;
                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index136,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index136);
                                                    }
                                                }
                                                let vec144 = array_references132;
                                                let len144 = vec144.len() as i32;
                                                let layout144 = alloc::Layout::from_size_align_unchecked(
                                                    vec144.len() * 8,
                                                    4,
                                                );
                                                let result144 = if layout144.size() != 0 {
                                                    let ptr = alloc::alloc(layout144);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout144);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec144.into_iter().enumerate() {
                                                    let base = result144 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec143 = e;
                                                        let len143 = vec143.len() as i32;
                                                        let layout143 = alloc::Layout::from_size_align_unchecked(
                                                            vec143.len() * 16,
                                                            8,
                                                        );
                                                        let result143 = if layout143.size() != 0 {
                                                            let ptr = alloc::alloc(layout143);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout143);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec143.into_iter().enumerate() {
                                                            let base = result143 as i32 + (i as i32) * 16;
                                                            {
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V142;
                                                                match e {
                                                                    V142::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V142::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V142::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V142::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V142::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V142::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec138 = e;
                                                                        let ptr138 = vec138.as_ptr() as i32;
                                                                        let len138 = vec138.len() as i32;
                                                                        *((base + 12) as *mut i32) = len138;
                                                                        *((base + 8) as *mut i32) = ptr138;
                                                                    }
                                                                    V142::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec139 = e;
                                                                        let ptr139 = vec139.as_ptr() as i32;
                                                                        let len139 = vec139.len() as i32;
                                                                        *((base + 12) as *mut i32) = len139;
                                                                        *((base + 8) as *mut i32) = ptr139;
                                                                    }
                                                                    V142::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index140,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index140);
                                                                    }
                                                                    V142::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index141,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index141);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len143;
                                                        *((base + 0) as *mut i32) = result143 as i32;
                                                        cleanup_list.extend_from_slice(&[(result143, layout143)]);
                                                    }
                                                }
                                                *((base + 44) as *mut i32) = len144;
                                                *((base + 40) as *mut i32) = result144 as i32;
                                                let vec153 = map_references132;
                                                let len153 = vec153.len() as i32;
                                                let layout153 = alloc::Layout::from_size_align_unchecked(
                                                    vec153.len() * 8,
                                                    4,
                                                );
                                                let result153 = if layout153.size() != 0 {
                                                    let ptr = alloc::alloc(layout153);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout153);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec153.into_iter().enumerate() {
                                                    let base = result153 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec152 = e;
                                                        let len152 = vec152.len() as i32;
                                                        let layout152 = alloc::Layout::from_size_align_unchecked(
                                                            vec152.len() * 24,
                                                            8,
                                                        );
                                                        let result152 = if layout152.size() != 0 {
                                                            let ptr = alloc::alloc(layout152);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout152);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec152.into_iter().enumerate() {
                                                            let base = result152 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t145_0, t145_1) = e;
                                                                let vec146 = t145_0;
                                                                let ptr146 = vec146.as_ptr() as i32;
                                                                let len146 = vec146.len() as i32;
                                                                *((base + 4) as *mut i32) = len146;
                                                                *((base + 0) as *mut i32) = ptr146;
                                                                use y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V151;
                                                                match t145_1 {
                                                                    V151::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V151::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V151::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V151::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V151::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V151::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec147 = e;
                                                                        let ptr147 = vec147.as_ptr() as i32;
                                                                        let len147 = vec147.len() as i32;
                                                                        *((base + 20) as *mut i32) = len147;
                                                                        *((base + 16) as *mut i32) = ptr147;
                                                                    }
                                                                    V151::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec148 = e;
                                                                        let ptr148 = vec148.as_ptr() as i32;
                                                                        let len148 = vec148.len() as i32;
                                                                        *((base + 20) as *mut i32) = len148;
                                                                        *((base + 16) as *mut i32) = ptr148;
                                                                    }
                                                                    V151::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index149,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index149);
                                                                    }
                                                                    V151::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index150,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index150);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len152;
                                                        *((base + 0) as *mut i32) = result152 as i32;
                                                        cleanup_list.extend_from_slice(&[(result152, layout152)]);
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len153;
                                                *((base + 48) as *mut i32) = result153 as i32;
                                                cleanup_list
                                                    .extend_from_slice(
                                                        &[(result144, layout144), (result153, layout153)],
                                                    );
                                            }
                                            None => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                        };
                                    }
                                };
                            }
                        }
                        *((base + 12) as *mut i32) = len154;
                        *((base + 8) as *mut i32) = result154 as i32;
                        let vec156 = path104;
                        let len156 = vec156.len() as i32;
                        let layout156 = alloc::Layout::from_size_align_unchecked(
                            vec156.len() * 12,
                            4,
                        );
                        let result156 = if layout156.size() != 0 {
                            let ptr = alloc::alloc(layout156);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout156);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec156.into_iter().enumerate() {
                            let base = result156 as i32 + (i as i32) * 12;
                            {
                                match e {
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::String(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let vec155 = e;
                                        let ptr155 = vec155.as_ptr() as i32;
                                        let len155 = vec155.len() as i32;
                                        *((base + 8) as *mut i32) = len155;
                                        *((base + 4) as *mut i32) = ptr155;
                                    }
                                    y_crdt_namespace::y_crdt::y_doc_methods_types::EventPathItem::U32(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    }
                                };
                            }
                        }
                        *((base + 20) as *mut i32) = len156;
                        *((base + 16) as *mut i32) = result156 as i32;
                        cleanup_list
                            .extend_from_slice(
                                &[(result154, layout154), (result156, layout156)],
                            );
                    }
                };
            }
        }
        #[cfg(not(target_arch = "wasm32"))]
        fn wit_import(_: i32, _: i32, _: i32) {
            ::core::panicking::panic("internal error: entered unreachable code")
        }
        wit_import(wit_bindgen::rt::as_i32(function_id), result157 as i32, len157);
        if layout157.size() != 0 {
            alloc::dealloc(result157, layout157);
        }
        for (ptr, layout) in cleanup_list {
            if layout.size() != 0 {
                alloc::dealloc(ptr, layout);
            }
        }
    }
}
#[allow(clippy::all)]
pub fn undo_event_callback(function_id: u32, event: &YUndoEvent) {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    unsafe {
        let y_crdt_namespace::y_crdt::y_doc_methods_types::YUndoEvent {
            origin: origin0,
            kind: kind0,
            stack_item: stack_item0,
        } = event;
        let (result2_0, result2_1, result2_2) = match origin0 {
            Some(e) => {
                let vec1 = e;
                let ptr1 = vec1.as_ptr() as i32;
                let len1 = vec1.len() as i32;
                (1i32, ptr1, len1)
            }
            None => (0i32, 0i32, 0i32),
        };
        let y_crdt_namespace::y_crdt::y_doc_methods_types::StackItemSets {
            insertions: insertions3,
            deletions: deletions3,
        } = stack_item0;
        let vec6 = insertions3;
        let len6 = vec6.len() as i32;
        let layout6 = alloc::Layout::from_size_align_unchecked(vec6.len() * 16, 8);
        let result6 = if layout6.size() != 0 {
            let ptr = alloc::alloc(layout6);
            if ptr.is_null() {
                alloc::handle_alloc_error(layout6);
            }
            ptr
        } else {
            ::core::ptr::null_mut()
        };
        for (i, e) in vec6.into_iter().enumerate() {
            let base = result6 as i32 + (i as i32) * 16;
            {
                let (t4_0, t4_1) = e;
                *((base + 0) as *mut i64) = wit_bindgen::rt::as_i64(t4_0);
                let vec5 = t4_1;
                let ptr5 = vec5.as_ptr() as i32;
                let len5 = vec5.len() as i32;
                *((base + 12) as *mut i32) = len5;
                *((base + 8) as *mut i32) = ptr5;
            }
        }
        let vec9 = deletions3;
        let len9 = vec9.len() as i32;
        let layout9 = alloc::Layout::from_size_align_unchecked(vec9.len() * 16, 8);
        let result9 = if layout9.size() != 0 {
            let ptr = alloc::alloc(layout9);
            if ptr.is_null() {
                alloc::handle_alloc_error(layout9);
            }
            ptr
        } else {
            ::core::ptr::null_mut()
        };
        for (i, e) in vec9.into_iter().enumerate() {
            let base = result9 as i32 + (i as i32) * 16;
            {
                let (t7_0, t7_1) = e;
                *((base + 0) as *mut i64) = wit_bindgen::rt::as_i64(t7_0);
                let vec8 = t7_1;
                let ptr8 = vec8.as_ptr() as i32;
                let len8 = vec8.len() as i32;
                *((base + 12) as *mut i32) = len8;
                *((base + 8) as *mut i32) = ptr8;
            }
        }
        #[cfg(not(target_arch = "wasm32"))]
        fn wit_import(
            _: i32,
            _: i32,
            _: i32,
            _: i32,
            _: i32,
            _: i32,
            _: i32,
            _: i32,
            _: i32,
        ) {
            ::core::panicking::panic("internal error: entered unreachable code")
        }
        wit_import(
            wit_bindgen::rt::as_i32(function_id),
            result2_0,
            result2_1,
            result2_2,
            kind0.clone() as i32,
            result6 as i32,
            len6,
            result9 as i32,
            len9,
        );
        if layout6.size() != 0 {
            alloc::dealloc(result6, layout6);
        }
        if layout9.size() != 0 {
            alloc::dealloc(result9, layout9);
        }
    }
}
pub mod y_crdt_namespace {
    pub mod y_crdt {
        #[allow(clippy::all)]
        pub mod y_doc_methods_types {
            #[repr(C)]
            pub struct EventObserver {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EventObserver {}
            #[automatically_derived]
            impl ::core::clone::Clone for EventObserver {
                #[inline]
                fn clone(&self) -> EventObserver {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for EventObserver {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EventObserver").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YDoc {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YDoc {}
            #[automatically_derived]
            impl ::core::clone::Clone for YDoc {
                #[inline]
                fn clone(&self) -> YDoc {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YDoc {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YDoc").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct ReadTransaction {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ReadTransaction {}
            #[automatically_derived]
            impl ::core::clone::Clone for ReadTransaction {
                #[inline]
                fn clone(&self) -> ReadTransaction {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for ReadTransaction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ReadTransaction").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct WriteTransaction {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for WriteTransaction {}
            #[automatically_derived]
            impl ::core::clone::Clone for WriteTransaction {
                #[inline]
                fn clone(&self) -> WriteTransaction {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for WriteTransaction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WriteTransaction").field("ref", &self.ref_).finish()
                }
            }
            pub enum YTransaction {
                ReadTransaction(ReadTransaction),
                WriteTransaction(WriteTransaction),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTransaction {
                #[inline]
                fn clone(&self) -> YTransaction {
                    let _: ::core::clone::AssertParamIsClone<ReadTransaction>;
                    let _: ::core::clone::AssertParamIsClone<WriteTransaction>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YTransaction {}
            impl ::core::fmt::Debug for YTransaction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YTransaction::ReadTransaction(e) => {
                            f.debug_tuple("YTransaction::ReadTransaction")
                                .field(e)
                                .finish()
                        }
                        YTransaction::WriteTransaction(e) => {
                            f.debug_tuple("YTransaction::WriteTransaction")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct YText {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YText {}
            #[automatically_derived]
            impl ::core::clone::Clone for YText {
                #[inline]
                fn clone(&self) -> YText {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YText {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YText").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YArray {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YArray {}
            #[automatically_derived]
            impl ::core::clone::Clone for YArray {
                #[inline]
                fn clone(&self) -> YArray {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YArray {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArray").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YMap {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YMap {}
            #[automatically_derived]
            impl ::core::clone::Clone for YMap {
                #[inline]
                fn clone(&self) -> YMap {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YMap {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YMap").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YXmlFragment {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YXmlFragment {}
            #[automatically_derived]
            impl ::core::clone::Clone for YXmlFragment {
                #[inline]
                fn clone(&self) -> YXmlFragment {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YXmlFragment {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YXmlFragment").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YXmlElement {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YXmlElement {}
            #[automatically_derived]
            impl ::core::clone::Clone for YXmlElement {
                #[inline]
                fn clone(&self) -> YXmlElement {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YXmlElement {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YXmlElement").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct YXmlText {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YXmlText {}
            #[automatically_derived]
            impl ::core::clone::Clone for YXmlText {
                #[inline]
                fn clone(&self) -> YXmlText {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YXmlText {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YXmlText").field("ref", &self.ref_).finish()
                }
            }
            pub enum YType {
                YText(YText),
                YArray(YArray),
                YMap(YMap),
                YXmlFragment(YXmlFragment),
                YXmlElement(YXmlElement),
                YXmlText(YXmlText),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YType {
                #[inline]
                fn clone(&self) -> YType {
                    let _: ::core::clone::AssertParamIsClone<YText>;
                    let _: ::core::clone::AssertParamIsClone<YArray>;
                    let _: ::core::clone::AssertParamIsClone<YMap>;
                    let _: ::core::clone::AssertParamIsClone<YXmlFragment>;
                    let _: ::core::clone::AssertParamIsClone<YXmlElement>;
                    let _: ::core::clone::AssertParamIsClone<YXmlText>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YType {}
            impl ::core::fmt::Debug for YType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YType::YText(e) => {
                            f.debug_tuple("YType::YText").field(e).finish()
                        }
                        YType::YArray(e) => {
                            f.debug_tuple("YType::YArray").field(e).finish()
                        }
                        YType::YMap(e) => f.debug_tuple("YType::YMap").field(e).finish(),
                        YType::YXmlFragment(e) => {
                            f.debug_tuple("YType::YXmlFragment").field(e).finish()
                        }
                        YType::YXmlElement(e) => {
                            f.debug_tuple("YType::YXmlElement").field(e).finish()
                        }
                        YType::YXmlText(e) => {
                            f.debug_tuple("YType::YXmlText").field(e).finish()
                        }
                    }
                }
            }
            pub enum EventPathItem {
                String(wit_bindgen::rt::string::String),
                U32(u32),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for EventPathItem {
                #[inline]
                fn clone(&self) -> EventPathItem {
                    match self {
                        EventPathItem::String(__self_0) => {
                            EventPathItem::String(::core::clone::Clone::clone(__self_0))
                        }
                        EventPathItem::U32(__self_0) => {
                            EventPathItem::U32(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for EventPathItem {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        EventPathItem::String(e) => {
                            f.debug_tuple("EventPathItem::String").field(e).finish()
                        }
                        EventPathItem::U32(e) => {
                            f.debug_tuple("EventPathItem::U32").field(e).finish()
                        }
                    }
                }
            }
            pub type EventPath = wit_bindgen::rt::vec::Vec<EventPathItem>;
            #[repr(C)]
            pub struct YArrayDeltaDelete {
                pub delete: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YArrayDeltaDelete {}
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayDeltaDelete {
                #[inline]
                fn clone(&self) -> YArrayDeltaDelete {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YArrayDeltaDelete {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayDeltaDelete")
                        .field("delete", &self.delete)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct YArrayDeltaRetain {
                pub retain: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YArrayDeltaRetain {}
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayDeltaRetain {
                #[inline]
                fn clone(&self) -> YArrayDeltaRetain {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YArrayDeltaRetain {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayDeltaRetain")
                        .field("retain", &self.retain)
                        .finish()
                }
            }
            #[repr(u8)]
            pub enum YMapDeltaAction {
                Insert,
                Update,
                Delete,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YMapDeltaAction {
                #[inline]
                fn clone(&self) -> YMapDeltaAction {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YMapDeltaAction {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for YMapDeltaAction {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for YMapDeltaAction {
                #[inline]
                fn eq(&self, other: &YMapDeltaAction) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for YMapDeltaAction {}
            #[automatically_derived]
            impl ::core::cmp::Eq for YMapDeltaAction {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            impl ::core::fmt::Debug for YMapDeltaAction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YMapDeltaAction::Insert => {
                            f.debug_tuple("YMapDeltaAction::Insert").finish()
                        }
                        YMapDeltaAction::Update => {
                            f.debug_tuple("YMapDeltaAction::Update").finish()
                        }
                        YMapDeltaAction::Delete => {
                            f.debug_tuple("YMapDeltaAction::Delete").finish()
                        }
                    }
                }
            }
            impl YMapDeltaAction {
                pub(crate) unsafe fn _lift(val: u8) -> YMapDeltaAction {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => YMapDeltaAction::Insert,
                        1 => YMapDeltaAction::Update,
                        2 => YMapDeltaAction::Delete,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct YTextDeltaDelete {
                pub delete: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YTextDeltaDelete {}
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDeltaDelete {
                #[inline]
                fn clone(&self) -> YTextDeltaDelete {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YTextDeltaDelete {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextDeltaDelete")
                        .field("delete", &self.delete)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct YSnapshot {
                pub ref_: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YSnapshot {}
            #[automatically_derived]
            impl ::core::clone::Clone for YSnapshot {
                #[inline]
                fn clone(&self) -> YSnapshot {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for YSnapshot {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YSnapshot").field("ref", &self.ref_).finish()
                }
            }
            #[repr(C)]
            pub struct JsonArrayRef {
                pub index: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for JsonArrayRef {}
            #[automatically_derived]
            impl ::core::clone::Clone for JsonArrayRef {
                #[inline]
                fn clone(&self) -> JsonArrayRef {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for JsonArrayRef {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JsonArrayRef").field("index", &self.index).finish()
                }
            }
            #[repr(C)]
            pub struct JsonMapRef {
                pub index: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for JsonMapRef {}
            #[automatically_derived]
            impl ::core::clone::Clone for JsonMapRef {
                #[inline]
                fn clone(&self) -> JsonMapRef {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for JsonMapRef {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JsonMapRef").field("index", &self.index).finish()
                }
            }
            pub enum JsonValue {
                Null,
                Undefined,
                Boolean(bool),
                Number(f64),
                BigInt(i64),
                Str(wit_bindgen::rt::string::String),
                Buffer(wit_bindgen::rt::vec::Vec<u8>),
                Array(JsonArrayRef),
                Map(JsonMapRef),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JsonValue {
                #[inline]
                fn clone(&self) -> JsonValue {
                    match self {
                        JsonValue::Null => JsonValue::Null,
                        JsonValue::Undefined => JsonValue::Undefined,
                        JsonValue::Boolean(__self_0) => {
                            JsonValue::Boolean(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Number(__self_0) => {
                            JsonValue::Number(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::BigInt(__self_0) => {
                            JsonValue::BigInt(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Str(__self_0) => {
                            JsonValue::Str(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Buffer(__self_0) => {
                            JsonValue::Buffer(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Array(__self_0) => {
                            JsonValue::Array(::core::clone::Clone::clone(__self_0))
                        }
                        JsonValue::Map(__self_0) => {
                            JsonValue::Map(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for JsonValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        JsonValue::Null => f.debug_tuple("JsonValue::Null").finish(),
                        JsonValue::Undefined => {
                            f.debug_tuple("JsonValue::Undefined").finish()
                        }
                        JsonValue::Boolean(e) => {
                            f.debug_tuple("JsonValue::Boolean").field(e).finish()
                        }
                        JsonValue::Number(e) => {
                            f.debug_tuple("JsonValue::Number").field(e).finish()
                        }
                        JsonValue::BigInt(e) => {
                            f.debug_tuple("JsonValue::BigInt").field(e).finish()
                        }
                        JsonValue::Str(e) => {
                            f.debug_tuple("JsonValue::Str").field(e).finish()
                        }
                        JsonValue::Buffer(e) => {
                            f.debug_tuple("JsonValue::Buffer").field(e).finish()
                        }
                        JsonValue::Array(e) => {
                            f.debug_tuple("JsonValue::Array").field(e).finish()
                        }
                        JsonValue::Map(e) => {
                            f.debug_tuple("JsonValue::Map").field(e).finish()
                        }
                    }
                }
            }
            pub struct JsonValueItem {
                pub item: JsonValue,
                pub array_references: wit_bindgen::rt::vec::Vec<
                    wit_bindgen::rt::vec::Vec<JsonValue>,
                >,
                pub map_references: wit_bindgen::rt::vec::Vec<
                    wit_bindgen::rt::vec::Vec<
                        (wit_bindgen::rt::string::String, JsonValue),
                    >,
                >,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JsonValueItem {
                #[inline]
                fn clone(&self) -> JsonValueItem {
                    JsonValueItem {
                        item: ::core::clone::Clone::clone(&self.item),
                        array_references: ::core::clone::Clone::clone(
                            &self.array_references,
                        ),
                        map_references: ::core::clone::Clone::clone(&self.map_references),
                    }
                }
            }
            impl ::core::fmt::Debug for JsonValueItem {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JsonValueItem")
                        .field("item", &self.item)
                        .field("array-references", &self.array_references)
                        .field("map-references", &self.map_references)
                        .finish()
                }
            }
            pub enum YValue {
                JsonValueItem(JsonValueItem),
                YDoc(YDoc),
                YType(YType),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YValue {
                #[inline]
                fn clone(&self) -> YValue {
                    match self {
                        YValue::JsonValueItem(__self_0) => {
                            YValue::JsonValueItem(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YDoc(__self_0) => {
                            YValue::YDoc(::core::clone::Clone::clone(__self_0))
                        }
                        YValue::YType(__self_0) => {
                            YValue::YType(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for YValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YValue::JsonValueItem(e) => {
                            f.debug_tuple("YValue::JsonValueItem").field(e).finish()
                        }
                        YValue::YDoc(e) => {
                            f.debug_tuple("YValue::YDoc").field(e).finish()
                        }
                        YValue::YType(e) => {
                            f.debug_tuple("YValue::YType").field(e).finish()
                        }
                    }
                }
            }
            pub struct YArrayDeltaInsert {
                pub insert: wit_bindgen::rt::vec::Vec<YValue>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayDeltaInsert {
                #[inline]
                fn clone(&self) -> YArrayDeltaInsert {
                    YArrayDeltaInsert {
                        insert: ::core::clone::Clone::clone(&self.insert),
                    }
                }
            }
            impl ::core::fmt::Debug for YArrayDeltaInsert {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayDeltaInsert")
                        .field("insert", &self.insert)
                        .finish()
                }
            }
            pub enum YArrayDelta {
                YArrayDeltaInsert(YArrayDeltaInsert),
                YArrayDeltaDelete(YArrayDeltaDelete),
                YArrayDeltaRetain(YArrayDeltaRetain),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayDelta {
                #[inline]
                fn clone(&self) -> YArrayDelta {
                    match self {
                        YArrayDelta::YArrayDeltaInsert(__self_0) => {
                            YArrayDelta::YArrayDeltaInsert(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YArrayDelta::YArrayDeltaDelete(__self_0) => {
                            YArrayDelta::YArrayDeltaDelete(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YArrayDelta::YArrayDeltaRetain(__self_0) => {
                            YArrayDelta::YArrayDeltaRetain(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for YArrayDelta {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YArrayDelta::YArrayDeltaInsert(e) => {
                            f.debug_tuple("YArrayDelta::YArrayDeltaInsert")
                                .field(e)
                                .finish()
                        }
                        YArrayDelta::YArrayDeltaDelete(e) => {
                            f.debug_tuple("YArrayDelta::YArrayDeltaDelete")
                                .field(e)
                                .finish()
                        }
                        YArrayDelta::YArrayDeltaRetain(e) => {
                            f.debug_tuple("YArrayDelta::YArrayDeltaRetain")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            pub struct YArrayEvent {
                pub target: YArray,
                pub delta: wit_bindgen::rt::vec::Vec<YArrayDelta>,
                pub path: EventPath,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YArrayEvent {
                #[inline]
                fn clone(&self) -> YArrayEvent {
                    YArrayEvent {
                        target: ::core::clone::Clone::clone(&self.target),
                        delta: ::core::clone::Clone::clone(&self.delta),
                        path: ::core::clone::Clone::clone(&self.path),
                    }
                }
            }
            impl ::core::fmt::Debug for YArrayEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YArrayEvent")
                        .field("target", &self.target)
                        .field("delta", &self.delta)
                        .field("path", &self.path)
                        .finish()
                }
            }
            pub struct YMapDelta {
                pub action: YMapDeltaAction,
                pub old_value: Option<YValue>,
                pub new_value: Option<YValue>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YMapDelta {
                #[inline]
                fn clone(&self) -> YMapDelta {
                    YMapDelta {
                        action: ::core::clone::Clone::clone(&self.action),
                        old_value: ::core::clone::Clone::clone(&self.old_value),
                        new_value: ::core::clone::Clone::clone(&self.new_value),
                    }
                }
            }
            impl ::core::fmt::Debug for YMapDelta {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YMapDelta")
                        .field("action", &self.action)
                        .field("old-value", &self.old_value)
                        .field("new-value", &self.new_value)
                        .finish()
                }
            }
            pub struct YMapEvent {
                pub target: YMap,
                pub keys: wit_bindgen::rt::vec::Vec<
                    (wit_bindgen::rt::string::String, YMapDelta),
                >,
                pub path: EventPath,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YMapEvent {
                #[inline]
                fn clone(&self) -> YMapEvent {
                    YMapEvent {
                        target: ::core::clone::Clone::clone(&self.target),
                        keys: ::core::clone::Clone::clone(&self.keys),
                        path: ::core::clone::Clone::clone(&self.path),
                    }
                }
            }
            impl ::core::fmt::Debug for YMapEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YMapEvent")
                        .field("target", &self.target)
                        .field("keys", &self.keys)
                        .field("path", &self.path)
                        .finish()
                }
            }
            pub type JsonObject = JsonValueItem;
            pub type JsonArray = JsonValueItem;
            pub type TextAttrs = JsonObject;
            pub struct YTextDeltaInsert {
                pub insert: wit_bindgen::rt::string::String,
                pub attributes: Option<TextAttrs>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDeltaInsert {
                #[inline]
                fn clone(&self) -> YTextDeltaInsert {
                    YTextDeltaInsert {
                        insert: ::core::clone::Clone::clone(&self.insert),
                        attributes: ::core::clone::Clone::clone(&self.attributes),
                    }
                }
            }
            impl ::core::fmt::Debug for YTextDeltaInsert {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextDeltaInsert")
                        .field("insert", &self.insert)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            pub struct YTextDeltaRetain {
                pub retain: u32,
                pub attributes: Option<TextAttrs>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDeltaRetain {
                #[inline]
                fn clone(&self) -> YTextDeltaRetain {
                    YTextDeltaRetain {
                        retain: ::core::clone::Clone::clone(&self.retain),
                        attributes: ::core::clone::Clone::clone(&self.attributes),
                    }
                }
            }
            impl ::core::fmt::Debug for YTextDeltaRetain {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextDeltaRetain")
                        .field("retain", &self.retain)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            /// https://quilljs.com/docs/delta/
            pub enum YTextDelta {
                YTextDeltaInsert(YTextDeltaInsert),
                YTextDeltaDelete(YTextDeltaDelete),
                YTextDeltaRetain(YTextDeltaRetain),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextDelta {
                #[inline]
                fn clone(&self) -> YTextDelta {
                    match self {
                        YTextDelta::YTextDeltaInsert(__self_0) => {
                            YTextDelta::YTextDeltaInsert(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YTextDelta::YTextDeltaDelete(__self_0) => {
                            YTextDelta::YTextDeltaDelete(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        YTextDelta::YTextDeltaRetain(__self_0) => {
                            YTextDelta::YTextDeltaRetain(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for YTextDelta {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YTextDelta::YTextDeltaInsert(e) => {
                            f.debug_tuple("YTextDelta::YTextDeltaInsert")
                                .field(e)
                                .finish()
                        }
                        YTextDelta::YTextDeltaDelete(e) => {
                            f.debug_tuple("YTextDelta::YTextDeltaDelete")
                                .field(e)
                                .finish()
                        }
                        YTextDelta::YTextDeltaRetain(e) => {
                            f.debug_tuple("YTextDelta::YTextDeltaRetain")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            pub struct YTextEvent {
                pub target: YText,
                pub delta: wit_bindgen::rt::vec::Vec<YTextDelta>,
                pub path: EventPath,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YTextEvent {
                #[inline]
                fn clone(&self) -> YTextEvent {
                    YTextEvent {
                        target: ::core::clone::Clone::clone(&self.target),
                        delta: ::core::clone::Clone::clone(&self.delta),
                        path: ::core::clone::Clone::clone(&self.path),
                    }
                }
            }
            impl ::core::fmt::Debug for YTextEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YTextEvent")
                        .field("target", &self.target)
                        .field("delta", &self.delta)
                        .field("path", &self.path)
                        .finish()
                }
            }
            pub enum YEvent {
                YArrayEvent(YArrayEvent),
                YMapEvent(YMapEvent),
                YTextEvent(YTextEvent),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YEvent {
                #[inline]
                fn clone(&self) -> YEvent {
                    match self {
                        YEvent::YArrayEvent(__self_0) => {
                            YEvent::YArrayEvent(::core::clone::Clone::clone(__self_0))
                        }
                        YEvent::YMapEvent(__self_0) => {
                            YEvent::YMapEvent(::core::clone::Clone::clone(__self_0))
                        }
                        YEvent::YTextEvent(__self_0) => {
                            YEvent::YTextEvent(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for YEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YEvent::YArrayEvent(e) => {
                            f.debug_tuple("YEvent::YArrayEvent").field(e).finish()
                        }
                        YEvent::YMapEvent(e) => {
                            f.debug_tuple("YEvent::YMapEvent").field(e).finish()
                        }
                        YEvent::YTextEvent(e) => {
                            f.debug_tuple("YEvent::YTextEvent").field(e).finish()
                        }
                    }
                }
            }
            #[repr(u8)]
            pub enum YUndoKind {
                Undo,
                Redo,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YUndoKind {
                #[inline]
                fn clone(&self) -> YUndoKind {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for YUndoKind {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for YUndoKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for YUndoKind {
                #[inline]
                fn eq(&self, other: &YUndoKind) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for YUndoKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for YUndoKind {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            impl ::core::fmt::Debug for YUndoKind {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        YUndoKind::Undo => f.debug_tuple("YUndoKind::Undo").finish(),
                        YUndoKind::Redo => f.debug_tuple("YUndoKind::Redo").finish(),
                    }
                }
            }
            impl YUndoKind {
                pub(crate) unsafe fn _lift(val: u8) -> YUndoKind {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => YUndoKind::Undo,
                        1 => YUndoKind::Redo,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[repr(C)]
            pub struct StartLength {
                pub start: u32,
                pub length: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for StartLength {}
            #[automatically_derived]
            impl ::core::clone::Clone for StartLength {
                #[inline]
                fn clone(&self) -> StartLength {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            impl ::core::fmt::Debug for StartLength {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("StartLength")
                        .field("start", &self.start)
                        .field("length", &self.length)
                        .finish()
                }
            }
            pub struct StackItemSets {
                pub insertions: wit_bindgen::rt::vec::Vec<
                    (u64, wit_bindgen::rt::vec::Vec<StartLength>),
                >,
                pub deletions: wit_bindgen::rt::vec::Vec<
                    (u64, wit_bindgen::rt::vec::Vec<StartLength>),
                >,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for StackItemSets {
                #[inline]
                fn clone(&self) -> StackItemSets {
                    StackItemSets {
                        insertions: ::core::clone::Clone::clone(&self.insertions),
                        deletions: ::core::clone::Clone::clone(&self.deletions),
                    }
                }
            }
            impl ::core::fmt::Debug for StackItemSets {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("StackItemSets")
                        .field("insertions", &self.insertions)
                        .field("deletions", &self.deletions)
                        .finish()
                }
            }
            pub struct YUndoEvent {
                pub origin: Option<wit_bindgen::rt::vec::Vec<u8>>,
                pub kind: YUndoKind,
                pub stack_item: StackItemSets,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for YUndoEvent {
                #[inline]
                fn clone(&self) -> YUndoEvent {
                    YUndoEvent {
                        origin: ::core::clone::Clone::clone(&self.origin),
                        kind: ::core::clone::Clone::clone(&self.kind),
                        stack_item: ::core::clone::Clone::clone(&self.stack_item),
                    }
                }
            }
            impl ::core::fmt::Debug for YUndoEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("YUndoEvent")
                        .field("origin", &self.origin)
                        .field("kind", &self.kind)
                        .field("stack-item", &self.stack_item)
                        .finish()
                }
            }
        }
    }
}
pub mod exports {
    pub mod y_crdt_namespace {
        pub mod y_crdt {
            #[allow(clippy::all)]
            pub mod y_doc_methods {
                pub type EventObserver = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver;
                pub type YValue = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue;
                pub type YDoc = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc;
                pub type YTransaction = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction;
                pub type ReadTransaction = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction;
                pub type WriteTransaction = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction;
                pub type YText = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText;
                pub type YArray = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray;
                pub type YMap = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap;
                pub type YXmlFragment = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment;
                pub type YXmlElement = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement;
                pub type YXmlText = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText;
                pub type YTextDelta = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta;
                pub type YSnapshot = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot;
                pub type JsonObject = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonObject;
                pub type JsonArray = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArray;
                pub type JsonValueItem = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem;
                pub type TextAttrs = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::TextAttrs;
                pub type YType = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType;
                pub type Error = wit_bindgen::rt::string::String;
                pub type Origin = wit_bindgen::rt::vec::Vec<u8>;
                pub type ImplicitTransaction = Option<YTransaction>;
                #[repr(u8)]
                pub enum OffsetKind {
                    /// Compute editable strings length and offset using UTF-8 byte count.
                    Bytes,
                    /// Compute editable strings length and offset using UTF-16 chars count.
                    Utf16,
                    /// Compute editable strings length and offset using Unicode code points number.
                    Utf32,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for OffsetKind {
                    #[inline]
                    fn clone(&self) -> OffsetKind {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for OffsetKind {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for OffsetKind {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for OffsetKind {
                    #[inline]
                    fn eq(&self, other: &OffsetKind) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for OffsetKind {}
                #[automatically_derived]
                impl ::core::cmp::Eq for OffsetKind {
                    #[inline]
                    #[doc(hidden)]
                    #[no_coverage]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                impl ::core::fmt::Debug for OffsetKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            OffsetKind::Bytes => {
                                f.debug_tuple("OffsetKind::Bytes").finish()
                            }
                            OffsetKind::Utf16 => {
                                f.debug_tuple("OffsetKind::Utf16").finish()
                            }
                            OffsetKind::Utf32 => {
                                f.debug_tuple("OffsetKind::Utf32").finish()
                            }
                        }
                    }
                }
                impl OffsetKind {
                    pub(crate) unsafe fn _lift(val: u8) -> OffsetKind {
                        if !true {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => OffsetKind::Bytes,
                            1 => OffsetKind::Utf16,
                            2 => OffsetKind::Utf32,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("invalid enum discriminant"),
                                );
                            }
                        }
                    }
                }
                pub struct YDocOptions {
                    /// Globally unique client identifier. This value must be unique across all active collaborating
                    /// peers, otherwise a update collisions will happen, causing document store state to be corrupted.
                    ///
                    /// Default value: randomly generated.
                    pub client_id: Option<u64>,
                    /// A globally unique identifier for this document.
                    ///
                    /// Default value: randomly generated UUID v4.
                    pub guid: Option<wit_bindgen::rt::string::String>,
                    /// Associate this document with a collection. This only plays a role if your provider has
                    /// a concept of collection.
                    ///
                    /// Default value: `None`.
                    pub collection_id: Option<wit_bindgen::rt::string::String>,
                    /// How to we count offsets and lengths used in text operations.
                    ///
                    /// Default value: [OffsetKind::Bytes].
                    pub offset_kind: Option<OffsetKind>,
                    /// Determines if transactions commits should try to perform GC-ing of deleted items.
                    ///
                    /// Default value: `false`.
                    pub skip_gc: Option<bool>,
                    /// If a subdocument, automatically load document. If this is a subdocument, remote peers will
                    /// load the document as well automatically.
                    ///
                    /// Default value: `false`.
                    pub auto_load: Option<bool>,
                    /// Whether the document should be synced by the provider now.
                    /// This is toggled to true when you call ydoc.load().
                    ///
                    /// Default value: `true`.
                    pub should_load: Option<bool>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for YDocOptions {
                    #[inline]
                    fn clone(&self) -> YDocOptions {
                        YDocOptions {
                            client_id: ::core::clone::Clone::clone(&self.client_id),
                            guid: ::core::clone::Clone::clone(&self.guid),
                            collection_id: ::core::clone::Clone::clone(
                                &self.collection_id,
                            ),
                            offset_kind: ::core::clone::Clone::clone(&self.offset_kind),
                            skip_gc: ::core::clone::Clone::clone(&self.skip_gc),
                            auto_load: ::core::clone::Clone::clone(&self.auto_load),
                            should_load: ::core::clone::Clone::clone(&self.should_load),
                        }
                    }
                }
                impl ::core::fmt::Debug for YDocOptions {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("YDocOptions")
                            .field("client-id", &self.client_id)
                            .field("guid", &self.guid)
                            .field("collection-id", &self.collection_id)
                            .field("offset-kind", &self.offset_kind)
                            .field("skip-gc", &self.skip_gc)
                            .field("auto-load", &self.auto_load)
                            .field("should-load", &self.should_load)
                            .finish()
                    }
                }
                pub struct UndoManagerOptions {
                    /// Undo-/redo-able updates are grouped together in time-constrained snapshots. This field
                    /// determines the period of time, every snapshot will be automatically made in.
                    pub capture_timeout_millis: Option<u64>,
                    /// List of origins tracked by corresponding [UndoManager].
                    /// If provided, it will track only updates made within transactions of specific origin.
                    /// If not provided, it will track only updates made within transaction with no origin defined.
                    pub tracked_origins: Option<wit_bindgen::rt::vec::Vec<Origin>>,
                    /// Custom logic decider, that along with [tracked-origins] can be used to determine if
                    /// transaction changes should be captured or not.
                    pub capture_transaction: Option<bool>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for UndoManagerOptions {
                    #[inline]
                    fn clone(&self) -> UndoManagerOptions {
                        UndoManagerOptions {
                            capture_timeout_millis: ::core::clone::Clone::clone(
                                &self.capture_timeout_millis,
                            ),
                            tracked_origins: ::core::clone::Clone::clone(
                                &self.tracked_origins,
                            ),
                            capture_transaction: ::core::clone::Clone::clone(
                                &self.capture_transaction,
                            ),
                        }
                    }
                }
                impl ::core::fmt::Debug for UndoManagerOptions {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("UndoManagerOptions")
                            .field(
                                "capture-timeout-millis",
                                &self.capture_timeout_millis,
                            )
                            .field("tracked-origins", &self.tracked_origins)
                            .field("capture-transaction", &self.capture_transaction)
                            .finish()
                    }
                }
                #[repr(C)]
                pub struct UndoManagerRef {
                    pub ref_: u32,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for UndoManagerRef {}
                #[automatically_derived]
                impl ::core::clone::Clone for UndoManagerRef {
                    #[inline]
                    fn clone(&self) -> UndoManagerRef {
                        let _: ::core::clone::AssertParamIsClone<u32>;
                        *self
                    }
                }
                impl ::core::fmt::Debug for UndoManagerRef {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("UndoManagerRef")
                            .field("ref", &self.ref_)
                            .finish()
                    }
                }
                pub trait YDocMethods {
                    fn y_doc_dispose(ref_: YDoc) -> bool;
                    fn y_text_dispose(ref_: YText) -> bool;
                    fn y_array_dispose(ref_: YArray) -> bool;
                    fn y_map_dispose(ref_: YMap) -> bool;
                    fn y_xml_element_dispose(ref_: YXmlElement) -> bool;
                    fn y_xml_fragment_dispose(ref_: YXmlFragment) -> bool;
                    fn y_xml_text_dispose(ref_: YXmlText) -> bool;
                    fn y_transaction_dispose(ref_: YTransaction) -> bool;
                    fn y_value_dispose(ref_: YValue) -> bool;
                    fn y_snapshot_dispose(ref_: YSnapshot) -> bool;
                    fn undo_manager_dispose(ref_: UndoManagerRef) -> bool;
                    fn callback_dispose(ref_: EventObserver) -> bool;
                    fn y_doc_new(options: Option<YDocOptions>) -> YDoc;
                    fn y_doc_parent_doc(ref_: YDoc) -> Option<YDoc>;
                    fn y_doc_id(ref_: YDoc) -> u64;
                    fn y_doc_guid(ref_: YDoc) -> wit_bindgen::rt::string::String;
                    fn y_doc_read_transaction(ref_: YDoc) -> ReadTransaction;
                    fn y_doc_write_transaction(
                        ref_: YDoc,
                        origin: Origin,
                    ) -> WriteTransaction;
                    fn y_doc_text(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YText;
                    fn y_doc_array(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YArray;
                    fn y_doc_map(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YMap;
                    fn y_doc_xml_fragment(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YXmlFragment;
                    fn y_doc_xml_element(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YXmlElement;
                    fn y_doc_xml_text(
                        ref_: YDoc,
                        name: wit_bindgen::rt::string::String,
                    ) -> YXmlText;
                    fn y_doc_on_update_v1(ref_: YDoc, function_id: u32) -> EventObserver;
                    fn y_doc_load(ref_: YDoc, parent_txn: ImplicitTransaction);
                    fn y_doc_destroy(ref_: YDoc, parent_txn: ImplicitTransaction);
                    fn y_doc_subdocs(
                        ref_: YDoc,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<YDoc>;
                    fn y_doc_subdoc_guids(
                        ref_: YDoc,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<wit_bindgen::rt::string::String>;
                    fn encode_state_vector(ref_: YDoc) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn encode_state_as_update(
                        ref_: YDoc,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn encode_state_as_update_v2(
                        ref_: YDoc,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn apply_update(
                        ref_: YDoc,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                        origin: Origin,
                    ) -> Result<(), Error>;
                    fn apply_update_v2(
                        ref_: YDoc,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                        origin: Origin,
                    ) -> Result<(), Error>;
                    fn transaction_origin(txn: YTransaction) -> Option<Origin>;
                    fn transaction_commit(txn: YTransaction);
                    fn transaction_state_vector_v1(
                        txn: YTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn transaction_diff_v1(
                        txn: YTransaction,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn transaction_diff_v2(
                        txn: YTransaction,
                        vector: Option<wit_bindgen::rt::vec::Vec<u8>>,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn transaction_apply_v1(
                        txn: YTransaction,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<(), Error>;
                    fn transaction_apply_v2(
                        txn: YTransaction,
                        diff: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<(), Error>;
                    fn transaction_encode_update(
                        txn: YTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn transaction_encode_update_v2(
                        txn: YTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn y_text_new(
                        init: Option<wit_bindgen::rt::string::String>,
                    ) -> YText;
                    fn y_text_prelim(ref_: YText) -> bool;
                    fn y_text_length(ref_: YText, txn: ImplicitTransaction) -> u32;
                    fn y_text_to_string(
                        ref_: YText,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::string::String;
                    fn y_text_to_json(
                        ref_: YText,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::string::String;
                    fn y_text_insert(
                        ref_: YText,
                        index: u32,
                        chunk: wit_bindgen::rt::string::String,
                        attributes: Option<TextAttrs>,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_insert_embed(
                        ref_: YText,
                        index: u32,
                        embed: JsonValueItem,
                        attributes: Option<TextAttrs>,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_format(
                        ref_: YText,
                        index: u32,
                        length: u32,
                        attributes: TextAttrs,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_push(
                        ref_: YText,
                        chunk: wit_bindgen::rt::string::String,
                        attributes: Option<TextAttrs>,
                        txn: ImplicitTransaction,
                    );
                    fn y_text_delete(
                        ref_: YText,
                        index: u32,
                        length: u32,
                        txn: ImplicitTransaction,
                    );
                    /// https://quilljs.com/docs/delta/
                    /// TODO: implement compute_ychange: Option<Function>,
                    fn y_text_to_delta(
                        ref_: YText,
                        snapshot: Option<YSnapshot>,
                        prev_snapshot: Option<YSnapshot>,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<YTextDelta>;
                    fn y_text_observe(ref_: YText, function_id: u32) -> EventObserver;
                    fn y_text_observe_deep(
                        ref_: YText,
                        function_id: u32,
                    ) -> EventObserver;
                    fn snapshot(doc: YDoc) -> YSnapshot;
                    fn equal_snapshot(left: YSnapshot, right: YSnapshot) -> bool;
                    fn encode_snapshot_v1(
                        snapshot: YSnapshot,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn encode_snapshot_v2(
                        snapshot: YSnapshot,
                    ) -> wit_bindgen::rt::vec::Vec<u8>;
                    fn decode_snapshot_v1(
                        snapshot: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<YSnapshot, Error>;
                    fn decode_snapshot_v2(
                        snapshot: wit_bindgen::rt::vec::Vec<u8>,
                    ) -> Result<YSnapshot, Error>;
                    fn encode_state_from_snapshot_v1(
                        doc: YDoc,
                        snapshot: YSnapshot,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn encode_state_from_snapshot_v2(
                        doc: YDoc,
                        snapshot: YSnapshot,
                    ) -> Result<wit_bindgen::rt::vec::Vec<u8>, Error>;
                    fn y_array_new(init: Option<JsonArray>) -> YArray;
                    fn y_array_prelim(ref_: YArray) -> bool;
                    fn y_array_length(ref_: YArray, txn: ImplicitTransaction) -> u32;
                    fn y_array_to_json(
                        ref_: YArray,
                        txn: ImplicitTransaction,
                    ) -> JsonValueItem;
                    fn y_array_insert(
                        ref_: YArray,
                        index: u32,
                        items: JsonArray,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_push(
                        ref_: YArray,
                        items: JsonArray,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_delete(
                        ref_: YArray,
                        index: u32,
                        length: u32,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_move_content(
                        ref_: YArray,
                        source: u32,
                        target: u32,
                        txn: ImplicitTransaction,
                    );
                    fn y_array_get(
                        ref_: YArray,
                        index: u32,
                        txn: ImplicitTransaction,
                    ) -> Result<YValue, Error>;
                    fn y_array_values(
                        ref_: YArray,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<YValue>;
                    fn y_array_observe(ref_: YArray, function_id: u32) -> EventObserver;
                    fn y_array_observe_deep(
                        ref_: YArray,
                        function_id: u32,
                    ) -> EventObserver;
                    fn y_map_new(init: Option<JsonObject>) -> YMap;
                    fn y_map_prelim(ref_: YMap) -> bool;
                    fn y_map_length(ref_: YMap, txn: ImplicitTransaction) -> u32;
                    fn y_map_to_json(
                        ref_: YMap,
                        txn: ImplicitTransaction,
                    ) -> JsonValueItem;
                    fn y_map_set(
                        ref_: YMap,
                        key: wit_bindgen::rt::string::String,
                        value: JsonValueItem,
                        txn: ImplicitTransaction,
                    );
                    fn y_map_delete(
                        ref_: YMap,
                        key: wit_bindgen::rt::string::String,
                        txn: ImplicitTransaction,
                    );
                    fn y_map_get(
                        ref_: YMap,
                        key: wit_bindgen::rt::string::String,
                        txn: ImplicitTransaction,
                    ) -> Option<YValue>;
                    fn y_map_entries(
                        ref_: YMap,
                        txn: ImplicitTransaction,
                    ) -> wit_bindgen::rt::vec::Vec<
                        (wit_bindgen::rt::string::String, YValue),
                    >;
                    fn y_map_observe(ref_: YMap, function_id: u32) -> EventObserver;
                    fn y_map_observe_deep(ref_: YMap, function_id: u32) -> EventObserver;
                    fn y_xml_element_name(
                        ref_: YXmlElement,
                    ) -> Option<wit_bindgen::rt::string::String>;
                    fn y_xml_element_length(
                        ref_: YXmlElement,
                        txn: ImplicitTransaction,
                    ) -> u32;
                    fn y_xml_element_insert_xml_element(
                        ref_: YXmlElement,
                        index: u32,
                        name: wit_bindgen::rt::string::String,
                        txn: ImplicitTransaction,
                    ) -> YXmlElement;
                    fn y_xml_element_insert_xml_text(
                        ref_: YXmlElement,
                        index: u32,
                        txn: ImplicitTransaction,
                    ) -> YXmlText;
                    fn y_xml_element_delete(
                        ref_: YXmlElement,
                        index: u32,
                        length: u32,
                        txn: ImplicitTransaction,
                    );
                    fn y_xml_fragment_name(
                        ref_: YXmlFragment,
                    ) -> Option<wit_bindgen::rt::string::String>;
                    fn y_xml_fragment_length(
                        ref_: YXmlFragment,
                        txn: ImplicitTransaction,
                    ) -> u32;
                    fn y_xml_text_length(
                        ref_: YXmlText,
                        txn: ImplicitTransaction,
                    ) -> u32;
                    fn undo_manager_new(
                        doc: YDoc,
                        scope: YType,
                        options: UndoManagerOptions,
                    ) -> UndoManagerRef;
                    fn undo_manager_add_to_scope(
                        ref_: UndoManagerRef,
                        ytypes: wit_bindgen::rt::vec::Vec<YType>,
                    );
                    fn undo_manager_add_tracked_origin(
                        ref_: UndoManagerRef,
                        origin: Origin,
                    );
                    fn undo_manager_remove_tracked_origin(
                        ref_: UndoManagerRef,
                        origin: Origin,
                    );
                    fn undo_manager_clear(ref_: UndoManagerRef) -> Result<(), Error>;
                    fn undo_manager_stop_capturing(ref_: UndoManagerRef);
                    fn undo_manager_undo(ref_: UndoManagerRef) -> Result<bool, Error>;
                    fn undo_manager_redo(ref_: UndoManagerRef) -> Result<bool, Error>;
                    fn undo_manager_can_undo(ref_: UndoManagerRef) -> bool;
                    fn undo_manager_can_redo(ref_: UndoManagerRef) -> bool;
                    fn undo_manager_on_item_added(
                        ref_: UndoManagerRef,
                        function_id: u32,
                    ) -> EventObserver;
                    fn undo_manager_on_item_popped(
                        ref_: UndoManagerRef,
                        function_id: u32,
                    ) -> EventObserver;
                }
                use super::super::super::super::WitImplementation as YDocMethodsImpl;
                const _: () = {
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_doc_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_text_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_array_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_map_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_element_dispose(
                        arg0: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_xml_element_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_fragment_dispose(
                        arg0: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_xml_fragment_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-text-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_text_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_xml_text_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-transaction-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_transaction_dispose(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_transaction_dispose(
                            v0,
                        );
                        match result1 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-value-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_value_dispose(
                        arg0: i32,
                        arg1: i32,
                        arg2: i64,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue as V41;
                        let v41 = match arg0 {
                            0 => {
                                let e41 = {
                                    use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V2;
                                    let v2 = match arg1 {
                                        0 => V2::Null,
                                        1 => V2::Undefined,
                                        2 => {
                                            let e2 = wit_bindgen::rt::bool_lift(arg2 as i32 as u8);
                                            V2::Boolean(e2)
                                        }
                                        3 => {
                                            let e2 = f64::from_bits(arg2 as u64);
                                            V2::Number(e2)
                                        }
                                        4 => {
                                            let e2 = arg2;
                                            V2::BigInt(e2)
                                        }
                                        5 => {
                                            let e2 = {
                                                let len0 = arg3 as usize;
                                                let bytes0 = Vec::from_raw_parts(
                                                    arg2 as i32 as *mut _,
                                                    len0,
                                                    len0,
                                                );
                                                wit_bindgen::rt::string_lift(bytes0)
                                            };
                                            V2::Str(e2)
                                        }
                                        6 => {
                                            let e2 = {
                                                let len1 = arg3 as usize;
                                                Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                            };
                                            V2::Buffer(e2)
                                        }
                                        7 => {
                                            let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                index: arg2 as i32 as u32,
                                            };
                                            V2::Array(e2)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &8) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                index: arg2 as i32 as u32,
                                            };
                                            V2::Map(e2)
                                        }
                                    };
                                    let base19 = arg4;
                                    let len19 = arg5;
                                    let mut result19 = Vec::with_capacity(len19 as usize);
                                    for i in 0..len19 {
                                        let base = base19 + i * 8;
                                        let e19 = {
                                            let l3 = *((base + 0) as *const i32);
                                            let l4 = *((base + 4) as *const i32);
                                            let base18 = l3;
                                            let len18 = l4;
                                            let mut result18 = Vec::with_capacity(len18 as usize);
                                            for i in 0..len18 {
                                                let base = base18 + i * 16;
                                                let e18 = {
                                                    let l5 = i32::from(*((base + 0) as *const u8));
                                                    use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V17;
                                                    let v17 = match l5 {
                                                        0 => V17::Null,
                                                        1 => V17::Undefined,
                                                        2 => {
                                                            let e17 = {
                                                                let l6 = i32::from(*((base + 8) as *const u8));
                                                                wit_bindgen::rt::bool_lift(l6 as u8)
                                                            };
                                                            V17::Boolean(e17)
                                                        }
                                                        3 => {
                                                            let e17 = {
                                                                let l7 = *((base + 8) as *const f64);
                                                                l7
                                                            };
                                                            V17::Number(e17)
                                                        }
                                                        4 => {
                                                            let e17 = {
                                                                let l8 = *((base + 8) as *const i64);
                                                                l8
                                                            };
                                                            V17::BigInt(e17)
                                                        }
                                                        5 => {
                                                            let e17 = {
                                                                let l9 = *((base + 8) as *const i32);
                                                                let l10 = *((base + 12) as *const i32);
                                                                let len11 = l10 as usize;
                                                                let bytes11 = Vec::from_raw_parts(
                                                                    l9 as *mut _,
                                                                    len11,
                                                                    len11,
                                                                );
                                                                wit_bindgen::rt::string_lift(bytes11)
                                                            };
                                                            V17::Str(e17)
                                                        }
                                                        6 => {
                                                            let e17 = {
                                                                let l12 = *((base + 8) as *const i32);
                                                                let l13 = *((base + 12) as *const i32);
                                                                let len14 = l13 as usize;
                                                                Vec::from_raw_parts(l12 as *mut _, len14, len14)
                                                            };
                                                            V17::Buffer(e17)
                                                        }
                                                        7 => {
                                                            let e17 = {
                                                                let l15 = *((base + 8) as *const i32);
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: l15 as u32,
                                                                }
                                                            };
                                                            V17::Array(e17)
                                                        }
                                                        n => {
                                                            if true {
                                                                match (&n, &8) {
                                                                    (left_val, right_val) => {
                                                                        if !(*left_val == *right_val) {
                                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                                            ::core::panicking::assert_failed(
                                                                                kind,
                                                                                &*left_val,
                                                                                &*right_val,
                                                                                ::core::option::Option::Some(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                ),
                                                                            );
                                                                        }
                                                                    }
                                                                };
                                                            }
                                                            let e17 = {
                                                                let l16 = *((base + 8) as *const i32);
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: l16 as u32,
                                                                }
                                                            };
                                                            V17::Map(e17)
                                                        }
                                                    };
                                                    v17
                                                };
                                                result18.push(e18);
                                            }
                                            wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                            result18
                                        };
                                        result19.push(e19);
                                    }
                                    wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                                    let base39 = arg6;
                                    let len39 = arg7;
                                    let mut result39 = Vec::with_capacity(len39 as usize);
                                    for i in 0..len39 {
                                        let base = base39 + i * 8;
                                        let e39 = {
                                            let l20 = *((base + 0) as *const i32);
                                            let l21 = *((base + 4) as *const i32);
                                            let base38 = l20;
                                            let len38 = l21;
                                            let mut result38 = Vec::with_capacity(len38 as usize);
                                            for i in 0..len38 {
                                                let base = base38 + i * 24;
                                                let e38 = {
                                                    let l22 = *((base + 0) as *const i32);
                                                    let l23 = *((base + 4) as *const i32);
                                                    let len24 = l23 as usize;
                                                    let bytes24 = Vec::from_raw_parts(
                                                        l22 as *mut _,
                                                        len24,
                                                        len24,
                                                    );
                                                    let l25 = i32::from(*((base + 8) as *const u8));
                                                    use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V37;
                                                    let v37 = match l25 {
                                                        0 => V37::Null,
                                                        1 => V37::Undefined,
                                                        2 => {
                                                            let e37 = {
                                                                let l26 = i32::from(*((base + 16) as *const u8));
                                                                wit_bindgen::rt::bool_lift(l26 as u8)
                                                            };
                                                            V37::Boolean(e37)
                                                        }
                                                        3 => {
                                                            let e37 = {
                                                                let l27 = *((base + 16) as *const f64);
                                                                l27
                                                            };
                                                            V37::Number(e37)
                                                        }
                                                        4 => {
                                                            let e37 = {
                                                                let l28 = *((base + 16) as *const i64);
                                                                l28
                                                            };
                                                            V37::BigInt(e37)
                                                        }
                                                        5 => {
                                                            let e37 = {
                                                                let l29 = *((base + 16) as *const i32);
                                                                let l30 = *((base + 20) as *const i32);
                                                                let len31 = l30 as usize;
                                                                let bytes31 = Vec::from_raw_parts(
                                                                    l29 as *mut _,
                                                                    len31,
                                                                    len31,
                                                                );
                                                                wit_bindgen::rt::string_lift(bytes31)
                                                            };
                                                            V37::Str(e37)
                                                        }
                                                        6 => {
                                                            let e37 = {
                                                                let l32 = *((base + 16) as *const i32);
                                                                let l33 = *((base + 20) as *const i32);
                                                                let len34 = l33 as usize;
                                                                Vec::from_raw_parts(l32 as *mut _, len34, len34)
                                                            };
                                                            V37::Buffer(e37)
                                                        }
                                                        7 => {
                                                            let e37 = {
                                                                let l35 = *((base + 16) as *const i32);
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: l35 as u32,
                                                                }
                                                            };
                                                            V37::Array(e37)
                                                        }
                                                        n => {
                                                            if true {
                                                                match (&n, &8) {
                                                                    (left_val, right_val) => {
                                                                        if !(*left_val == *right_val) {
                                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                                            ::core::panicking::assert_failed(
                                                                                kind,
                                                                                &*left_val,
                                                                                &*right_val,
                                                                                ::core::option::Option::Some(
                                                                                    format_args!("invalid enum discriminant"),
                                                                                ),
                                                                            );
                                                                        }
                                                                    }
                                                                };
                                                            }
                                                            let e37 = {
                                                                let l36 = *((base + 16) as *const i32);
                                                                super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: l36 as u32,
                                                                }
                                                            };
                                                            V37::Map(e37)
                                                        }
                                                    };
                                                    (wit_bindgen::rt::string_lift(bytes24), v37)
                                                };
                                                result38.push(e38);
                                            }
                                            wit_bindgen::rt::dealloc(base38, (len38 as usize) * 24, 8);
                                            result38
                                        };
                                        result39.push(e39);
                                    }
                                    wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                        item: v2,
                                        array_references: result19,
                                        map_references: result39,
                                    }
                                };
                                V41::JsonValueItem(e41)
                            }
                            1 => {
                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                    ref_: arg1 as u32,
                                };
                                V41::YDoc(e41)
                            }
                            n => {
                                if true {
                                    match (&n, &2) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e41 = {
                                    use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType as V40;
                                    let v40 = match arg1 {
                                        0 => {
                                            let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                ref_: arg2 as i32 as u32,
                                            };
                                            V40::YText(e40)
                                        }
                                        1 => {
                                            let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                ref_: arg2 as i32 as u32,
                                            };
                                            V40::YArray(e40)
                                        }
                                        2 => {
                                            let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                ref_: arg2 as i32 as u32,
                                            };
                                            V40::YMap(e40)
                                        }
                                        3 => {
                                            let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                ref_: arg2 as i32 as u32,
                                            };
                                            V40::YXmlFragment(e40)
                                        }
                                        4 => {
                                            let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                ref_: arg2 as i32 as u32,
                                            };
                                            V40::YXmlElement(e40)
                                        }
                                        n => {
                                            if true {
                                                match (&n, &5) {
                                                    (left_val, right_val) => {
                                                        if !(*left_val == *right_val) {
                                                            let kind = ::core::panicking::AssertKind::Eq;
                                                            ::core::panicking::assert_failed(
                                                                kind,
                                                                &*left_val,
                                                                &*right_val,
                                                                ::core::option::Option::Some(
                                                                    format_args!("invalid enum discriminant"),
                                                                ),
                                                            );
                                                        }
                                                    }
                                                };
                                            }
                                            let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                ref_: arg2 as i32 as u32,
                                            };
                                            V40::YXmlText(e40)
                                        }
                                    };
                                    v40
                                };
                                V41::YType(e41)
                            }
                        };
                        let result42 = <YDocMethodsImpl as YDocMethods>::y_value_dispose(
                            v41,
                        );
                        match result42 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-snapshot-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_snapshot_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_snapshot_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_dispose(
                        arg0: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_dispose(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#callback-dispose"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_callback_dispose(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::callback_dispose(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-new"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_new(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let l0 = i32::from(*((arg0 + 0) as *const u8));
                        let result19 = <YDocMethodsImpl as YDocMethods>::y_doc_new(
                            match l0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l1 = i32::from(*((arg0 + 8) as *const u8));
                                        let l3 = i32::from(*((arg0 + 24) as *const u8));
                                        let l7 = i32::from(*((arg0 + 36) as *const u8));
                                        let l11 = i32::from(*((arg0 + 48) as *const u8));
                                        let l13 = i32::from(*((arg0 + 50) as *const u8));
                                        let l15 = i32::from(*((arg0 + 52) as *const u8));
                                        let l17 = i32::from(*((arg0 + 54) as *const u8));
                                        YDocOptions {
                                            client_id: match l1 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l2 = *((arg0 + 16) as *const i64);
                                                        l2 as u64
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                            guid: match l3 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l4 = *((arg0 + 28) as *const i32);
                                                        let l5 = *((arg0 + 32) as *const i32);
                                                        let len6 = l5 as usize;
                                                        let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                                                        wit_bindgen::rt::string_lift(bytes6)
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                            collection_id: match l7 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l8 = *((arg0 + 40) as *const i32);
                                                        let l9 = *((arg0 + 44) as *const i32);
                                                        let len10 = l9 as usize;
                                                        let bytes10 = Vec::from_raw_parts(
                                                            l8 as *mut _,
                                                            len10,
                                                            len10,
                                                        );
                                                        wit_bindgen::rt::string_lift(bytes10)
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                            offset_kind: match l11 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l12 = i32::from(*((arg0 + 49) as *const u8));
                                                        OffsetKind::_lift(l12 as u8)
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                            skip_gc: match l13 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l14 = i32::from(*((arg0 + 51) as *const u8));
                                                        wit_bindgen::rt::bool_lift(l14 as u8)
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                            auto_load: match l15 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l16 = i32::from(*((arg0 + 53) as *const u8));
                                                        wit_bindgen::rt::bool_lift(l16 as u8)
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                            should_load: match l17 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l18 = i32::from(*((arg0 + 55) as *const u8));
                                                        wit_bindgen::rt::bool_lift(l18 as u8)
                                                    };
                                                    Some(e)
                                                }
                                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            },
                                        }
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::dealloc(arg0, 56, 8);
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: ref_20,
                        } = result19;
                        wit_bindgen::rt::as_i32(ref_20)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-parent-doc"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_parent_doc(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_doc_parent_doc(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Some(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                    ref_: ref_2,
                                } = e;
                                *((ptr1 + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_2);
                            }
                            None => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            }
                        };
                        ptr1
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-id"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_id(arg0: i32) -> i64 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_doc_id(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        wit_bindgen::rt::as_i64(result0)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-guid"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_guid(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_doc_guid(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec2 = (result0.into_bytes()).into_boxed_slice();
                        let ptr2 = vec2.as_ptr() as i32;
                        let len2 = vec2.len() as i32;
                        ::core::mem::forget(vec2);
                        *((ptr1 + 4) as *mut i32) = len2;
                        *((ptr1 + 0) as *mut i32) = ptr2;
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-doc-guid"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_doc_guid(arg0: i32) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-read-transaction"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_read_transaction(
                        arg0: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_doc_read_transaction(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-write-transaction"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_write_transaction(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_write_transaction(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-text"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_text(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_text(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-array"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_array(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_array(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-map"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_map(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_map(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-xml-fragment"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_xml_fragment(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_xml_fragment(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-xml-element"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_xml_element(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_xml_element(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-xml-text"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_xml_text(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_xml_text(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-on-update-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_on_update_v1(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_doc_on_update_v1(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-load"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_load(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::y_doc_load(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-destroy"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_destroy(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::y_doc_destroy(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-subdocs"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_subdocs(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_subdocs(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec3 = (result1).into_boxed_slice();
                        let ptr3 = vec3.as_ptr() as i32;
                        let len3 = vec3.len() as i32;
                        ::core::mem::forget(vec3);
                        *((ptr2 + 4) as *mut i32) = len3;
                        *((ptr2 + 0) as *mut i32) = ptr3;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-doc-subdocs"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_doc_subdocs(arg0: i32) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 4, 4);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-doc-subdoc-guids"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_doc_subdoc_guids(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_doc_subdoc_guids(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec4 = result1;
                        let len4 = vec4.len() as i32;
                        let layout4 = alloc::Layout::from_size_align_unchecked(
                            vec4.len() * 8,
                            4,
                        );
                        let result4 = if layout4.size() != 0 {
                            let ptr = alloc::alloc(layout4);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout4);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec4.into_iter().enumerate() {
                            let base = result4 as i32 + (i as i32) * 8;
                            {
                                let vec3 = (e.into_bytes()).into_boxed_slice();
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                ::core::mem::forget(vec3);
                                *((base + 4) as *mut i32) = len3;
                                *((base + 0) as *mut i32) = ptr3;
                            }
                        }
                        *((ptr2 + 4) as *mut i32) = len4;
                        *((ptr2 + 0) as *mut i32) = result4 as i32;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-doc-subdoc-guids"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_doc_subdoc_guids(
                            arg0: i32,
                        ) {
                            let l2 = *((arg0 + 0) as *const i32);
                            let l3 = *((arg0 + 4) as *const i32);
                            let base4 = l2;
                            let len4 = l3;
                            for i in 0..len4 {
                                let base = base4 + i * 8;
                                {
                                    let l0 = *((base + 0) as *const i32);
                                    let l1 = *((base + 4) as *const i32);
                                    wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
                                }
                            }
                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-vector"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_state_vector(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::encode_state_vector(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec2 = (result0).into_boxed_slice();
                        let ptr2 = vec2.as_ptr() as i32;
                        let len2 = vec2.len() as i32;
                        ::core::mem::forget(vec2);
                        *((ptr1 + 4) as *mut i32) = len2;
                        *((ptr1 + 0) as *mut i32) = ptr2;
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-vector"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_state_vector(
                            arg0: i32,
                        ) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_state_as_update(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::encode_state_as_update(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len0 = arg3 as usize;
                                        Vec::from_raw_parts(arg2 as *mut _, len0, len0)
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result1 {
                            Ok(e) => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                                let vec3 = (e).into_boxed_slice();
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                ::core::mem::forget(vec3);
                                *((ptr2 + 8) as *mut i32) = len3;
                                *((ptr2 + 4) as *mut i32) = ptr3;
                            }
                            Err(e) => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr2 + 8) as *mut i32) = len4;
                                *((ptr2 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_state_as_update(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                                _ => {
                                    let l4 = *((arg0 + 4) as *const i32);
                                    let l5 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_state_as_update_v2(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::encode_state_as_update_v2(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len0 = arg3 as usize;
                                        Vec::from_raw_parts(arg2 as *mut _, len0, len0)
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result1 {
                            Ok(e) => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                                let vec3 = (e).into_boxed_slice();
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                ::core::mem::forget(vec3);
                                *((ptr2 + 8) as *mut i32) = len3;
                                *((ptr2 + 4) as *mut i32) = ptr3;
                            }
                            Err(e) => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr2 + 8) as *mut i32) = len4;
                                *((ptr2 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-as-update-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_state_as_update_v2(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                                _ => {
                                    let l4 = *((arg0 + 4) as *const i32);
                                    let l5 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#apply-update"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_apply_update(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let len1 = arg4 as usize;
                        let result2 = <YDocMethodsImpl as YDocMethods>::apply_update(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                            Vec::from_raw_parts(arg3 as *mut _, len1, len1),
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Ok(_) => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                            }
                            Err(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr3 + 8) as *mut i32) = len4;
                                *((ptr3 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#apply-update"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_apply_update(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#apply-update-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_apply_update_v2(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let len1 = arg4 as usize;
                        let result2 = <YDocMethodsImpl as YDocMethods>::apply_update_v2(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                            Vec::from_raw_parts(arg3 as *mut _, len1, len1),
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Ok(_) => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                            }
                            Err(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr3 + 8) as *mut i32) = len4;
                                *((ptr3 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#apply-update-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_apply_update_v2(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-origin"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_origin(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result1 = <YDocMethodsImpl as YDocMethods>::transaction_origin(
                            v0,
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result1 {
                            Some(e) => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                                let vec3 = (e).into_boxed_slice();
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                ::core::mem::forget(vec3);
                                *((ptr2 + 8) as *mut i32) = len3;
                                *((ptr2 + 4) as *mut i32) = ptr3;
                            }
                            None => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            }
                        };
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-origin"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_origin(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-commit"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_commit(
                        arg0: i32,
                        arg1: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        <YDocMethodsImpl as YDocMethods>::transaction_commit(v0);
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-state-vector-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_state_vector_v1(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result1 = <YDocMethodsImpl as YDocMethods>::transaction_state_vector_v1(
                            v0,
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec3 = (result1).into_boxed_slice();
                        let ptr3 = vec3.as_ptr() as i32;
                        let len3 = vec3.len() as i32;
                        ::core::mem::forget(vec3);
                        *((ptr2 + 4) as *mut i32) = len3;
                        *((ptr2 + 0) as *mut i32) = ptr3;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-state-vector-v1"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_state_vector_v1(
                            arg0: i32,
                        ) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_diff_v1(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result2 = <YDocMethodsImpl as YDocMethods>::transaction_diff_v1(
                            v0,
                            match arg2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg4 as usize;
                                        Vec::from_raw_parts(arg3 as *mut _, len1, len1)
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Ok(e) => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                                let vec4 = (e).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr3 + 8) as *mut i32) = len4;
                                *((ptr3 + 4) as *mut i32) = ptr4;
                            }
                            Err(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                let vec5 = (e.into_bytes()).into_boxed_slice();
                                let ptr5 = vec5.as_ptr() as i32;
                                let len5 = vec5.len() as i32;
                                ::core::mem::forget(vec5);
                                *((ptr3 + 8) as *mut i32) = len5;
                                *((ptr3 + 4) as *mut i32) = ptr5;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v1"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_diff_v1(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                                _ => {
                                    let l4 = *((arg0 + 4) as *const i32);
                                    let l5 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_diff_v2(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result2 = <YDocMethodsImpl as YDocMethods>::transaction_diff_v2(
                            v0,
                            match arg2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg4 as usize;
                                        Vec::from_raw_parts(arg3 as *mut _, len1, len1)
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Ok(e) => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                                let vec4 = (e).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr3 + 8) as *mut i32) = len4;
                                *((ptr3 + 4) as *mut i32) = ptr4;
                            }
                            Err(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                let vec5 = (e.into_bytes()).into_boxed_slice();
                                let ptr5 = vec5.as_ptr() as i32;
                                let len5 = vec5.len() as i32;
                                ::core::mem::forget(vec5);
                                *((ptr3 + 8) as *mut i32) = len5;
                                *((ptr3 + 4) as *mut i32) = ptr5;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-diff-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_diff_v2(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                                _ => {
                                    let l4 = *((arg0 + 4) as *const i32);
                                    let l5 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_apply_v1(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let len1 = arg3 as usize;
                        let result2 = <YDocMethodsImpl as YDocMethods>::transaction_apply_v1(
                            v0,
                            Vec::from_raw_parts(arg2 as *mut _, len1, len1),
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Ok(_) => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                            }
                            Err(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr3 + 8) as *mut i32) = len4;
                                *((ptr3 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v1"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_apply_v1(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_apply_v2(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let len1 = arg3 as usize;
                        let result2 = <YDocMethodsImpl as YDocMethods>::transaction_apply_v2(
                            v0,
                            Vec::from_raw_parts(arg2 as *mut _, len1, len1),
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Ok(_) => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                            }
                            Err(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr3 + 8) as *mut i32) = len4;
                                *((ptr3 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-apply-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_apply_v2(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_encode_update(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result1 = <YDocMethodsImpl as YDocMethods>::transaction_encode_update(
                            v0,
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec3 = (result1).into_boxed_slice();
                        let ptr3 = vec3.as_ptr() as i32;
                        let len3 = vec3.len() as i32;
                        ::core::mem::forget(vec3);
                        *((ptr2 + 4) as *mut i32) = len3;
                        *((ptr2 + 0) as *mut i32) = ptr3;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_encode_update(
                            arg0: i32,
                        ) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_transaction_encode_update_v2(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                        let v0 = match arg0 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::ReadTransaction(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &1) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                    ref_: arg1 as u32,
                                };
                                V0::WriteTransaction(e0)
                            }
                        };
                        let result1 = <YDocMethodsImpl as YDocMethods>::transaction_encode_update_v2(
                            v0,
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec3 = (result1).into_boxed_slice();
                        let ptr3 = vec3.as_ptr() as i32;
                        let len3 = vec3.len() as i32;
                        ::core::mem::forget(vec3);
                        *((ptr2 + 4) as *mut i32) = len3;
                        *((ptr2 + 0) as *mut i32) = ptr3;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#transaction-encode-update-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_transaction_encode_update_v2(
                            arg0: i32,
                        ) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-new"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_new(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_text_new(
                            match arg0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len0 = arg2 as usize;
                                        let bytes0 = Vec::from_raw_parts(
                                            arg1 as *mut _,
                                            len0,
                                            len0,
                                        );
                                        wit_bindgen::rt::string_lift(bytes0)
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-prelim"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_prelim(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_text_prelim(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-length"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_length(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_text_length(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::as_i32(result1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-string"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_to_string(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_text_to_string(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec3 = (result1.into_bytes()).into_boxed_slice();
                        let ptr3 = vec3.as_ptr() as i32;
                        let len3 = vec3.len() as i32;
                        ::core::mem::forget(vec3);
                        *((ptr2 + 4) as *mut i32) = len3;
                        *((ptr2 + 0) as *mut i32) = ptr3;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-string"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_text_to_string(arg0: i32) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-json"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_to_json(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_text_to_json(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec3 = (result1.into_bytes()).into_boxed_slice();
                        let ptr3 = vec3.as_ptr() as i32;
                        let len3 = vec3.len() as i32;
                        ::core::mem::forget(vec3);
                        *((ptr2 + 4) as *mut i32) = len3;
                        *((ptr2 + 0) as *mut i32) = ptr3;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-json"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_text_to_json(arg0: i32) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-insert"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_insert(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i64,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                        arg10: i32,
                        arg11: i32,
                        arg12: i32,
                        arg13: i32,
                        arg14: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg3 as usize;
                        let bytes0 = Vec::from_raw_parts(arg2 as *mut _, len0, len0);
                        <YDocMethodsImpl as YDocMethods>::y_text_insert(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            wit_bindgen::rt::string_lift(bytes0),
                            match arg4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V3;
                                        let v3 = match arg5 {
                                            0 => V3::Null,
                                            1 => V3::Undefined,
                                            2 => {
                                                let e3 = wit_bindgen::rt::bool_lift(arg6 as i32 as u8);
                                                V3::Boolean(e3)
                                            }
                                            3 => {
                                                let e3 = f64::from_bits(arg6 as u64);
                                                V3::Number(e3)
                                            }
                                            4 => {
                                                let e3 = arg6;
                                                V3::BigInt(e3)
                                            }
                                            5 => {
                                                let e3 = {
                                                    let len1 = arg7 as usize;
                                                    let bytes1 = Vec::from_raw_parts(
                                                        arg6 as i32 as *mut _,
                                                        len1,
                                                        len1,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes1)
                                                };
                                                V3::Str(e3)
                                            }
                                            6 => {
                                                let e3 = {
                                                    let len2 = arg7 as usize;
                                                    Vec::from_raw_parts(arg6 as i32 as *mut _, len2, len2)
                                                };
                                                V3::Buffer(e3)
                                            }
                                            7 => {
                                                let e3 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: arg6 as i32 as u32,
                                                };
                                                V3::Array(e3)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e3 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: arg6 as i32 as u32,
                                                };
                                                V3::Map(e3)
                                            }
                                        };
                                        let base20 = arg8;
                                        let len20 = arg9;
                                        let mut result20 = Vec::with_capacity(len20 as usize);
                                        for i in 0..len20 {
                                            let base = base20 + i * 8;
                                            let e20 = {
                                                let l4 = *((base + 0) as *const i32);
                                                let l5 = *((base + 4) as *const i32);
                                                let base19 = l4;
                                                let len19 = l5;
                                                let mut result19 = Vec::with_capacity(len19 as usize);
                                                for i in 0..len19 {
                                                    let base = base19 + i * 16;
                                                    let e19 = {
                                                        let l6 = i32::from(*((base + 0) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V18;
                                                        let v18 = match l6 {
                                                            0 => V18::Null,
                                                            1 => V18::Undefined,
                                                            2 => {
                                                                let e18 = {
                                                                    let l7 = i32::from(*((base + 8) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l7 as u8)
                                                                };
                                                                V18::Boolean(e18)
                                                            }
                                                            3 => {
                                                                let e18 = {
                                                                    let l8 = *((base + 8) as *const f64);
                                                                    l8
                                                                };
                                                                V18::Number(e18)
                                                            }
                                                            4 => {
                                                                let e18 = {
                                                                    let l9 = *((base + 8) as *const i64);
                                                                    l9
                                                                };
                                                                V18::BigInt(e18)
                                                            }
                                                            5 => {
                                                                let e18 = {
                                                                    let l10 = *((base + 8) as *const i32);
                                                                    let l11 = *((base + 12) as *const i32);
                                                                    let len12 = l11 as usize;
                                                                    let bytes12 = Vec::from_raw_parts(
                                                                        l10 as *mut _,
                                                                        len12,
                                                                        len12,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes12)
                                                                };
                                                                V18::Str(e18)
                                                            }
                                                            6 => {
                                                                let e18 = {
                                                                    let l13 = *((base + 8) as *const i32);
                                                                    let l14 = *((base + 12) as *const i32);
                                                                    let len15 = l14 as usize;
                                                                    Vec::from_raw_parts(l13 as *mut _, len15, len15)
                                                                };
                                                                V18::Buffer(e18)
                                                            }
                                                            7 => {
                                                                let e18 = {
                                                                    let l16 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l16 as u32,
                                                                    }
                                                                };
                                                                V18::Array(e18)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e18 = {
                                                                    let l17 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l17 as u32,
                                                                    }
                                                                };
                                                                V18::Map(e18)
                                                            }
                                                        };
                                                        v18
                                                    };
                                                    result19.push(e19);
                                                }
                                                wit_bindgen::rt::dealloc(base19, (len19 as usize) * 16, 8);
                                                result19
                                            };
                                            result20.push(e20);
                                        }
                                        wit_bindgen::rt::dealloc(base20, (len20 as usize) * 8, 4);
                                        let base40 = arg10;
                                        let len40 = arg11;
                                        let mut result40 = Vec::with_capacity(len40 as usize);
                                        for i in 0..len40 {
                                            let base = base40 + i * 8;
                                            let e40 = {
                                                let l21 = *((base + 0) as *const i32);
                                                let l22 = *((base + 4) as *const i32);
                                                let base39 = l21;
                                                let len39 = l22;
                                                let mut result39 = Vec::with_capacity(len39 as usize);
                                                for i in 0..len39 {
                                                    let base = base39 + i * 24;
                                                    let e39 = {
                                                        let l23 = *((base + 0) as *const i32);
                                                        let l24 = *((base + 4) as *const i32);
                                                        let len25 = l24 as usize;
                                                        let bytes25 = Vec::from_raw_parts(
                                                            l23 as *mut _,
                                                            len25,
                                                            len25,
                                                        );
                                                        let l26 = i32::from(*((base + 8) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V38;
                                                        let v38 = match l26 {
                                                            0 => V38::Null,
                                                            1 => V38::Undefined,
                                                            2 => {
                                                                let e38 = {
                                                                    let l27 = i32::from(*((base + 16) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l27 as u8)
                                                                };
                                                                V38::Boolean(e38)
                                                            }
                                                            3 => {
                                                                let e38 = {
                                                                    let l28 = *((base + 16) as *const f64);
                                                                    l28
                                                                };
                                                                V38::Number(e38)
                                                            }
                                                            4 => {
                                                                let e38 = {
                                                                    let l29 = *((base + 16) as *const i64);
                                                                    l29
                                                                };
                                                                V38::BigInt(e38)
                                                            }
                                                            5 => {
                                                                let e38 = {
                                                                    let l30 = *((base + 16) as *const i32);
                                                                    let l31 = *((base + 20) as *const i32);
                                                                    let len32 = l31 as usize;
                                                                    let bytes32 = Vec::from_raw_parts(
                                                                        l30 as *mut _,
                                                                        len32,
                                                                        len32,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes32)
                                                                };
                                                                V38::Str(e38)
                                                            }
                                                            6 => {
                                                                let e38 = {
                                                                    let l33 = *((base + 16) as *const i32);
                                                                    let l34 = *((base + 20) as *const i32);
                                                                    let len35 = l34 as usize;
                                                                    Vec::from_raw_parts(l33 as *mut _, len35, len35)
                                                                };
                                                                V38::Buffer(e38)
                                                            }
                                                            7 => {
                                                                let e38 = {
                                                                    let l36 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l36 as u32,
                                                                    }
                                                                };
                                                                V38::Array(e38)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e38 = {
                                                                    let l37 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l37 as u32,
                                                                    }
                                                                };
                                                                V38::Map(e38)
                                                            }
                                                        };
                                                        (wit_bindgen::rt::string_lift(bytes25), v38)
                                                    };
                                                    result39.push(e39);
                                                }
                                                wit_bindgen::rt::dealloc(base39, (len39 as usize) * 24, 8);
                                                result39
                                            };
                                            result40.push(e40);
                                        }
                                        wit_bindgen::rt::dealloc(base40, (len40 as usize) * 8, 4);
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: v3,
                                            array_references: result20,
                                            map_references: result40,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                            match arg12 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V41;
                                        let v41 = match arg13 {
                                            0 => {
                                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg14 as u32,
                                                };
                                                V41::ReadTransaction(e41)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg14 as u32,
                                                };
                                                V41::WriteTransaction(e41)
                                            }
                                        };
                                        v41
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-insert-embed"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_insert_embed(arg0: i32) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let l0 = *((arg0 + 0) as *const i32);
                        let l1 = *((arg0 + 4) as *const i32);
                        let l2 = i32::from(*((arg0 + 8) as *const u8));
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V14;
                        let v14 = match l2 {
                            0 => V14::Null,
                            1 => V14::Undefined,
                            2 => {
                                let e14 = {
                                    let l3 = i32::from(*((arg0 + 16) as *const u8));
                                    wit_bindgen::rt::bool_lift(l3 as u8)
                                };
                                V14::Boolean(e14)
                            }
                            3 => {
                                let e14 = {
                                    let l4 = *((arg0 + 16) as *const f64);
                                    l4
                                };
                                V14::Number(e14)
                            }
                            4 => {
                                let e14 = {
                                    let l5 = *((arg0 + 16) as *const i64);
                                    l5
                                };
                                V14::BigInt(e14)
                            }
                            5 => {
                                let e14 = {
                                    let l6 = *((arg0 + 16) as *const i32);
                                    let l7 = *((arg0 + 20) as *const i32);
                                    let len8 = l7 as usize;
                                    let bytes8 = Vec::from_raw_parts(l6 as *mut _, len8, len8);
                                    wit_bindgen::rt::string_lift(bytes8)
                                };
                                V14::Str(e14)
                            }
                            6 => {
                                let e14 = {
                                    let l9 = *((arg0 + 16) as *const i32);
                                    let l10 = *((arg0 + 20) as *const i32);
                                    let len11 = l10 as usize;
                                    Vec::from_raw_parts(l9 as *mut _, len11, len11)
                                };
                                V14::Buffer(e14)
                            }
                            7 => {
                                let e14 = {
                                    let l12 = *((arg0 + 16) as *const i32);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                        index: l12 as u32,
                                    }
                                };
                                V14::Array(e14)
                            }
                            n => {
                                if true {
                                    match (&n, &8) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e14 = {
                                    let l13 = *((arg0 + 16) as *const i32);
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                        index: l13 as u32,
                                    }
                                };
                                V14::Map(e14)
                            }
                        };
                        let l15 = *((arg0 + 24) as *const i32);
                        let l16 = *((arg0 + 28) as *const i32);
                        let base33 = l15;
                        let len33 = l16;
                        let mut result33 = Vec::with_capacity(len33 as usize);
                        for i in 0..len33 {
                            let base = base33 + i * 8;
                            let e33 = {
                                let l17 = *((base + 0) as *const i32);
                                let l18 = *((base + 4) as *const i32);
                                let base32 = l17;
                                let len32 = l18;
                                let mut result32 = Vec::with_capacity(len32 as usize);
                                for i in 0..len32 {
                                    let base = base32 + i * 16;
                                    let e32 = {
                                        let l19 = i32::from(*((base + 0) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V31;
                                        let v31 = match l19 {
                                            0 => V31::Null,
                                            1 => V31::Undefined,
                                            2 => {
                                                let e31 = {
                                                    let l20 = i32::from(*((base + 8) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l20 as u8)
                                                };
                                                V31::Boolean(e31)
                                            }
                                            3 => {
                                                let e31 = {
                                                    let l21 = *((base + 8) as *const f64);
                                                    l21
                                                };
                                                V31::Number(e31)
                                            }
                                            4 => {
                                                let e31 = {
                                                    let l22 = *((base + 8) as *const i64);
                                                    l22
                                                };
                                                V31::BigInt(e31)
                                            }
                                            5 => {
                                                let e31 = {
                                                    let l23 = *((base + 8) as *const i32);
                                                    let l24 = *((base + 12) as *const i32);
                                                    let len25 = l24 as usize;
                                                    let bytes25 = Vec::from_raw_parts(
                                                        l23 as *mut _,
                                                        len25,
                                                        len25,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes25)
                                                };
                                                V31::Str(e31)
                                            }
                                            6 => {
                                                let e31 = {
                                                    let l26 = *((base + 8) as *const i32);
                                                    let l27 = *((base + 12) as *const i32);
                                                    let len28 = l27 as usize;
                                                    Vec::from_raw_parts(l26 as *mut _, len28, len28)
                                                };
                                                V31::Buffer(e31)
                                            }
                                            7 => {
                                                let e31 = {
                                                    let l29 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l29 as u32,
                                                    }
                                                };
                                                V31::Array(e31)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e31 = {
                                                    let l30 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l30 as u32,
                                                    }
                                                };
                                                V31::Map(e31)
                                            }
                                        };
                                        v31
                                    };
                                    result32.push(e32);
                                }
                                wit_bindgen::rt::dealloc(base32, (len32 as usize) * 16, 8);
                                result32
                            };
                            result33.push(e33);
                        }
                        wit_bindgen::rt::dealloc(base33, (len33 as usize) * 8, 4);
                        let l34 = *((arg0 + 32) as *const i32);
                        let l35 = *((arg0 + 36) as *const i32);
                        let base55 = l34;
                        let len55 = l35;
                        let mut result55 = Vec::with_capacity(len55 as usize);
                        for i in 0..len55 {
                            let base = base55 + i * 8;
                            let e55 = {
                                let l36 = *((base + 0) as *const i32);
                                let l37 = *((base + 4) as *const i32);
                                let base54 = l36;
                                let len54 = l37;
                                let mut result54 = Vec::with_capacity(len54 as usize);
                                for i in 0..len54 {
                                    let base = base54 + i * 24;
                                    let e54 = {
                                        let l38 = *((base + 0) as *const i32);
                                        let l39 = *((base + 4) as *const i32);
                                        let len40 = l39 as usize;
                                        let bytes40 = Vec::from_raw_parts(
                                            l38 as *mut _,
                                            len40,
                                            len40,
                                        );
                                        let l41 = i32::from(*((base + 8) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V53;
                                        let v53 = match l41 {
                                            0 => V53::Null,
                                            1 => V53::Undefined,
                                            2 => {
                                                let e53 = {
                                                    let l42 = i32::from(*((base + 16) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l42 as u8)
                                                };
                                                V53::Boolean(e53)
                                            }
                                            3 => {
                                                let e53 = {
                                                    let l43 = *((base + 16) as *const f64);
                                                    l43
                                                };
                                                V53::Number(e53)
                                            }
                                            4 => {
                                                let e53 = {
                                                    let l44 = *((base + 16) as *const i64);
                                                    l44
                                                };
                                                V53::BigInt(e53)
                                            }
                                            5 => {
                                                let e53 = {
                                                    let l45 = *((base + 16) as *const i32);
                                                    let l46 = *((base + 20) as *const i32);
                                                    let len47 = l46 as usize;
                                                    let bytes47 = Vec::from_raw_parts(
                                                        l45 as *mut _,
                                                        len47,
                                                        len47,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes47)
                                                };
                                                V53::Str(e53)
                                            }
                                            6 => {
                                                let e53 = {
                                                    let l48 = *((base + 16) as *const i32);
                                                    let l49 = *((base + 20) as *const i32);
                                                    let len50 = l49 as usize;
                                                    Vec::from_raw_parts(l48 as *mut _, len50, len50)
                                                };
                                                V53::Buffer(e53)
                                            }
                                            7 => {
                                                let e53 = {
                                                    let l51 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l51 as u32,
                                                    }
                                                };
                                                V53::Array(e53)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e53 = {
                                                    let l52 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l52 as u32,
                                                    }
                                                };
                                                V53::Map(e53)
                                            }
                                        };
                                        (wit_bindgen::rt::string_lift(bytes40), v53)
                                    };
                                    result54.push(e54);
                                }
                                wit_bindgen::rt::dealloc(base54, (len54 as usize) * 24, 8);
                                result54
                            };
                            result55.push(e55);
                        }
                        wit_bindgen::rt::dealloc(base55, (len55 as usize) * 8, 4);
                        let l56 = i32::from(*((arg0 + 40) as *const u8));
                        let l111 = i32::from(*((arg0 + 80) as *const u8));
                        <YDocMethodsImpl as YDocMethods>::y_text_insert_embed(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: l0 as u32,
                            },
                            l1 as u32,
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                item: v14,
                                array_references: result33,
                                map_references: result55,
                            },
                            match l56 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l57 = i32::from(*((arg0 + 48) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V69;
                                        let v69 = match l57 {
                                            0 => V69::Null,
                                            1 => V69::Undefined,
                                            2 => {
                                                let e69 = {
                                                    let l58 = i32::from(*((arg0 + 56) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l58 as u8)
                                                };
                                                V69::Boolean(e69)
                                            }
                                            3 => {
                                                let e69 = {
                                                    let l59 = *((arg0 + 56) as *const f64);
                                                    l59
                                                };
                                                V69::Number(e69)
                                            }
                                            4 => {
                                                let e69 = {
                                                    let l60 = *((arg0 + 56) as *const i64);
                                                    l60
                                                };
                                                V69::BigInt(e69)
                                            }
                                            5 => {
                                                let e69 = {
                                                    let l61 = *((arg0 + 56) as *const i32);
                                                    let l62 = *((arg0 + 60) as *const i32);
                                                    let len63 = l62 as usize;
                                                    let bytes63 = Vec::from_raw_parts(
                                                        l61 as *mut _,
                                                        len63,
                                                        len63,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes63)
                                                };
                                                V69::Str(e69)
                                            }
                                            6 => {
                                                let e69 = {
                                                    let l64 = *((arg0 + 56) as *const i32);
                                                    let l65 = *((arg0 + 60) as *const i32);
                                                    let len66 = l65 as usize;
                                                    Vec::from_raw_parts(l64 as *mut _, len66, len66)
                                                };
                                                V69::Buffer(e69)
                                            }
                                            7 => {
                                                let e69 = {
                                                    let l67 = *((arg0 + 56) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l67 as u32,
                                                    }
                                                };
                                                V69::Array(e69)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e69 = {
                                                    let l68 = *((arg0 + 56) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l68 as u32,
                                                    }
                                                };
                                                V69::Map(e69)
                                            }
                                        };
                                        let l70 = *((arg0 + 64) as *const i32);
                                        let l71 = *((arg0 + 68) as *const i32);
                                        let base88 = l70;
                                        let len88 = l71;
                                        let mut result88 = Vec::with_capacity(len88 as usize);
                                        for i in 0..len88 {
                                            let base = base88 + i * 8;
                                            let e88 = {
                                                let l72 = *((base + 0) as *const i32);
                                                let l73 = *((base + 4) as *const i32);
                                                let base87 = l72;
                                                let len87 = l73;
                                                let mut result87 = Vec::with_capacity(len87 as usize);
                                                for i in 0..len87 {
                                                    let base = base87 + i * 16;
                                                    let e87 = {
                                                        let l74 = i32::from(*((base + 0) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V86;
                                                        let v86 = match l74 {
                                                            0 => V86::Null,
                                                            1 => V86::Undefined,
                                                            2 => {
                                                                let e86 = {
                                                                    let l75 = i32::from(*((base + 8) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l75 as u8)
                                                                };
                                                                V86::Boolean(e86)
                                                            }
                                                            3 => {
                                                                let e86 = {
                                                                    let l76 = *((base + 8) as *const f64);
                                                                    l76
                                                                };
                                                                V86::Number(e86)
                                                            }
                                                            4 => {
                                                                let e86 = {
                                                                    let l77 = *((base + 8) as *const i64);
                                                                    l77
                                                                };
                                                                V86::BigInt(e86)
                                                            }
                                                            5 => {
                                                                let e86 = {
                                                                    let l78 = *((base + 8) as *const i32);
                                                                    let l79 = *((base + 12) as *const i32);
                                                                    let len80 = l79 as usize;
                                                                    let bytes80 = Vec::from_raw_parts(
                                                                        l78 as *mut _,
                                                                        len80,
                                                                        len80,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes80)
                                                                };
                                                                V86::Str(e86)
                                                            }
                                                            6 => {
                                                                let e86 = {
                                                                    let l81 = *((base + 8) as *const i32);
                                                                    let l82 = *((base + 12) as *const i32);
                                                                    let len83 = l82 as usize;
                                                                    Vec::from_raw_parts(l81 as *mut _, len83, len83)
                                                                };
                                                                V86::Buffer(e86)
                                                            }
                                                            7 => {
                                                                let e86 = {
                                                                    let l84 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l84 as u32,
                                                                    }
                                                                };
                                                                V86::Array(e86)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e86 = {
                                                                    let l85 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l85 as u32,
                                                                    }
                                                                };
                                                                V86::Map(e86)
                                                            }
                                                        };
                                                        v86
                                                    };
                                                    result87.push(e87);
                                                }
                                                wit_bindgen::rt::dealloc(base87, (len87 as usize) * 16, 8);
                                                result87
                                            };
                                            result88.push(e88);
                                        }
                                        wit_bindgen::rt::dealloc(base88, (len88 as usize) * 8, 4);
                                        let l89 = *((arg0 + 72) as *const i32);
                                        let l90 = *((arg0 + 76) as *const i32);
                                        let base110 = l89;
                                        let len110 = l90;
                                        let mut result110 = Vec::with_capacity(len110 as usize);
                                        for i in 0..len110 {
                                            let base = base110 + i * 8;
                                            let e110 = {
                                                let l91 = *((base + 0) as *const i32);
                                                let l92 = *((base + 4) as *const i32);
                                                let base109 = l91;
                                                let len109 = l92;
                                                let mut result109 = Vec::with_capacity(len109 as usize);
                                                for i in 0..len109 {
                                                    let base = base109 + i * 24;
                                                    let e109 = {
                                                        let l93 = *((base + 0) as *const i32);
                                                        let l94 = *((base + 4) as *const i32);
                                                        let len95 = l94 as usize;
                                                        let bytes95 = Vec::from_raw_parts(
                                                            l93 as *mut _,
                                                            len95,
                                                            len95,
                                                        );
                                                        let l96 = i32::from(*((base + 8) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V108;
                                                        let v108 = match l96 {
                                                            0 => V108::Null,
                                                            1 => V108::Undefined,
                                                            2 => {
                                                                let e108 = {
                                                                    let l97 = i32::from(*((base + 16) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l97 as u8)
                                                                };
                                                                V108::Boolean(e108)
                                                            }
                                                            3 => {
                                                                let e108 = {
                                                                    let l98 = *((base + 16) as *const f64);
                                                                    l98
                                                                };
                                                                V108::Number(e108)
                                                            }
                                                            4 => {
                                                                let e108 = {
                                                                    let l99 = *((base + 16) as *const i64);
                                                                    l99
                                                                };
                                                                V108::BigInt(e108)
                                                            }
                                                            5 => {
                                                                let e108 = {
                                                                    let l100 = *((base + 16) as *const i32);
                                                                    let l101 = *((base + 20) as *const i32);
                                                                    let len102 = l101 as usize;
                                                                    let bytes102 = Vec::from_raw_parts(
                                                                        l100 as *mut _,
                                                                        len102,
                                                                        len102,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes102)
                                                                };
                                                                V108::Str(e108)
                                                            }
                                                            6 => {
                                                                let e108 = {
                                                                    let l103 = *((base + 16) as *const i32);
                                                                    let l104 = *((base + 20) as *const i32);
                                                                    let len105 = l104 as usize;
                                                                    Vec::from_raw_parts(l103 as *mut _, len105, len105)
                                                                };
                                                                V108::Buffer(e108)
                                                            }
                                                            7 => {
                                                                let e108 = {
                                                                    let l106 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l106 as u32,
                                                                    }
                                                                };
                                                                V108::Array(e108)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e108 = {
                                                                    let l107 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l107 as u32,
                                                                    }
                                                                };
                                                                V108::Map(e108)
                                                            }
                                                        };
                                                        (wit_bindgen::rt::string_lift(bytes95), v108)
                                                    };
                                                    result109.push(e109);
                                                }
                                                wit_bindgen::rt::dealloc(
                                                    base109,
                                                    (len109 as usize) * 24,
                                                    8,
                                                );
                                                result109
                                            };
                                            result110.push(e110);
                                        }
                                        wit_bindgen::rt::dealloc(base110, (len110 as usize) * 8, 4);
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: v69,
                                            array_references: result88,
                                            map_references: result110,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                            match l111 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l112 = i32::from(*((arg0 + 84) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V115;
                                        let v115 = match l112 {
                                            0 => {
                                                let e115 = {
                                                    let l113 = *((arg0 + 88) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                        ref_: l113 as u32,
                                                    }
                                                };
                                                V115::ReadTransaction(e115)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e115 = {
                                                    let l114 = *((arg0 + 88) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                        ref_: l114 as u32,
                                                    }
                                                };
                                                V115::WriteTransaction(e115)
                                            }
                                        };
                                        v115
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::dealloc(arg0, 96, 8);
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-format"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_format(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i64,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                        arg10: i32,
                        arg11: i32,
                        arg12: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V2;
                        let v2 = match arg3 {
                            0 => V2::Null,
                            1 => V2::Undefined,
                            2 => {
                                let e2 = wit_bindgen::rt::bool_lift(arg4 as i32 as u8);
                                V2::Boolean(e2)
                            }
                            3 => {
                                let e2 = f64::from_bits(arg4 as u64);
                                V2::Number(e2)
                            }
                            4 => {
                                let e2 = arg4;
                                V2::BigInt(e2)
                            }
                            5 => {
                                let e2 = {
                                    let len0 = arg5 as usize;
                                    let bytes0 = Vec::from_raw_parts(
                                        arg4 as i32 as *mut _,
                                        len0,
                                        len0,
                                    );
                                    wit_bindgen::rt::string_lift(bytes0)
                                };
                                V2::Str(e2)
                            }
                            6 => {
                                let e2 = {
                                    let len1 = arg5 as usize;
                                    Vec::from_raw_parts(arg4 as i32 as *mut _, len1, len1)
                                };
                                V2::Buffer(e2)
                            }
                            7 => {
                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                    index: arg4 as i32 as u32,
                                };
                                V2::Array(e2)
                            }
                            n => {
                                if true {
                                    match (&n, &8) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                    index: arg4 as i32 as u32,
                                };
                                V2::Map(e2)
                            }
                        };
                        let base19 = arg6;
                        let len19 = arg7;
                        let mut result19 = Vec::with_capacity(len19 as usize);
                        for i in 0..len19 {
                            let base = base19 + i * 8;
                            let e19 = {
                                let l3 = *((base + 0) as *const i32);
                                let l4 = *((base + 4) as *const i32);
                                let base18 = l3;
                                let len18 = l4;
                                let mut result18 = Vec::with_capacity(len18 as usize);
                                for i in 0..len18 {
                                    let base = base18 + i * 16;
                                    let e18 = {
                                        let l5 = i32::from(*((base + 0) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V17;
                                        let v17 = match l5 {
                                            0 => V17::Null,
                                            1 => V17::Undefined,
                                            2 => {
                                                let e17 = {
                                                    let l6 = i32::from(*((base + 8) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l6 as u8)
                                                };
                                                V17::Boolean(e17)
                                            }
                                            3 => {
                                                let e17 = {
                                                    let l7 = *((base + 8) as *const f64);
                                                    l7
                                                };
                                                V17::Number(e17)
                                            }
                                            4 => {
                                                let e17 = {
                                                    let l8 = *((base + 8) as *const i64);
                                                    l8
                                                };
                                                V17::BigInt(e17)
                                            }
                                            5 => {
                                                let e17 = {
                                                    let l9 = *((base + 8) as *const i32);
                                                    let l10 = *((base + 12) as *const i32);
                                                    let len11 = l10 as usize;
                                                    let bytes11 = Vec::from_raw_parts(
                                                        l9 as *mut _,
                                                        len11,
                                                        len11,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes11)
                                                };
                                                V17::Str(e17)
                                            }
                                            6 => {
                                                let e17 = {
                                                    let l12 = *((base + 8) as *const i32);
                                                    let l13 = *((base + 12) as *const i32);
                                                    let len14 = l13 as usize;
                                                    Vec::from_raw_parts(l12 as *mut _, len14, len14)
                                                };
                                                V17::Buffer(e17)
                                            }
                                            7 => {
                                                let e17 = {
                                                    let l15 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l15 as u32,
                                                    }
                                                };
                                                V17::Array(e17)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e17 = {
                                                    let l16 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l16 as u32,
                                                    }
                                                };
                                                V17::Map(e17)
                                            }
                                        };
                                        v17
                                    };
                                    result18.push(e18);
                                }
                                wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                result18
                            };
                            result19.push(e19);
                        }
                        wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                        let base39 = arg8;
                        let len39 = arg9;
                        let mut result39 = Vec::with_capacity(len39 as usize);
                        for i in 0..len39 {
                            let base = base39 + i * 8;
                            let e39 = {
                                let l20 = *((base + 0) as *const i32);
                                let l21 = *((base + 4) as *const i32);
                                let base38 = l20;
                                let len38 = l21;
                                let mut result38 = Vec::with_capacity(len38 as usize);
                                for i in 0..len38 {
                                    let base = base38 + i * 24;
                                    let e38 = {
                                        let l22 = *((base + 0) as *const i32);
                                        let l23 = *((base + 4) as *const i32);
                                        let len24 = l23 as usize;
                                        let bytes24 = Vec::from_raw_parts(
                                            l22 as *mut _,
                                            len24,
                                            len24,
                                        );
                                        let l25 = i32::from(*((base + 8) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V37;
                                        let v37 = match l25 {
                                            0 => V37::Null,
                                            1 => V37::Undefined,
                                            2 => {
                                                let e37 = {
                                                    let l26 = i32::from(*((base + 16) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l26 as u8)
                                                };
                                                V37::Boolean(e37)
                                            }
                                            3 => {
                                                let e37 = {
                                                    let l27 = *((base + 16) as *const f64);
                                                    l27
                                                };
                                                V37::Number(e37)
                                            }
                                            4 => {
                                                let e37 = {
                                                    let l28 = *((base + 16) as *const i64);
                                                    l28
                                                };
                                                V37::BigInt(e37)
                                            }
                                            5 => {
                                                let e37 = {
                                                    let l29 = *((base + 16) as *const i32);
                                                    let l30 = *((base + 20) as *const i32);
                                                    let len31 = l30 as usize;
                                                    let bytes31 = Vec::from_raw_parts(
                                                        l29 as *mut _,
                                                        len31,
                                                        len31,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes31)
                                                };
                                                V37::Str(e37)
                                            }
                                            6 => {
                                                let e37 = {
                                                    let l32 = *((base + 16) as *const i32);
                                                    let l33 = *((base + 20) as *const i32);
                                                    let len34 = l33 as usize;
                                                    Vec::from_raw_parts(l32 as *mut _, len34, len34)
                                                };
                                                V37::Buffer(e37)
                                            }
                                            7 => {
                                                let e37 = {
                                                    let l35 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l35 as u32,
                                                    }
                                                };
                                                V37::Array(e37)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e37 = {
                                                    let l36 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l36 as u32,
                                                    }
                                                };
                                                V37::Map(e37)
                                            }
                                        };
                                        (wit_bindgen::rt::string_lift(bytes24), v37)
                                    };
                                    result38.push(e38);
                                }
                                wit_bindgen::rt::dealloc(base38, (len38 as usize) * 24, 8);
                                result38
                            };
                            result39.push(e39);
                        }
                        wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                        <YDocMethodsImpl as YDocMethods>::y_text_format(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            arg2 as u32,
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                item: v2,
                                array_references: result19,
                                map_references: result39,
                            },
                            match arg10 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V40;
                                        let v40 = match arg11 {
                                            0 => {
                                                let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg12 as u32,
                                                };
                                                V40::ReadTransaction(e40)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg12 as u32,
                                                };
                                                V40::WriteTransaction(e40)
                                            }
                                        };
                                        v40
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-push"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_push(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i64,
                        arg6: i32,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                        arg10: i32,
                        arg11: i32,
                        arg12: i32,
                        arg13: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        <YDocMethodsImpl as YDocMethods>::y_text_push(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V3;
                                        let v3 = match arg4 {
                                            0 => V3::Null,
                                            1 => V3::Undefined,
                                            2 => {
                                                let e3 = wit_bindgen::rt::bool_lift(arg5 as i32 as u8);
                                                V3::Boolean(e3)
                                            }
                                            3 => {
                                                let e3 = f64::from_bits(arg5 as u64);
                                                V3::Number(e3)
                                            }
                                            4 => {
                                                let e3 = arg5;
                                                V3::BigInt(e3)
                                            }
                                            5 => {
                                                let e3 = {
                                                    let len1 = arg6 as usize;
                                                    let bytes1 = Vec::from_raw_parts(
                                                        arg5 as i32 as *mut _,
                                                        len1,
                                                        len1,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes1)
                                                };
                                                V3::Str(e3)
                                            }
                                            6 => {
                                                let e3 = {
                                                    let len2 = arg6 as usize;
                                                    Vec::from_raw_parts(arg5 as i32 as *mut _, len2, len2)
                                                };
                                                V3::Buffer(e3)
                                            }
                                            7 => {
                                                let e3 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: arg5 as i32 as u32,
                                                };
                                                V3::Array(e3)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e3 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: arg5 as i32 as u32,
                                                };
                                                V3::Map(e3)
                                            }
                                        };
                                        let base20 = arg7;
                                        let len20 = arg8;
                                        let mut result20 = Vec::with_capacity(len20 as usize);
                                        for i in 0..len20 {
                                            let base = base20 + i * 8;
                                            let e20 = {
                                                let l4 = *((base + 0) as *const i32);
                                                let l5 = *((base + 4) as *const i32);
                                                let base19 = l4;
                                                let len19 = l5;
                                                let mut result19 = Vec::with_capacity(len19 as usize);
                                                for i in 0..len19 {
                                                    let base = base19 + i * 16;
                                                    let e19 = {
                                                        let l6 = i32::from(*((base + 0) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V18;
                                                        let v18 = match l6 {
                                                            0 => V18::Null,
                                                            1 => V18::Undefined,
                                                            2 => {
                                                                let e18 = {
                                                                    let l7 = i32::from(*((base + 8) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l7 as u8)
                                                                };
                                                                V18::Boolean(e18)
                                                            }
                                                            3 => {
                                                                let e18 = {
                                                                    let l8 = *((base + 8) as *const f64);
                                                                    l8
                                                                };
                                                                V18::Number(e18)
                                                            }
                                                            4 => {
                                                                let e18 = {
                                                                    let l9 = *((base + 8) as *const i64);
                                                                    l9
                                                                };
                                                                V18::BigInt(e18)
                                                            }
                                                            5 => {
                                                                let e18 = {
                                                                    let l10 = *((base + 8) as *const i32);
                                                                    let l11 = *((base + 12) as *const i32);
                                                                    let len12 = l11 as usize;
                                                                    let bytes12 = Vec::from_raw_parts(
                                                                        l10 as *mut _,
                                                                        len12,
                                                                        len12,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes12)
                                                                };
                                                                V18::Str(e18)
                                                            }
                                                            6 => {
                                                                let e18 = {
                                                                    let l13 = *((base + 8) as *const i32);
                                                                    let l14 = *((base + 12) as *const i32);
                                                                    let len15 = l14 as usize;
                                                                    Vec::from_raw_parts(l13 as *mut _, len15, len15)
                                                                };
                                                                V18::Buffer(e18)
                                                            }
                                                            7 => {
                                                                let e18 = {
                                                                    let l16 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l16 as u32,
                                                                    }
                                                                };
                                                                V18::Array(e18)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e18 = {
                                                                    let l17 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l17 as u32,
                                                                    }
                                                                };
                                                                V18::Map(e18)
                                                            }
                                                        };
                                                        v18
                                                    };
                                                    result19.push(e19);
                                                }
                                                wit_bindgen::rt::dealloc(base19, (len19 as usize) * 16, 8);
                                                result19
                                            };
                                            result20.push(e20);
                                        }
                                        wit_bindgen::rt::dealloc(base20, (len20 as usize) * 8, 4);
                                        let base40 = arg9;
                                        let len40 = arg10;
                                        let mut result40 = Vec::with_capacity(len40 as usize);
                                        for i in 0..len40 {
                                            let base = base40 + i * 8;
                                            let e40 = {
                                                let l21 = *((base + 0) as *const i32);
                                                let l22 = *((base + 4) as *const i32);
                                                let base39 = l21;
                                                let len39 = l22;
                                                let mut result39 = Vec::with_capacity(len39 as usize);
                                                for i in 0..len39 {
                                                    let base = base39 + i * 24;
                                                    let e39 = {
                                                        let l23 = *((base + 0) as *const i32);
                                                        let l24 = *((base + 4) as *const i32);
                                                        let len25 = l24 as usize;
                                                        let bytes25 = Vec::from_raw_parts(
                                                            l23 as *mut _,
                                                            len25,
                                                            len25,
                                                        );
                                                        let l26 = i32::from(*((base + 8) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V38;
                                                        let v38 = match l26 {
                                                            0 => V38::Null,
                                                            1 => V38::Undefined,
                                                            2 => {
                                                                let e38 = {
                                                                    let l27 = i32::from(*((base + 16) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l27 as u8)
                                                                };
                                                                V38::Boolean(e38)
                                                            }
                                                            3 => {
                                                                let e38 = {
                                                                    let l28 = *((base + 16) as *const f64);
                                                                    l28
                                                                };
                                                                V38::Number(e38)
                                                            }
                                                            4 => {
                                                                let e38 = {
                                                                    let l29 = *((base + 16) as *const i64);
                                                                    l29
                                                                };
                                                                V38::BigInt(e38)
                                                            }
                                                            5 => {
                                                                let e38 = {
                                                                    let l30 = *((base + 16) as *const i32);
                                                                    let l31 = *((base + 20) as *const i32);
                                                                    let len32 = l31 as usize;
                                                                    let bytes32 = Vec::from_raw_parts(
                                                                        l30 as *mut _,
                                                                        len32,
                                                                        len32,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes32)
                                                                };
                                                                V38::Str(e38)
                                                            }
                                                            6 => {
                                                                let e38 = {
                                                                    let l33 = *((base + 16) as *const i32);
                                                                    let l34 = *((base + 20) as *const i32);
                                                                    let len35 = l34 as usize;
                                                                    Vec::from_raw_parts(l33 as *mut _, len35, len35)
                                                                };
                                                                V38::Buffer(e38)
                                                            }
                                                            7 => {
                                                                let e38 = {
                                                                    let l36 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l36 as u32,
                                                                    }
                                                                };
                                                                V38::Array(e38)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e38 = {
                                                                    let l37 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l37 as u32,
                                                                    }
                                                                };
                                                                V38::Map(e38)
                                                            }
                                                        };
                                                        (wit_bindgen::rt::string_lift(bytes25), v38)
                                                    };
                                                    result39.push(e39);
                                                }
                                                wit_bindgen::rt::dealloc(base39, (len39 as usize) * 24, 8);
                                                result39
                                            };
                                            result40.push(e40);
                                        }
                                        wit_bindgen::rt::dealloc(base40, (len40 as usize) * 8, 4);
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: v3,
                                            array_references: result20,
                                            map_references: result40,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                            match arg11 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V41;
                                        let v41 = match arg12 {
                                            0 => {
                                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg13 as u32,
                                                };
                                                V41::ReadTransaction(e41)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg13 as u32,
                                                };
                                                V41::WriteTransaction(e41)
                                            }
                                        };
                                        v41
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-delete"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_delete(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::y_text_delete(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            arg2 as u32,
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg4 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-delta"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_to_delta(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_text_to_delta(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                        ref_: arg2 as u32,
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                        ref_: arg4 as u32,
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                            match arg5 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg6 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg7 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg7 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec51 = result1;
                        let len51 = vec51.len() as i32;
                        let layout51 = alloc::Layout::from_size_align_unchecked(
                            vec51.len() * 56,
                            8,
                        );
                        let result51 = if layout51.size() != 0 {
                            let ptr = alloc::alloc(layout51);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout51);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec51.into_iter().enumerate() {
                            let base = result51 as i32 + (i as i32) * 56;
                            {
                                match e {
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaInsert(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaInsert {
                                            insert: insert3,
                                            attributes: attributes3,
                                        } = e;
                                        let vec4 = (insert3.into_bytes()).into_boxed_slice();
                                        let ptr4 = vec4.as_ptr() as i32;
                                        let len4 = vec4.len() as i32;
                                        ::core::mem::forget(vec4);
                                        *((base + 12) as *mut i32) = len4;
                                        *((base + 8) as *mut i32) = ptr4;
                                        match attributes3 {
                                            Some(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item5,
                                                    array_references: array_references5,
                                                    map_references: map_references5,
                                                } = e;
                                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V10;
                                                match item5 {
                                                    V10::Null => {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V10::Undefined => {
                                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V10::Boolean(e) => {
                                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                                        *((base + 32)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V10::Number(e) => {
                                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V10::BigInt(e) => {
                                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V10::Str(e) => {
                                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                                        let vec6 = (e.into_bytes()).into_boxed_slice();
                                                        let ptr6 = vec6.as_ptr() as i32;
                                                        let len6 = vec6.len() as i32;
                                                        ::core::mem::forget(vec6);
                                                        *((base + 36) as *mut i32) = len6;
                                                        *((base + 32) as *mut i32) = ptr6;
                                                    }
                                                    V10::Buffer(e) => {
                                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                                        let vec7 = (e).into_boxed_slice();
                                                        let ptr7 = vec7.as_ptr() as i32;
                                                        let len7 = vec7.len() as i32;
                                                        ::core::mem::forget(vec7);
                                                        *((base + 36) as *mut i32) = len7;
                                                        *((base + 32) as *mut i32) = ptr7;
                                                    }
                                                    V10::Array(e) => {
                                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index8,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index8);
                                                    }
                                                    V10::Map(e) => {
                                                        *((base + 24) as *mut u8) = (8i32) as u8;
                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index9,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index9);
                                                    }
                                                }
                                                let vec17 = array_references5;
                                                let len17 = vec17.len() as i32;
                                                let layout17 = alloc::Layout::from_size_align_unchecked(
                                                    vec17.len() * 8,
                                                    4,
                                                );
                                                let result17 = if layout17.size() != 0 {
                                                    let ptr = alloc::alloc(layout17);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout17);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec17.into_iter().enumerate() {
                                                    let base = result17 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec16 = e;
                                                        let len16 = vec16.len() as i32;
                                                        let layout16 = alloc::Layout::from_size_align_unchecked(
                                                            vec16.len() * 16,
                                                            8,
                                                        );
                                                        let result16 = if layout16.size() != 0 {
                                                            let ptr = alloc::alloc(layout16);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout16);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec16.into_iter().enumerate() {
                                                            let base = result16 as i32 + (i as i32) * 16;
                                                            {
                                                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V15;
                                                                match e {
                                                                    V15::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V15::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V15::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V15::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V15::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V15::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec11 = (e.into_bytes()).into_boxed_slice();
                                                                        let ptr11 = vec11.as_ptr() as i32;
                                                                        let len11 = vec11.len() as i32;
                                                                        ::core::mem::forget(vec11);
                                                                        *((base + 12) as *mut i32) = len11;
                                                                        *((base + 8) as *mut i32) = ptr11;
                                                                    }
                                                                    V15::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec12 = (e).into_boxed_slice();
                                                                        let ptr12 = vec12.as_ptr() as i32;
                                                                        let len12 = vec12.len() as i32;
                                                                        ::core::mem::forget(vec12);
                                                                        *((base + 12) as *mut i32) = len12;
                                                                        *((base + 8) as *mut i32) = ptr12;
                                                                    }
                                                                    V15::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index13,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index13);
                                                                    }
                                                                    V15::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index14,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index14);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len16;
                                                        *((base + 0) as *mut i32) = result16 as i32;
                                                    }
                                                }
                                                *((base + 44) as *mut i32) = len17;
                                                *((base + 40) as *mut i32) = result17 as i32;
                                                let vec26 = map_references5;
                                                let len26 = vec26.len() as i32;
                                                let layout26 = alloc::Layout::from_size_align_unchecked(
                                                    vec26.len() * 8,
                                                    4,
                                                );
                                                let result26 = if layout26.size() != 0 {
                                                    let ptr = alloc::alloc(layout26);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout26);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec26.into_iter().enumerate() {
                                                    let base = result26 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec25 = e;
                                                        let len25 = vec25.len() as i32;
                                                        let layout25 = alloc::Layout::from_size_align_unchecked(
                                                            vec25.len() * 24,
                                                            8,
                                                        );
                                                        let result25 = if layout25.size() != 0 {
                                                            let ptr = alloc::alloc(layout25);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout25);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec25.into_iter().enumerate() {
                                                            let base = result25 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t18_0, t18_1) = e;
                                                                let vec19 = (t18_0.into_bytes()).into_boxed_slice();
                                                                let ptr19 = vec19.as_ptr() as i32;
                                                                let len19 = vec19.len() as i32;
                                                                ::core::mem::forget(vec19);
                                                                *((base + 4) as *mut i32) = len19;
                                                                *((base + 0) as *mut i32) = ptr19;
                                                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V24;
                                                                match t18_1 {
                                                                    V24::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V24::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V24::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V24::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V24::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V24::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec20 = (e.into_bytes()).into_boxed_slice();
                                                                        let ptr20 = vec20.as_ptr() as i32;
                                                                        let len20 = vec20.len() as i32;
                                                                        ::core::mem::forget(vec20);
                                                                        *((base + 20) as *mut i32) = len20;
                                                                        *((base + 16) as *mut i32) = ptr20;
                                                                    }
                                                                    V24::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec21 = (e).into_boxed_slice();
                                                                        let ptr21 = vec21.as_ptr() as i32;
                                                                        let len21 = vec21.len() as i32;
                                                                        ::core::mem::forget(vec21);
                                                                        *((base + 20) as *mut i32) = len21;
                                                                        *((base + 16) as *mut i32) = ptr21;
                                                                    }
                                                                    V24::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index22,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index22);
                                                                    }
                                                                    V24::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index23,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index23);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len25;
                                                        *((base + 0) as *mut i32) = result25 as i32;
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len26;
                                                *((base + 48) as *mut i32) = result26 as i32;
                                            }
                                            None => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                        };
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaDelete(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaDelete {
                                            delete: delete27,
                                        } = e;
                                        *((base + 8)
                                            as *mut i32) = wit_bindgen::rt::as_i32(delete27);
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDelta::YTextDeltaRetain(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTextDeltaRetain {
                                            retain: retain28,
                                            attributes: attributes28,
                                        } = e;
                                        *((base + 8)
                                            as *mut i32) = wit_bindgen::rt::as_i32(retain28);
                                        match attributes28 {
                                            Some(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                                    item: item29,
                                                    array_references: array_references29,
                                                    map_references: map_references29,
                                                } = e;
                                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V34;
                                                match item29 {
                                                    V34::Null => {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                    }
                                                    V34::Undefined => {
                                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                                    }
                                                    V34::Boolean(e) => {
                                                        *((base + 24) as *mut u8) = (2i32) as u8;
                                                        *((base + 32)
                                                            as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        }) as u8;
                                                    }
                                                    V34::Number(e) => {
                                                        *((base + 24) as *mut u8) = (3i32) as u8;
                                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    }
                                                    V34::BigInt(e) => {
                                                        *((base + 24) as *mut u8) = (4i32) as u8;
                                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    }
                                                    V34::Str(e) => {
                                                        *((base + 24) as *mut u8) = (5i32) as u8;
                                                        let vec30 = (e.into_bytes()).into_boxed_slice();
                                                        let ptr30 = vec30.as_ptr() as i32;
                                                        let len30 = vec30.len() as i32;
                                                        ::core::mem::forget(vec30);
                                                        *((base + 36) as *mut i32) = len30;
                                                        *((base + 32) as *mut i32) = ptr30;
                                                    }
                                                    V34::Buffer(e) => {
                                                        *((base + 24) as *mut u8) = (6i32) as u8;
                                                        let vec31 = (e).into_boxed_slice();
                                                        let ptr31 = vec31.as_ptr() as i32;
                                                        let len31 = vec31.len() as i32;
                                                        ::core::mem::forget(vec31);
                                                        *((base + 36) as *mut i32) = len31;
                                                        *((base + 32) as *mut i32) = ptr31;
                                                    }
                                                    V34::Array(e) => {
                                                        *((base + 24) as *mut u8) = (7i32) as u8;
                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                            index: index32,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index32);
                                                    }
                                                    V34::Map(e) => {
                                                        *((base + 24) as *mut u8) = (8i32) as u8;
                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                            index: index33,
                                                        } = e;
                                                        *((base + 32)
                                                            as *mut i32) = wit_bindgen::rt::as_i32(index33);
                                                    }
                                                }
                                                let vec41 = array_references29;
                                                let len41 = vec41.len() as i32;
                                                let layout41 = alloc::Layout::from_size_align_unchecked(
                                                    vec41.len() * 8,
                                                    4,
                                                );
                                                let result41 = if layout41.size() != 0 {
                                                    let ptr = alloc::alloc(layout41);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout41);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec41.into_iter().enumerate() {
                                                    let base = result41 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec40 = e;
                                                        let len40 = vec40.len() as i32;
                                                        let layout40 = alloc::Layout::from_size_align_unchecked(
                                                            vec40.len() * 16,
                                                            8,
                                                        );
                                                        let result40 = if layout40.size() != 0 {
                                                            let ptr = alloc::alloc(layout40);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout40);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec40.into_iter().enumerate() {
                                                            let base = result40 as i32 + (i as i32) * 16;
                                                            {
                                                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V39;
                                                                match e {
                                                                    V39::Null => {
                                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V39::Undefined => {
                                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V39::Boolean(e) => {
                                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                                        *((base + 8)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V39::Number(e) => {
                                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                                        *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V39::BigInt(e) => {
                                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                                        *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V39::Str(e) => {
                                                                        *((base + 0) as *mut u8) = (5i32) as u8;
                                                                        let vec35 = (e.into_bytes()).into_boxed_slice();
                                                                        let ptr35 = vec35.as_ptr() as i32;
                                                                        let len35 = vec35.len() as i32;
                                                                        ::core::mem::forget(vec35);
                                                                        *((base + 12) as *mut i32) = len35;
                                                                        *((base + 8) as *mut i32) = ptr35;
                                                                    }
                                                                    V39::Buffer(e) => {
                                                                        *((base + 0) as *mut u8) = (6i32) as u8;
                                                                        let vec36 = (e).into_boxed_slice();
                                                                        let ptr36 = vec36.as_ptr() as i32;
                                                                        let len36 = vec36.len() as i32;
                                                                        ::core::mem::forget(vec36);
                                                                        *((base + 12) as *mut i32) = len36;
                                                                        *((base + 8) as *mut i32) = ptr36;
                                                                    }
                                                                    V39::Array(e) => {
                                                                        *((base + 0) as *mut u8) = (7i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index37,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index37);
                                                                    }
                                                                    V39::Map(e) => {
                                                                        *((base + 0) as *mut u8) = (8i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index38,
                                                                        } = e;
                                                                        *((base + 8)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index38);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len40;
                                                        *((base + 0) as *mut i32) = result40 as i32;
                                                    }
                                                }
                                                *((base + 44) as *mut i32) = len41;
                                                *((base + 40) as *mut i32) = result41 as i32;
                                                let vec50 = map_references29;
                                                let len50 = vec50.len() as i32;
                                                let layout50 = alloc::Layout::from_size_align_unchecked(
                                                    vec50.len() * 8,
                                                    4,
                                                );
                                                let result50 = if layout50.size() != 0 {
                                                    let ptr = alloc::alloc(layout50);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout50);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec50.into_iter().enumerate() {
                                                    let base = result50 as i32 + (i as i32) * 8;
                                                    {
                                                        let vec49 = e;
                                                        let len49 = vec49.len() as i32;
                                                        let layout49 = alloc::Layout::from_size_align_unchecked(
                                                            vec49.len() * 24,
                                                            8,
                                                        );
                                                        let result49 = if layout49.size() != 0 {
                                                            let ptr = alloc::alloc(layout49);
                                                            if ptr.is_null() {
                                                                alloc::handle_alloc_error(layout49);
                                                            }
                                                            ptr
                                                        } else {
                                                            ::core::ptr::null_mut()
                                                        };
                                                        for (i, e) in vec49.into_iter().enumerate() {
                                                            let base = result49 as i32 + (i as i32) * 24;
                                                            {
                                                                let (t42_0, t42_1) = e;
                                                                let vec43 = (t42_0.into_bytes()).into_boxed_slice();
                                                                let ptr43 = vec43.as_ptr() as i32;
                                                                let len43 = vec43.len() as i32;
                                                                ::core::mem::forget(vec43);
                                                                *((base + 4) as *mut i32) = len43;
                                                                *((base + 0) as *mut i32) = ptr43;
                                                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V48;
                                                                match t42_1 {
                                                                    V48::Null => {
                                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                                    }
                                                                    V48::Undefined => {
                                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                                    }
                                                                    V48::Boolean(e) => {
                                                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                                                        *((base + 16)
                                                                            as *mut u8) = (match e {
                                                                            true => 1,
                                                                            false => 0,
                                                                        }) as u8;
                                                                    }
                                                                    V48::Number(e) => {
                                                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                                    }
                                                                    V48::BigInt(e) => {
                                                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                                    }
                                                                    V48::Str(e) => {
                                                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                                                        let vec44 = (e.into_bytes()).into_boxed_slice();
                                                                        let ptr44 = vec44.as_ptr() as i32;
                                                                        let len44 = vec44.len() as i32;
                                                                        ::core::mem::forget(vec44);
                                                                        *((base + 20) as *mut i32) = len44;
                                                                        *((base + 16) as *mut i32) = ptr44;
                                                                    }
                                                                    V48::Buffer(e) => {
                                                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                                                        let vec45 = (e).into_boxed_slice();
                                                                        let ptr45 = vec45.as_ptr() as i32;
                                                                        let len45 = vec45.len() as i32;
                                                                        ::core::mem::forget(vec45);
                                                                        *((base + 20) as *mut i32) = len45;
                                                                        *((base + 16) as *mut i32) = ptr45;
                                                                    }
                                                                    V48::Array(e) => {
                                                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                            index: index46,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index46);
                                                                    }
                                                                    V48::Map(e) => {
                                                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                            index: index47,
                                                                        } = e;
                                                                        *((base + 16)
                                                                            as *mut i32) = wit_bindgen::rt::as_i32(index47);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        *((base + 4) as *mut i32) = len49;
                                                        *((base + 0) as *mut i32) = result49 as i32;
                                                    }
                                                }
                                                *((base + 52) as *mut i32) = len50;
                                                *((base + 48) as *mut i32) = result50 as i32;
                                            }
                                            None => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                        };
                                    }
                                };
                            }
                        }
                        *((ptr2 + 4) as *mut i32) = len51;
                        *((ptr2 + 0) as *mut i32) = result51 as i32;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-text-to-delta"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_text_to_delta(arg0: i32) {
                            let l69 = *((arg0 + 0) as *const i32);
                            let l70 = *((arg0 + 4) as *const i32);
                            let base71 = l69;
                            let len71 = l70;
                            for i in 0..len71 {
                                let base = base71 + i * 56;
                                {
                                    let l0 = i32::from(*((base + 0) as *const u8));
                                    match l0 {
                                        0 => {
                                            let l1 = *((base + 8) as *const i32);
                                            let l2 = *((base + 12) as *const i32);
                                            wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                            let l3 = i32::from(*((base + 16) as *const u8));
                                            match l3 {
                                                0 => {}
                                                _ => {
                                                    let l4 = i32::from(*((base + 24) as *const u8));
                                                    match l4 {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            let l5 = *((base + 32) as *const i32);
                                                            let l6 = *((base + 36) as *const i32);
                                                            wit_bindgen::rt::dealloc(l5, (l6) as usize, 1);
                                                        }
                                                        6 => {
                                                            let l7 = *((base + 32) as *const i32);
                                                            let l8 = *((base + 36) as *const i32);
                                                            let base9 = l7;
                                                            let len9 = l8;
                                                            wit_bindgen::rt::dealloc(base9, (len9 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                    let l19 = *((base + 40) as *const i32);
                                                    let l20 = *((base + 44) as *const i32);
                                                    let base21 = l19;
                                                    let len21 = l20;
                                                    for i in 0..len21 {
                                                        let base = base21 + i * 8;
                                                        {
                                                            let l16 = *((base + 0) as *const i32);
                                                            let l17 = *((base + 4) as *const i32);
                                                            let base18 = l16;
                                                            let len18 = l17;
                                                            for i in 0..len18 {
                                                                let base = base18 + i * 16;
                                                                {
                                                                    let l10 = i32::from(*((base + 0) as *const u8));
                                                                    match l10 {
                                                                        0 => {}
                                                                        1 => {}
                                                                        2 => {}
                                                                        3 => {}
                                                                        4 => {}
                                                                        5 => {
                                                                            let l11 = *((base + 8) as *const i32);
                                                                            let l12 = *((base + 12) as *const i32);
                                                                            wit_bindgen::rt::dealloc(l11, (l12) as usize, 1);
                                                                        }
                                                                        6 => {
                                                                            let l13 = *((base + 8) as *const i32);
                                                                            let l14 = *((base + 12) as *const i32);
                                                                            let base15 = l13;
                                                                            let len15 = l14;
                                                                            wit_bindgen::rt::dealloc(base15, (len15 as usize) * 1, 1);
                                                                        }
                                                                        7 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base21, (len21 as usize) * 8, 4);
                                                    let l33 = *((base + 48) as *const i32);
                                                    let l34 = *((base + 52) as *const i32);
                                                    let base35 = l33;
                                                    let len35 = l34;
                                                    for i in 0..len35 {
                                                        let base = base35 + i * 8;
                                                        {
                                                            let l30 = *((base + 0) as *const i32);
                                                            let l31 = *((base + 4) as *const i32);
                                                            let base32 = l30;
                                                            let len32 = l31;
                                                            for i in 0..len32 {
                                                                let base = base32 + i * 24;
                                                                {
                                                                    let l22 = *((base + 0) as *const i32);
                                                                    let l23 = *((base + 4) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l22, (l23) as usize, 1);
                                                                    let l24 = i32::from(*((base + 8) as *const u8));
                                                                    match l24 {
                                                                        0 => {}
                                                                        1 => {}
                                                                        2 => {}
                                                                        3 => {}
                                                                        4 => {}
                                                                        5 => {
                                                                            let l25 = *((base + 16) as *const i32);
                                                                            let l26 = *((base + 20) as *const i32);
                                                                            wit_bindgen::rt::dealloc(l25, (l26) as usize, 1);
                                                                        }
                                                                        6 => {
                                                                            let l27 = *((base + 16) as *const i32);
                                                                            let l28 = *((base + 20) as *const i32);
                                                                            let base29 = l27;
                                                                            let len29 = l28;
                                                                            wit_bindgen::rt::dealloc(base29, (len29 as usize) * 1, 1);
                                                                        }
                                                                        7 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            wit_bindgen::rt::dealloc(base32, (len32 as usize) * 24, 8);
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base35, (len35 as usize) * 8, 4);
                                                }
                                            }
                                        }
                                        1 => {}
                                        _ => {
                                            let l36 = i32::from(*((base + 16) as *const u8));
                                            match l36 {
                                                0 => {}
                                                _ => {
                                                    let l37 = i32::from(*((base + 24) as *const u8));
                                                    match l37 {
                                                        0 => {}
                                                        1 => {}
                                                        2 => {}
                                                        3 => {}
                                                        4 => {}
                                                        5 => {
                                                            let l38 = *((base + 32) as *const i32);
                                                            let l39 = *((base + 36) as *const i32);
                                                            wit_bindgen::rt::dealloc(l38, (l39) as usize, 1);
                                                        }
                                                        6 => {
                                                            let l40 = *((base + 32) as *const i32);
                                                            let l41 = *((base + 36) as *const i32);
                                                            let base42 = l40;
                                                            let len42 = l41;
                                                            wit_bindgen::rt::dealloc(base42, (len42 as usize) * 1, 1);
                                                        }
                                                        7 => {}
                                                        _ => {}
                                                    }
                                                    let l52 = *((base + 40) as *const i32);
                                                    let l53 = *((base + 44) as *const i32);
                                                    let base54 = l52;
                                                    let len54 = l53;
                                                    for i in 0..len54 {
                                                        let base = base54 + i * 8;
                                                        {
                                                            let l49 = *((base + 0) as *const i32);
                                                            let l50 = *((base + 4) as *const i32);
                                                            let base51 = l49;
                                                            let len51 = l50;
                                                            for i in 0..len51 {
                                                                let base = base51 + i * 16;
                                                                {
                                                                    let l43 = i32::from(*((base + 0) as *const u8));
                                                                    match l43 {
                                                                        0 => {}
                                                                        1 => {}
                                                                        2 => {}
                                                                        3 => {}
                                                                        4 => {}
                                                                        5 => {
                                                                            let l44 = *((base + 8) as *const i32);
                                                                            let l45 = *((base + 12) as *const i32);
                                                                            wit_bindgen::rt::dealloc(l44, (l45) as usize, 1);
                                                                        }
                                                                        6 => {
                                                                            let l46 = *((base + 8) as *const i32);
                                                                            let l47 = *((base + 12) as *const i32);
                                                                            let base48 = l46;
                                                                            let len48 = l47;
                                                                            wit_bindgen::rt::dealloc(base48, (len48 as usize) * 1, 1);
                                                                        }
                                                                        7 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            wit_bindgen::rt::dealloc(base51, (len51 as usize) * 16, 8);
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base54, (len54 as usize) * 8, 4);
                                                    let l66 = *((base + 48) as *const i32);
                                                    let l67 = *((base + 52) as *const i32);
                                                    let base68 = l66;
                                                    let len68 = l67;
                                                    for i in 0..len68 {
                                                        let base = base68 + i * 8;
                                                        {
                                                            let l63 = *((base + 0) as *const i32);
                                                            let l64 = *((base + 4) as *const i32);
                                                            let base65 = l63;
                                                            let len65 = l64;
                                                            for i in 0..len65 {
                                                                let base = base65 + i * 24;
                                                                {
                                                                    let l55 = *((base + 0) as *const i32);
                                                                    let l56 = *((base + 4) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l55, (l56) as usize, 1);
                                                                    let l57 = i32::from(*((base + 8) as *const u8));
                                                                    match l57 {
                                                                        0 => {}
                                                                        1 => {}
                                                                        2 => {}
                                                                        3 => {}
                                                                        4 => {}
                                                                        5 => {
                                                                            let l58 = *((base + 16) as *const i32);
                                                                            let l59 = *((base + 20) as *const i32);
                                                                            wit_bindgen::rt::dealloc(l58, (l59) as usize, 1);
                                                                        }
                                                                        6 => {
                                                                            let l60 = *((base + 16) as *const i32);
                                                                            let l61 = *((base + 20) as *const i32);
                                                                            let base62 = l60;
                                                                            let len62 = l61;
                                                                            wit_bindgen::rt::dealloc(base62, (len62 as usize) * 1, 1);
                                                                        }
                                                                        7 => {}
                                                                        _ => {}
                                                                    }
                                                                }
                                                            }
                                                            wit_bindgen::rt::dealloc(base65, (len65 as usize) * 24, 8);
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base68, (len68 as usize) * 8, 4);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base71, (len71 as usize) * 56, 8);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-observe"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_observe(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_text_observe(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-text-observe-deep"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_text_observe_deep(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_text_observe_deep(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#snapshot"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_snapshot(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::snapshot(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                            ref_: arg0 as u32,
                        });
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#equal-snapshot"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_equal_snapshot(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::equal_snapshot(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                ref_: arg0 as u32,
                            },
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                ref_: arg1 as u32,
                            },
                        );
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_snapshot_v1(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::encode_snapshot_v1(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec2 = (result0).into_boxed_slice();
                        let ptr2 = vec2.as_ptr() as i32;
                        let len2 = vec2.len() as i32;
                        ::core::mem::forget(vec2);
                        *((ptr1 + 4) as *mut i32) = len2;
                        *((ptr1 + 0) as *mut i32) = ptr2;
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v1"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_snapshot_v1(
                            arg0: i32,
                        ) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_snapshot_v2(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::encode_snapshot_v2(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec2 = (result0).into_boxed_slice();
                        let ptr2 = vec2.as_ptr() as i32;
                        let len2 = vec2.len() as i32;
                        ::core::mem::forget(vec2);
                        *((ptr1 + 4) as *mut i32) = len2;
                        *((ptr1 + 0) as *mut i32) = ptr2;
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-snapshot-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_snapshot_v2(
                            arg0: i32,
                        ) {
                            let l0 = *((arg0 + 0) as *const i32);
                            let l1 = *((arg0 + 4) as *const i32);
                            let base2 = l0;
                            let len2 = l1;
                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_decode_snapshot_v1(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg1 as usize;
                        let result1 = <YDocMethodsImpl as YDocMethods>::decode_snapshot_v1(
                            Vec::from_raw_parts(arg0 as *mut _, len0, len0),
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result1 {
                            Ok(e) => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                    ref_: ref_3,
                                } = e;
                                *((ptr2 + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_3);
                            }
                            Err(e) => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr2 + 8) as *mut i32) = len4;
                                *((ptr2 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v1"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_decode_snapshot_v1(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_decode_snapshot_v2(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg1 as usize;
                        let result1 = <YDocMethodsImpl as YDocMethods>::decode_snapshot_v2(
                            Vec::from_raw_parts(arg0 as *mut _, len0, len0),
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result1 {
                            Ok(e) => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                    ref_: ref_3,
                                } = e;
                                *((ptr2 + 4) as *mut i32) = wit_bindgen::rt::as_i32(ref_3);
                            }
                            Err(e) => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr2 + 8) as *mut i32) = len4;
                                *((ptr2 + 4) as *mut i32) = ptr4;
                            }
                        };
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#decode-snapshot-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_decode_snapshot_v2(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v1"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_state_from_snapshot_v1(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::encode_state_from_snapshot_v1(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                ref_: arg1 as u32,
                            },
                        );
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Ok(e) => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                                let vec2 = (e).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                            Err(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec3 = (e.into_bytes()).into_boxed_slice();
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                ::core::mem::forget(vec3);
                                *((ptr1 + 8) as *mut i32) = len3;
                                *((ptr1 + 4) as *mut i32) = ptr3;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v1"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_state_from_snapshot_v1(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                                _ => {
                                    let l4 = *((arg0 + 4) as *const i32);
                                    let l5 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v2"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_encode_state_from_snapshot_v2(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::encode_state_from_snapshot_v2(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YSnapshot {
                                ref_: arg1 as u32,
                            },
                        );
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Ok(e) => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                                let vec2 = (e).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                            Err(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec3 = (e.into_bytes()).into_boxed_slice();
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                ::core::mem::forget(vec3);
                                *((ptr1 + 8) as *mut i32) = len3;
                                *((ptr1 + 4) as *mut i32) = ptr3;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#encode-state-from-snapshot-v2"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_encode_state_from_snapshot_v2(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    let base3 = l1;
                                    let len3 = l2;
                                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                }
                                _ => {
                                    let l4 = *((arg0 + 4) as *const i32);
                                    let l5 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-new"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_new(
                        arg0: i32,
                        arg1: i32,
                        arg2: i64,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result40 = <YDocMethodsImpl as YDocMethods>::y_array_new(
                            match arg0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V2;
                                        let v2 = match arg1 {
                                            0 => V2::Null,
                                            1 => V2::Undefined,
                                            2 => {
                                                let e2 = wit_bindgen::rt::bool_lift(arg2 as i32 as u8);
                                                V2::Boolean(e2)
                                            }
                                            3 => {
                                                let e2 = f64::from_bits(arg2 as u64);
                                                V2::Number(e2)
                                            }
                                            4 => {
                                                let e2 = arg2;
                                                V2::BigInt(e2)
                                            }
                                            5 => {
                                                let e2 = {
                                                    let len0 = arg3 as usize;
                                                    let bytes0 = Vec::from_raw_parts(
                                                        arg2 as i32 as *mut _,
                                                        len0,
                                                        len0,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes0)
                                                };
                                                V2::Str(e2)
                                            }
                                            6 => {
                                                let e2 = {
                                                    let len1 = arg3 as usize;
                                                    Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                                };
                                                V2::Buffer(e2)
                                            }
                                            7 => {
                                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: arg2 as i32 as u32,
                                                };
                                                V2::Array(e2)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: arg2 as i32 as u32,
                                                };
                                                V2::Map(e2)
                                            }
                                        };
                                        let base19 = arg4;
                                        let len19 = arg5;
                                        let mut result19 = Vec::with_capacity(len19 as usize);
                                        for i in 0..len19 {
                                            let base = base19 + i * 8;
                                            let e19 = {
                                                let l3 = *((base + 0) as *const i32);
                                                let l4 = *((base + 4) as *const i32);
                                                let base18 = l3;
                                                let len18 = l4;
                                                let mut result18 = Vec::with_capacity(len18 as usize);
                                                for i in 0..len18 {
                                                    let base = base18 + i * 16;
                                                    let e18 = {
                                                        let l5 = i32::from(*((base + 0) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V17;
                                                        let v17 = match l5 {
                                                            0 => V17::Null,
                                                            1 => V17::Undefined,
                                                            2 => {
                                                                let e17 = {
                                                                    let l6 = i32::from(*((base + 8) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l6 as u8)
                                                                };
                                                                V17::Boolean(e17)
                                                            }
                                                            3 => {
                                                                let e17 = {
                                                                    let l7 = *((base + 8) as *const f64);
                                                                    l7
                                                                };
                                                                V17::Number(e17)
                                                            }
                                                            4 => {
                                                                let e17 = {
                                                                    let l8 = *((base + 8) as *const i64);
                                                                    l8
                                                                };
                                                                V17::BigInt(e17)
                                                            }
                                                            5 => {
                                                                let e17 = {
                                                                    let l9 = *((base + 8) as *const i32);
                                                                    let l10 = *((base + 12) as *const i32);
                                                                    let len11 = l10 as usize;
                                                                    let bytes11 = Vec::from_raw_parts(
                                                                        l9 as *mut _,
                                                                        len11,
                                                                        len11,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes11)
                                                                };
                                                                V17::Str(e17)
                                                            }
                                                            6 => {
                                                                let e17 = {
                                                                    let l12 = *((base + 8) as *const i32);
                                                                    let l13 = *((base + 12) as *const i32);
                                                                    let len14 = l13 as usize;
                                                                    Vec::from_raw_parts(l12 as *mut _, len14, len14)
                                                                };
                                                                V17::Buffer(e17)
                                                            }
                                                            7 => {
                                                                let e17 = {
                                                                    let l15 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l15 as u32,
                                                                    }
                                                                };
                                                                V17::Array(e17)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e17 = {
                                                                    let l16 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l16 as u32,
                                                                    }
                                                                };
                                                                V17::Map(e17)
                                                            }
                                                        };
                                                        v17
                                                    };
                                                    result18.push(e18);
                                                }
                                                wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                                result18
                                            };
                                            result19.push(e19);
                                        }
                                        wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                                        let base39 = arg6;
                                        let len39 = arg7;
                                        let mut result39 = Vec::with_capacity(len39 as usize);
                                        for i in 0..len39 {
                                            let base = base39 + i * 8;
                                            let e39 = {
                                                let l20 = *((base + 0) as *const i32);
                                                let l21 = *((base + 4) as *const i32);
                                                let base38 = l20;
                                                let len38 = l21;
                                                let mut result38 = Vec::with_capacity(len38 as usize);
                                                for i in 0..len38 {
                                                    let base = base38 + i * 24;
                                                    let e38 = {
                                                        let l22 = *((base + 0) as *const i32);
                                                        let l23 = *((base + 4) as *const i32);
                                                        let len24 = l23 as usize;
                                                        let bytes24 = Vec::from_raw_parts(
                                                            l22 as *mut _,
                                                            len24,
                                                            len24,
                                                        );
                                                        let l25 = i32::from(*((base + 8) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V37;
                                                        let v37 = match l25 {
                                                            0 => V37::Null,
                                                            1 => V37::Undefined,
                                                            2 => {
                                                                let e37 = {
                                                                    let l26 = i32::from(*((base + 16) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l26 as u8)
                                                                };
                                                                V37::Boolean(e37)
                                                            }
                                                            3 => {
                                                                let e37 = {
                                                                    let l27 = *((base + 16) as *const f64);
                                                                    l27
                                                                };
                                                                V37::Number(e37)
                                                            }
                                                            4 => {
                                                                let e37 = {
                                                                    let l28 = *((base + 16) as *const i64);
                                                                    l28
                                                                };
                                                                V37::BigInt(e37)
                                                            }
                                                            5 => {
                                                                let e37 = {
                                                                    let l29 = *((base + 16) as *const i32);
                                                                    let l30 = *((base + 20) as *const i32);
                                                                    let len31 = l30 as usize;
                                                                    let bytes31 = Vec::from_raw_parts(
                                                                        l29 as *mut _,
                                                                        len31,
                                                                        len31,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes31)
                                                                };
                                                                V37::Str(e37)
                                                            }
                                                            6 => {
                                                                let e37 = {
                                                                    let l32 = *((base + 16) as *const i32);
                                                                    let l33 = *((base + 20) as *const i32);
                                                                    let len34 = l33 as usize;
                                                                    Vec::from_raw_parts(l32 as *mut _, len34, len34)
                                                                };
                                                                V37::Buffer(e37)
                                                            }
                                                            7 => {
                                                                let e37 = {
                                                                    let l35 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l35 as u32,
                                                                    }
                                                                };
                                                                V37::Array(e37)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e37 = {
                                                                    let l36 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l36 as u32,
                                                                    }
                                                                };
                                                                V37::Map(e37)
                                                            }
                                                        };
                                                        (wit_bindgen::rt::string_lift(bytes24), v37)
                                                    };
                                                    result38.push(e38);
                                                }
                                                wit_bindgen::rt::dealloc(base38, (len38 as usize) * 24, 8);
                                                result38
                                            };
                                            result39.push(e39);
                                        }
                                        wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: v2,
                                            array_references: result19,
                                            map_references: result39,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: ref_41,
                        } = result40;
                        wit_bindgen::rt::as_i32(ref_41)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-prelim"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_prelim(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_array_prelim(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-length"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_length(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_array_length(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::as_i32(result1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-to-json"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_to_json(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_array_to_json(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: item3,
                            array_references: array_references3,
                            map_references: map_references3,
                        } = result1;
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V8;
                        match item3 {
                            V8::Null => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            }
                            V8::Undefined => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            }
                            V8::Boolean(e) => {
                                *((ptr2 + 0) as *mut u8) = (2i32) as u8;
                                *((ptr2 + 8)
                                    as *mut u8) = (match e {
                                    true => 1,
                                    false => 0,
                                }) as u8;
                            }
                            V8::Number(e) => {
                                *((ptr2 + 0) as *mut u8) = (3i32) as u8;
                                *((ptr2 + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                            }
                            V8::BigInt(e) => {
                                *((ptr2 + 0) as *mut u8) = (4i32) as u8;
                                *((ptr2 + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            }
                            V8::Str(e) => {
                                *((ptr2 + 0) as *mut u8) = (5i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr2 + 12) as *mut i32) = len4;
                                *((ptr2 + 8) as *mut i32) = ptr4;
                            }
                            V8::Buffer(e) => {
                                *((ptr2 + 0) as *mut u8) = (6i32) as u8;
                                let vec5 = (e).into_boxed_slice();
                                let ptr5 = vec5.as_ptr() as i32;
                                let len5 = vec5.len() as i32;
                                ::core::mem::forget(vec5);
                                *((ptr2 + 12) as *mut i32) = len5;
                                *((ptr2 + 8) as *mut i32) = ptr5;
                            }
                            V8::Array(e) => {
                                *((ptr2 + 0) as *mut u8) = (7i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                    index: index6,
                                } = e;
                                *((ptr2 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index6);
                            }
                            V8::Map(e) => {
                                *((ptr2 + 0) as *mut u8) = (8i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                    index: index7,
                                } = e;
                                *((ptr2 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index7);
                            }
                        }
                        let vec15 = array_references3;
                        let len15 = vec15.len() as i32;
                        let layout15 = alloc::Layout::from_size_align_unchecked(
                            vec15.len() * 8,
                            4,
                        );
                        let result15 = if layout15.size() != 0 {
                            let ptr = alloc::alloc(layout15);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout15);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec15.into_iter().enumerate() {
                            let base = result15 as i32 + (i as i32) * 8;
                            {
                                let vec14 = e;
                                let len14 = vec14.len() as i32;
                                let layout14 = alloc::Layout::from_size_align_unchecked(
                                    vec14.len() * 16,
                                    8,
                                );
                                let result14 = if layout14.size() != 0 {
                                    let ptr = alloc::alloc(layout14);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout14);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec14.into_iter().enumerate() {
                                    let base = result14 as i32 + (i as i32) * 16;
                                    {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V13;
                                        match e {
                                            V13::Null => {
                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                            }
                                            V13::Undefined => {
                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                            }
                                            V13::Boolean(e) => {
                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                *((base + 8)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V13::Number(e) => {
                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V13::BigInt(e) => {
                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V13::Str(e) => {
                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                let vec9 = (e.into_bytes()).into_boxed_slice();
                                                let ptr9 = vec9.as_ptr() as i32;
                                                let len9 = vec9.len() as i32;
                                                ::core::mem::forget(vec9);
                                                *((base + 12) as *mut i32) = len9;
                                                *((base + 8) as *mut i32) = ptr9;
                                            }
                                            V13::Buffer(e) => {
                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                let vec10 = (e).into_boxed_slice();
                                                let ptr10 = vec10.as_ptr() as i32;
                                                let len10 = vec10.len() as i32;
                                                ::core::mem::forget(vec10);
                                                *((base + 12) as *mut i32) = len10;
                                                *((base + 8) as *mut i32) = ptr10;
                                            }
                                            V13::Array(e) => {
                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index11,
                                                } = e;
                                                *((base + 8)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                            }
                                            V13::Map(e) => {
                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index12,
                                                } = e;
                                                *((base + 8)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                            }
                                        }
                                    }
                                }
                                *((base + 4) as *mut i32) = len14;
                                *((base + 0) as *mut i32) = result14 as i32;
                            }
                        }
                        *((ptr2 + 20) as *mut i32) = len15;
                        *((ptr2 + 16) as *mut i32) = result15 as i32;
                        let vec24 = map_references3;
                        let len24 = vec24.len() as i32;
                        let layout24 = alloc::Layout::from_size_align_unchecked(
                            vec24.len() * 8,
                            4,
                        );
                        let result24 = if layout24.size() != 0 {
                            let ptr = alloc::alloc(layout24);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout24);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec24.into_iter().enumerate() {
                            let base = result24 as i32 + (i as i32) * 8;
                            {
                                let vec23 = e;
                                let len23 = vec23.len() as i32;
                                let layout23 = alloc::Layout::from_size_align_unchecked(
                                    vec23.len() * 24,
                                    8,
                                );
                                let result23 = if layout23.size() != 0 {
                                    let ptr = alloc::alloc(layout23);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout23);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec23.into_iter().enumerate() {
                                    let base = result23 as i32 + (i as i32) * 24;
                                    {
                                        let (t16_0, t16_1) = e;
                                        let vec17 = (t16_0.into_bytes()).into_boxed_slice();
                                        let ptr17 = vec17.as_ptr() as i32;
                                        let len17 = vec17.len() as i32;
                                        ::core::mem::forget(vec17);
                                        *((base + 4) as *mut i32) = len17;
                                        *((base + 0) as *mut i32) = ptr17;
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V22;
                                        match t16_1 {
                                            V22::Null => {
                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                            }
                                            V22::Undefined => {
                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                            }
                                            V22::Boolean(e) => {
                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                *((base + 16)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V22::Number(e) => {
                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V22::BigInt(e) => {
                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V22::Str(e) => {
                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                let vec18 = (e.into_bytes()).into_boxed_slice();
                                                let ptr18 = vec18.as_ptr() as i32;
                                                let len18 = vec18.len() as i32;
                                                ::core::mem::forget(vec18);
                                                *((base + 20) as *mut i32) = len18;
                                                *((base + 16) as *mut i32) = ptr18;
                                            }
                                            V22::Buffer(e) => {
                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                let vec19 = (e).into_boxed_slice();
                                                let ptr19 = vec19.as_ptr() as i32;
                                                let len19 = vec19.len() as i32;
                                                ::core::mem::forget(vec19);
                                                *((base + 20) as *mut i32) = len19;
                                                *((base + 16) as *mut i32) = ptr19;
                                            }
                                            V22::Array(e) => {
                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index20,
                                                } = e;
                                                *((base + 16)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                            }
                                            V22::Map(e) => {
                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index21,
                                                } = e;
                                                *((base + 16)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                            }
                                        }
                                    }
                                }
                                *((base + 4) as *mut i32) = len23;
                                *((base + 0) as *mut i32) = result23 as i32;
                            }
                        }
                        *((ptr2 + 28) as *mut i32) = len24;
                        *((ptr2 + 24) as *mut i32) = result24 as i32;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-array-to-json"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_array_to_json(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {
                                    let l1 = *((arg0 + 8) as *const i32);
                                    let l2 = *((arg0 + 12) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                                6 => {
                                    let l3 = *((arg0 + 8) as *const i32);
                                    let l4 = *((arg0 + 12) as *const i32);
                                    let base5 = l3;
                                    let len5 = l4;
                                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 1, 1);
                                }
                                7 => {}
                                _ => {}
                            }
                            let l15 = *((arg0 + 16) as *const i32);
                            let l16 = *((arg0 + 20) as *const i32);
                            let base17 = l15;
                            let len17 = l16;
                            for i in 0..len17 {
                                let base = base17 + i * 8;
                                {
                                    let l12 = *((base + 0) as *const i32);
                                    let l13 = *((base + 4) as *const i32);
                                    let base14 = l12;
                                    let len14 = l13;
                                    for i in 0..len14 {
                                        let base = base14 + i * 16;
                                        {
                                            let l6 = i32::from(*((base + 0) as *const u8));
                                            match l6 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l7 = *((base + 8) as *const i32);
                                                    let l8 = *((base + 12) as *const i32);
                                                    wit_bindgen::rt::dealloc(l7, (l8) as usize, 1);
                                                }
                                                6 => {
                                                    let l9 = *((base + 8) as *const i32);
                                                    let l10 = *((base + 12) as *const i32);
                                                    let base11 = l9;
                                                    let len11 = l10;
                                                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base14, (len14 as usize) * 16, 8);
                                }
                            }
                            wit_bindgen::rt::dealloc(base17, (len17 as usize) * 8, 4);
                            let l29 = *((arg0 + 24) as *const i32);
                            let l30 = *((arg0 + 28) as *const i32);
                            let base31 = l29;
                            let len31 = l30;
                            for i in 0..len31 {
                                let base = base31 + i * 8;
                                {
                                    let l26 = *((base + 0) as *const i32);
                                    let l27 = *((base + 4) as *const i32);
                                    let base28 = l26;
                                    let len28 = l27;
                                    for i in 0..len28 {
                                        let base = base28 + i * 24;
                                        {
                                            let l18 = *((base + 0) as *const i32);
                                            let l19 = *((base + 4) as *const i32);
                                            wit_bindgen::rt::dealloc(l18, (l19) as usize, 1);
                                            let l20 = i32::from(*((base + 8) as *const u8));
                                            match l20 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l21 = *((base + 16) as *const i32);
                                                    let l22 = *((base + 20) as *const i32);
                                                    wit_bindgen::rt::dealloc(l21, (l22) as usize, 1);
                                                }
                                                6 => {
                                                    let l23 = *((base + 16) as *const i32);
                                                    let l24 = *((base + 20) as *const i32);
                                                    let base25 = l23;
                                                    let len25 = l24;
                                                    wit_bindgen::rt::dealloc(base25, (len25 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base28, (len28 as usize) * 24, 8);
                                }
                            }
                            wit_bindgen::rt::dealloc(base31, (len31 as usize) * 8, 4);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-insert"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_insert(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i64,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                        arg10: i32,
                        arg11: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V2;
                        let v2 = match arg2 {
                            0 => V2::Null,
                            1 => V2::Undefined,
                            2 => {
                                let e2 = wit_bindgen::rt::bool_lift(arg3 as i32 as u8);
                                V2::Boolean(e2)
                            }
                            3 => {
                                let e2 = f64::from_bits(arg3 as u64);
                                V2::Number(e2)
                            }
                            4 => {
                                let e2 = arg3;
                                V2::BigInt(e2)
                            }
                            5 => {
                                let e2 = {
                                    let len0 = arg4 as usize;
                                    let bytes0 = Vec::from_raw_parts(
                                        arg3 as i32 as *mut _,
                                        len0,
                                        len0,
                                    );
                                    wit_bindgen::rt::string_lift(bytes0)
                                };
                                V2::Str(e2)
                            }
                            6 => {
                                let e2 = {
                                    let len1 = arg4 as usize;
                                    Vec::from_raw_parts(arg3 as i32 as *mut _, len1, len1)
                                };
                                V2::Buffer(e2)
                            }
                            7 => {
                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                    index: arg3 as i32 as u32,
                                };
                                V2::Array(e2)
                            }
                            n => {
                                if true {
                                    match (&n, &8) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                    index: arg3 as i32 as u32,
                                };
                                V2::Map(e2)
                            }
                        };
                        let base19 = arg5;
                        let len19 = arg6;
                        let mut result19 = Vec::with_capacity(len19 as usize);
                        for i in 0..len19 {
                            let base = base19 + i * 8;
                            let e19 = {
                                let l3 = *((base + 0) as *const i32);
                                let l4 = *((base + 4) as *const i32);
                                let base18 = l3;
                                let len18 = l4;
                                let mut result18 = Vec::with_capacity(len18 as usize);
                                for i in 0..len18 {
                                    let base = base18 + i * 16;
                                    let e18 = {
                                        let l5 = i32::from(*((base + 0) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V17;
                                        let v17 = match l5 {
                                            0 => V17::Null,
                                            1 => V17::Undefined,
                                            2 => {
                                                let e17 = {
                                                    let l6 = i32::from(*((base + 8) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l6 as u8)
                                                };
                                                V17::Boolean(e17)
                                            }
                                            3 => {
                                                let e17 = {
                                                    let l7 = *((base + 8) as *const f64);
                                                    l7
                                                };
                                                V17::Number(e17)
                                            }
                                            4 => {
                                                let e17 = {
                                                    let l8 = *((base + 8) as *const i64);
                                                    l8
                                                };
                                                V17::BigInt(e17)
                                            }
                                            5 => {
                                                let e17 = {
                                                    let l9 = *((base + 8) as *const i32);
                                                    let l10 = *((base + 12) as *const i32);
                                                    let len11 = l10 as usize;
                                                    let bytes11 = Vec::from_raw_parts(
                                                        l9 as *mut _,
                                                        len11,
                                                        len11,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes11)
                                                };
                                                V17::Str(e17)
                                            }
                                            6 => {
                                                let e17 = {
                                                    let l12 = *((base + 8) as *const i32);
                                                    let l13 = *((base + 12) as *const i32);
                                                    let len14 = l13 as usize;
                                                    Vec::from_raw_parts(l12 as *mut _, len14, len14)
                                                };
                                                V17::Buffer(e17)
                                            }
                                            7 => {
                                                let e17 = {
                                                    let l15 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l15 as u32,
                                                    }
                                                };
                                                V17::Array(e17)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e17 = {
                                                    let l16 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l16 as u32,
                                                    }
                                                };
                                                V17::Map(e17)
                                            }
                                        };
                                        v17
                                    };
                                    result18.push(e18);
                                }
                                wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                result18
                            };
                            result19.push(e19);
                        }
                        wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                        let base39 = arg7;
                        let len39 = arg8;
                        let mut result39 = Vec::with_capacity(len39 as usize);
                        for i in 0..len39 {
                            let base = base39 + i * 8;
                            let e39 = {
                                let l20 = *((base + 0) as *const i32);
                                let l21 = *((base + 4) as *const i32);
                                let base38 = l20;
                                let len38 = l21;
                                let mut result38 = Vec::with_capacity(len38 as usize);
                                for i in 0..len38 {
                                    let base = base38 + i * 24;
                                    let e38 = {
                                        let l22 = *((base + 0) as *const i32);
                                        let l23 = *((base + 4) as *const i32);
                                        let len24 = l23 as usize;
                                        let bytes24 = Vec::from_raw_parts(
                                            l22 as *mut _,
                                            len24,
                                            len24,
                                        );
                                        let l25 = i32::from(*((base + 8) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V37;
                                        let v37 = match l25 {
                                            0 => V37::Null,
                                            1 => V37::Undefined,
                                            2 => {
                                                let e37 = {
                                                    let l26 = i32::from(*((base + 16) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l26 as u8)
                                                };
                                                V37::Boolean(e37)
                                            }
                                            3 => {
                                                let e37 = {
                                                    let l27 = *((base + 16) as *const f64);
                                                    l27
                                                };
                                                V37::Number(e37)
                                            }
                                            4 => {
                                                let e37 = {
                                                    let l28 = *((base + 16) as *const i64);
                                                    l28
                                                };
                                                V37::BigInt(e37)
                                            }
                                            5 => {
                                                let e37 = {
                                                    let l29 = *((base + 16) as *const i32);
                                                    let l30 = *((base + 20) as *const i32);
                                                    let len31 = l30 as usize;
                                                    let bytes31 = Vec::from_raw_parts(
                                                        l29 as *mut _,
                                                        len31,
                                                        len31,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes31)
                                                };
                                                V37::Str(e37)
                                            }
                                            6 => {
                                                let e37 = {
                                                    let l32 = *((base + 16) as *const i32);
                                                    let l33 = *((base + 20) as *const i32);
                                                    let len34 = l33 as usize;
                                                    Vec::from_raw_parts(l32 as *mut _, len34, len34)
                                                };
                                                V37::Buffer(e37)
                                            }
                                            7 => {
                                                let e37 = {
                                                    let l35 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l35 as u32,
                                                    }
                                                };
                                                V37::Array(e37)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e37 = {
                                                    let l36 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l36 as u32,
                                                    }
                                                };
                                                V37::Map(e37)
                                            }
                                        };
                                        (wit_bindgen::rt::string_lift(bytes24), v37)
                                    };
                                    result38.push(e38);
                                }
                                wit_bindgen::rt::dealloc(base38, (len38 as usize) * 24, 8);
                                result38
                            };
                            result39.push(e39);
                        }
                        wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                        <YDocMethodsImpl as YDocMethods>::y_array_insert(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                item: v2,
                                array_references: result19,
                                map_references: result39,
                            },
                            match arg9 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V40;
                                        let v40 = match arg10 {
                                            0 => {
                                                let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg11 as u32,
                                                };
                                                V40::ReadTransaction(e40)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg11 as u32,
                                                };
                                                V40::WriteTransaction(e40)
                                            }
                                        };
                                        v40
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-push"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_push(
                        arg0: i32,
                        arg1: i32,
                        arg2: i64,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                        arg10: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V2;
                        let v2 = match arg1 {
                            0 => V2::Null,
                            1 => V2::Undefined,
                            2 => {
                                let e2 = wit_bindgen::rt::bool_lift(arg2 as i32 as u8);
                                V2::Boolean(e2)
                            }
                            3 => {
                                let e2 = f64::from_bits(arg2 as u64);
                                V2::Number(e2)
                            }
                            4 => {
                                let e2 = arg2;
                                V2::BigInt(e2)
                            }
                            5 => {
                                let e2 = {
                                    let len0 = arg3 as usize;
                                    let bytes0 = Vec::from_raw_parts(
                                        arg2 as i32 as *mut _,
                                        len0,
                                        len0,
                                    );
                                    wit_bindgen::rt::string_lift(bytes0)
                                };
                                V2::Str(e2)
                            }
                            6 => {
                                let e2 = {
                                    let len1 = arg3 as usize;
                                    Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                };
                                V2::Buffer(e2)
                            }
                            7 => {
                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                    index: arg2 as i32 as u32,
                                };
                                V2::Array(e2)
                            }
                            n => {
                                if true {
                                    match (&n, &8) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                    index: arg2 as i32 as u32,
                                };
                                V2::Map(e2)
                            }
                        };
                        let base19 = arg4;
                        let len19 = arg5;
                        let mut result19 = Vec::with_capacity(len19 as usize);
                        for i in 0..len19 {
                            let base = base19 + i * 8;
                            let e19 = {
                                let l3 = *((base + 0) as *const i32);
                                let l4 = *((base + 4) as *const i32);
                                let base18 = l3;
                                let len18 = l4;
                                let mut result18 = Vec::with_capacity(len18 as usize);
                                for i in 0..len18 {
                                    let base = base18 + i * 16;
                                    let e18 = {
                                        let l5 = i32::from(*((base + 0) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V17;
                                        let v17 = match l5 {
                                            0 => V17::Null,
                                            1 => V17::Undefined,
                                            2 => {
                                                let e17 = {
                                                    let l6 = i32::from(*((base + 8) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l6 as u8)
                                                };
                                                V17::Boolean(e17)
                                            }
                                            3 => {
                                                let e17 = {
                                                    let l7 = *((base + 8) as *const f64);
                                                    l7
                                                };
                                                V17::Number(e17)
                                            }
                                            4 => {
                                                let e17 = {
                                                    let l8 = *((base + 8) as *const i64);
                                                    l8
                                                };
                                                V17::BigInt(e17)
                                            }
                                            5 => {
                                                let e17 = {
                                                    let l9 = *((base + 8) as *const i32);
                                                    let l10 = *((base + 12) as *const i32);
                                                    let len11 = l10 as usize;
                                                    let bytes11 = Vec::from_raw_parts(
                                                        l9 as *mut _,
                                                        len11,
                                                        len11,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes11)
                                                };
                                                V17::Str(e17)
                                            }
                                            6 => {
                                                let e17 = {
                                                    let l12 = *((base + 8) as *const i32);
                                                    let l13 = *((base + 12) as *const i32);
                                                    let len14 = l13 as usize;
                                                    Vec::from_raw_parts(l12 as *mut _, len14, len14)
                                                };
                                                V17::Buffer(e17)
                                            }
                                            7 => {
                                                let e17 = {
                                                    let l15 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l15 as u32,
                                                    }
                                                };
                                                V17::Array(e17)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e17 = {
                                                    let l16 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l16 as u32,
                                                    }
                                                };
                                                V17::Map(e17)
                                            }
                                        };
                                        v17
                                    };
                                    result18.push(e18);
                                }
                                wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                result18
                            };
                            result19.push(e19);
                        }
                        wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                        let base39 = arg6;
                        let len39 = arg7;
                        let mut result39 = Vec::with_capacity(len39 as usize);
                        for i in 0..len39 {
                            let base = base39 + i * 8;
                            let e39 = {
                                let l20 = *((base + 0) as *const i32);
                                let l21 = *((base + 4) as *const i32);
                                let base38 = l20;
                                let len38 = l21;
                                let mut result38 = Vec::with_capacity(len38 as usize);
                                for i in 0..len38 {
                                    let base = base38 + i * 24;
                                    let e38 = {
                                        let l22 = *((base + 0) as *const i32);
                                        let l23 = *((base + 4) as *const i32);
                                        let len24 = l23 as usize;
                                        let bytes24 = Vec::from_raw_parts(
                                            l22 as *mut _,
                                            len24,
                                            len24,
                                        );
                                        let l25 = i32::from(*((base + 8) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V37;
                                        let v37 = match l25 {
                                            0 => V37::Null,
                                            1 => V37::Undefined,
                                            2 => {
                                                let e37 = {
                                                    let l26 = i32::from(*((base + 16) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l26 as u8)
                                                };
                                                V37::Boolean(e37)
                                            }
                                            3 => {
                                                let e37 = {
                                                    let l27 = *((base + 16) as *const f64);
                                                    l27
                                                };
                                                V37::Number(e37)
                                            }
                                            4 => {
                                                let e37 = {
                                                    let l28 = *((base + 16) as *const i64);
                                                    l28
                                                };
                                                V37::BigInt(e37)
                                            }
                                            5 => {
                                                let e37 = {
                                                    let l29 = *((base + 16) as *const i32);
                                                    let l30 = *((base + 20) as *const i32);
                                                    let len31 = l30 as usize;
                                                    let bytes31 = Vec::from_raw_parts(
                                                        l29 as *mut _,
                                                        len31,
                                                        len31,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes31)
                                                };
                                                V37::Str(e37)
                                            }
                                            6 => {
                                                let e37 = {
                                                    let l32 = *((base + 16) as *const i32);
                                                    let l33 = *((base + 20) as *const i32);
                                                    let len34 = l33 as usize;
                                                    Vec::from_raw_parts(l32 as *mut _, len34, len34)
                                                };
                                                V37::Buffer(e37)
                                            }
                                            7 => {
                                                let e37 = {
                                                    let l35 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l35 as u32,
                                                    }
                                                };
                                                V37::Array(e37)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e37 = {
                                                    let l36 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l36 as u32,
                                                    }
                                                };
                                                V37::Map(e37)
                                            }
                                        };
                                        (wit_bindgen::rt::string_lift(bytes24), v37)
                                    };
                                    result38.push(e38);
                                }
                                wit_bindgen::rt::dealloc(base38, (len38 as usize) * 24, 8);
                                result38
                            };
                            result39.push(e39);
                        }
                        wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                        <YDocMethodsImpl as YDocMethods>::y_array_push(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                item: v2,
                                array_references: result19,
                                map_references: result39,
                            },
                            match arg8 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V40;
                                        let v40 = match arg9 {
                                            0 => {
                                                let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg10 as u32,
                                                };
                                                V40::ReadTransaction(e40)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e40 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg10 as u32,
                                                };
                                                V40::WriteTransaction(e40)
                                            }
                                        };
                                        v40
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-delete"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_delete(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::y_array_delete(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            arg2 as u32,
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg4 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-move-content"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_move_content(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::y_array_move_content(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            arg2 as u32,
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg4 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-get"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_get(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_array_get(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            match arg2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg3 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg4 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg4 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result1 {
                            Ok(e) => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                                match e {
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((ptr2 + 8) as *mut u8) = (0i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item3,
                                            array_references: array_references3,
                                            map_references: map_references3,
                                        } = e;
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V8;
                                        match item3 {
                                            V8::Null => {
                                                *((ptr2 + 16) as *mut u8) = (0i32) as u8;
                                            }
                                            V8::Undefined => {
                                                *((ptr2 + 16) as *mut u8) = (1i32) as u8;
                                            }
                                            V8::Boolean(e) => {
                                                *((ptr2 + 16) as *mut u8) = (2i32) as u8;
                                                *((ptr2 + 24)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V8::Number(e) => {
                                                *((ptr2 + 16) as *mut u8) = (3i32) as u8;
                                                *((ptr2 + 24) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V8::BigInt(e) => {
                                                *((ptr2 + 16) as *mut u8) = (4i32) as u8;
                                                *((ptr2 + 24) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V8::Str(e) => {
                                                *((ptr2 + 16) as *mut u8) = (5i32) as u8;
                                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                                let ptr4 = vec4.as_ptr() as i32;
                                                let len4 = vec4.len() as i32;
                                                ::core::mem::forget(vec4);
                                                *((ptr2 + 28) as *mut i32) = len4;
                                                *((ptr2 + 24) as *mut i32) = ptr4;
                                            }
                                            V8::Buffer(e) => {
                                                *((ptr2 + 16) as *mut u8) = (6i32) as u8;
                                                let vec5 = (e).into_boxed_slice();
                                                let ptr5 = vec5.as_ptr() as i32;
                                                let len5 = vec5.len() as i32;
                                                ::core::mem::forget(vec5);
                                                *((ptr2 + 28) as *mut i32) = len5;
                                                *((ptr2 + 24) as *mut i32) = ptr5;
                                            }
                                            V8::Array(e) => {
                                                *((ptr2 + 16) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index6,
                                                } = e;
                                                *((ptr2 + 24)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                            }
                                            V8::Map(e) => {
                                                *((ptr2 + 16) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index7,
                                                } = e;
                                                *((ptr2 + 24)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                            }
                                        }
                                        let vec15 = array_references3;
                                        let len15 = vec15.len() as i32;
                                        let layout15 = alloc::Layout::from_size_align_unchecked(
                                            vec15.len() * 8,
                                            4,
                                        );
                                        let result15 = if layout15.size() != 0 {
                                            let ptr = alloc::alloc(layout15);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout15);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec15.into_iter().enumerate() {
                                            let base = result15 as i32 + (i as i32) * 8;
                                            {
                                                let vec14 = e;
                                                let len14 = vec14.len() as i32;
                                                let layout14 = alloc::Layout::from_size_align_unchecked(
                                                    vec14.len() * 16,
                                                    8,
                                                );
                                                let result14 = if layout14.size() != 0 {
                                                    let ptr = alloc::alloc(layout14);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout14);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec14.into_iter().enumerate() {
                                                    let base = result14 as i32 + (i as i32) * 16;
                                                    {
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V13;
                                                        match e {
                                                            V13::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V13::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V13::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V13::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V13::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V13::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec9 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr9 = vec9.as_ptr() as i32;
                                                                let len9 = vec9.len() as i32;
                                                                ::core::mem::forget(vec9);
                                                                *((base + 12) as *mut i32) = len9;
                                                                *((base + 8) as *mut i32) = ptr9;
                                                            }
                                                            V13::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec10 = (e).into_boxed_slice();
                                                                let ptr10 = vec10.as_ptr() as i32;
                                                                let len10 = vec10.len() as i32;
                                                                ::core::mem::forget(vec10);
                                                                *((base + 12) as *mut i32) = len10;
                                                                *((base + 8) as *mut i32) = ptr10;
                                                            }
                                                            V13::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index11,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                            }
                                                            V13::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index12,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len14;
                                                *((base + 0) as *mut i32) = result14 as i32;
                                            }
                                        }
                                        *((ptr2 + 36) as *mut i32) = len15;
                                        *((ptr2 + 32) as *mut i32) = result15 as i32;
                                        let vec24 = map_references3;
                                        let len24 = vec24.len() as i32;
                                        let layout24 = alloc::Layout::from_size_align_unchecked(
                                            vec24.len() * 8,
                                            4,
                                        );
                                        let result24 = if layout24.size() != 0 {
                                            let ptr = alloc::alloc(layout24);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout24);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec24.into_iter().enumerate() {
                                            let base = result24 as i32 + (i as i32) * 8;
                                            {
                                                let vec23 = e;
                                                let len23 = vec23.len() as i32;
                                                let layout23 = alloc::Layout::from_size_align_unchecked(
                                                    vec23.len() * 24,
                                                    8,
                                                );
                                                let result23 = if layout23.size() != 0 {
                                                    let ptr = alloc::alloc(layout23);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout23);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec23.into_iter().enumerate() {
                                                    let base = result23 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t16_0, t16_1) = e;
                                                        let vec17 = (t16_0.into_bytes()).into_boxed_slice();
                                                        let ptr17 = vec17.as_ptr() as i32;
                                                        let len17 = vec17.len() as i32;
                                                        ::core::mem::forget(vec17);
                                                        *((base + 4) as *mut i32) = len17;
                                                        *((base + 0) as *mut i32) = ptr17;
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V22;
                                                        match t16_1 {
                                                            V22::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V22::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V22::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V22::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V22::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V22::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec18 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr18 = vec18.as_ptr() as i32;
                                                                let len18 = vec18.len() as i32;
                                                                ::core::mem::forget(vec18);
                                                                *((base + 20) as *mut i32) = len18;
                                                                *((base + 16) as *mut i32) = ptr18;
                                                            }
                                                            V22::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec19 = (e).into_boxed_slice();
                                                                let ptr19 = vec19.as_ptr() as i32;
                                                                let len19 = vec19.len() as i32;
                                                                ::core::mem::forget(vec19);
                                                                *((base + 20) as *mut i32) = len19;
                                                                *((base + 16) as *mut i32) = ptr19;
                                                            }
                                                            V22::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index20,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                                            }
                                                            V22::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index21,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len23;
                                                *((base + 0) as *mut i32) = result23 as i32;
                                            }
                                        }
                                        *((ptr2 + 44) as *mut i32) = len24;
                                        *((ptr2 + 40) as *mut i32) = result24 as i32;
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((ptr2 + 8) as *mut u8) = (1i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_25,
                                        } = e;
                                        *((ptr2 + 16)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                        e,
                                    ) => {
                                        *((ptr2 + 8) as *mut u8) = (2i32) as u8;
                                        match e {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                e,
                                            ) => {
                                                *((ptr2 + 16) as *mut u8) = (0i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_26,
                                                } = e;
                                                *((ptr2 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                e,
                                            ) => {
                                                *((ptr2 + 16) as *mut u8) = (1i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_27,
                                                } = e;
                                                *((ptr2 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                e,
                                            ) => {
                                                *((ptr2 + 16) as *mut u8) = (2i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_28,
                                                } = e;
                                                *((ptr2 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                e,
                                            ) => {
                                                *((ptr2 + 16) as *mut u8) = (3i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_29,
                                                } = e;
                                                *((ptr2 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                e,
                                            ) => {
                                                *((ptr2 + 16) as *mut u8) = (4i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_30,
                                                } = e;
                                                *((ptr2 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_30);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                e,
                                            ) => {
                                                *((ptr2 + 16) as *mut u8) = (5i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_31,
                                                } = e;
                                                *((ptr2 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_31);
                                            }
                                        };
                                    }
                                };
                            }
                            Err(e) => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                                let vec32 = (e.into_bytes()).into_boxed_slice();
                                let ptr32 = vec32.as_ptr() as i32;
                                let len32 = vec32.len() as i32;
                                ::core::mem::forget(vec32);
                                *((ptr2 + 12) as *mut i32) = len32;
                                *((ptr2 + 8) as *mut i32) = ptr32;
                            }
                        };
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-array-get"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_array_get(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {
                                    let l1 = i32::from(*((arg0 + 8) as *const u8));
                                    match l1 {
                                        0 => {
                                            let l2 = i32::from(*((arg0 + 16) as *const u8));
                                            match l2 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l3 = *((arg0 + 24) as *const i32);
                                                    let l4 = *((arg0 + 28) as *const i32);
                                                    wit_bindgen::rt::dealloc(l3, (l4) as usize, 1);
                                                }
                                                6 => {
                                                    let l5 = *((arg0 + 24) as *const i32);
                                                    let l6 = *((arg0 + 28) as *const i32);
                                                    let base7 = l5;
                                                    let len7 = l6;
                                                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                            let l17 = *((arg0 + 32) as *const i32);
                                            let l18 = *((arg0 + 36) as *const i32);
                                            let base19 = l17;
                                            let len19 = l18;
                                            for i in 0..len19 {
                                                let base = base19 + i * 8;
                                                {
                                                    let l14 = *((base + 0) as *const i32);
                                                    let l15 = *((base + 4) as *const i32);
                                                    let base16 = l14;
                                                    let len16 = l15;
                                                    for i in 0..len16 {
                                                        let base = base16 + i * 16;
                                                        {
                                                            let l8 = i32::from(*((base + 0) as *const u8));
                                                            match l8 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l9 = *((base + 8) as *const i32);
                                                                    let l10 = *((base + 12) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l9, (l10) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l11 = *((base + 8) as *const i32);
                                                                    let l12 = *((base + 12) as *const i32);
                                                                    let base13 = l11;
                                                                    let len13 = l12;
                                                                    wit_bindgen::rt::dealloc(base13, (len13 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base16, (len16 as usize) * 16, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                                            let l31 = *((arg0 + 40) as *const i32);
                                            let l32 = *((arg0 + 44) as *const i32);
                                            let base33 = l31;
                                            let len33 = l32;
                                            for i in 0..len33 {
                                                let base = base33 + i * 8;
                                                {
                                                    let l28 = *((base + 0) as *const i32);
                                                    let l29 = *((base + 4) as *const i32);
                                                    let base30 = l28;
                                                    let len30 = l29;
                                                    for i in 0..len30 {
                                                        let base = base30 + i * 24;
                                                        {
                                                            let l20 = *((base + 0) as *const i32);
                                                            let l21 = *((base + 4) as *const i32);
                                                            wit_bindgen::rt::dealloc(l20, (l21) as usize, 1);
                                                            let l22 = i32::from(*((base + 8) as *const u8));
                                                            match l22 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l23 = *((base + 16) as *const i32);
                                                                    let l24 = *((base + 20) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l23, (l24) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l25 = *((base + 16) as *const i32);
                                                                    let l26 = *((base + 20) as *const i32);
                                                                    let base27 = l25;
                                                                    let len27 = l26;
                                                                    wit_bindgen::rt::dealloc(base27, (len27 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base30, (len30 as usize) * 24, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base33, (len33 as usize) * 8, 4);
                                        }
                                        1 => {}
                                        _ => {}
                                    }
                                }
                                _ => {
                                    let l34 = *((arg0 + 8) as *const i32);
                                    let l35 = *((arg0 + 12) as *const i32);
                                    wit_bindgen::rt::dealloc(l34, (l35) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-values"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_values(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_array_values(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec32 = result1;
                        let len32 = vec32.len() as i32;
                        let layout32 = alloc::Layout::from_size_align_unchecked(
                            vec32.len() * 40,
                            8,
                        );
                        let result32 = if layout32.size() != 0 {
                            let ptr = alloc::alloc(layout32);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout32);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec32.into_iter().enumerate() {
                            let base = result32 as i32 + (i as i32) * 40;
                            {
                                match e {
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item3,
                                            array_references: array_references3,
                                            map_references: map_references3,
                                        } = e;
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V8;
                                        match item3 {
                                            V8::Null => {
                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                            }
                                            V8::Undefined => {
                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                            }
                                            V8::Boolean(e) => {
                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                *((base + 16)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V8::Number(e) => {
                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V8::BigInt(e) => {
                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V8::Str(e) => {
                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                                let ptr4 = vec4.as_ptr() as i32;
                                                let len4 = vec4.len() as i32;
                                                ::core::mem::forget(vec4);
                                                *((base + 20) as *mut i32) = len4;
                                                *((base + 16) as *mut i32) = ptr4;
                                            }
                                            V8::Buffer(e) => {
                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                let vec5 = (e).into_boxed_slice();
                                                let ptr5 = vec5.as_ptr() as i32;
                                                let len5 = vec5.len() as i32;
                                                ::core::mem::forget(vec5);
                                                *((base + 20) as *mut i32) = len5;
                                                *((base + 16) as *mut i32) = ptr5;
                                            }
                                            V8::Array(e) => {
                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index6,
                                                } = e;
                                                *((base + 16)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index6);
                                            }
                                            V8::Map(e) => {
                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index7,
                                                } = e;
                                                *((base + 16)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                            }
                                        }
                                        let vec15 = array_references3;
                                        let len15 = vec15.len() as i32;
                                        let layout15 = alloc::Layout::from_size_align_unchecked(
                                            vec15.len() * 8,
                                            4,
                                        );
                                        let result15 = if layout15.size() != 0 {
                                            let ptr = alloc::alloc(layout15);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout15);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec15.into_iter().enumerate() {
                                            let base = result15 as i32 + (i as i32) * 8;
                                            {
                                                let vec14 = e;
                                                let len14 = vec14.len() as i32;
                                                let layout14 = alloc::Layout::from_size_align_unchecked(
                                                    vec14.len() * 16,
                                                    8,
                                                );
                                                let result14 = if layout14.size() != 0 {
                                                    let ptr = alloc::alloc(layout14);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout14);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec14.into_iter().enumerate() {
                                                    let base = result14 as i32 + (i as i32) * 16;
                                                    {
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V13;
                                                        match e {
                                                            V13::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V13::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V13::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V13::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V13::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V13::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec9 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr9 = vec9.as_ptr() as i32;
                                                                let len9 = vec9.len() as i32;
                                                                ::core::mem::forget(vec9);
                                                                *((base + 12) as *mut i32) = len9;
                                                                *((base + 8) as *mut i32) = ptr9;
                                                            }
                                                            V13::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec10 = (e).into_boxed_slice();
                                                                let ptr10 = vec10.as_ptr() as i32;
                                                                let len10 = vec10.len() as i32;
                                                                ::core::mem::forget(vec10);
                                                                *((base + 12) as *mut i32) = len10;
                                                                *((base + 8) as *mut i32) = ptr10;
                                                            }
                                                            V13::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index11,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                                            }
                                                            V13::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index12,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len14;
                                                *((base + 0) as *mut i32) = result14 as i32;
                                            }
                                        }
                                        *((base + 28) as *mut i32) = len15;
                                        *((base + 24) as *mut i32) = result15 as i32;
                                        let vec24 = map_references3;
                                        let len24 = vec24.len() as i32;
                                        let layout24 = alloc::Layout::from_size_align_unchecked(
                                            vec24.len() * 8,
                                            4,
                                        );
                                        let result24 = if layout24.size() != 0 {
                                            let ptr = alloc::alloc(layout24);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout24);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec24.into_iter().enumerate() {
                                            let base = result24 as i32 + (i as i32) * 8;
                                            {
                                                let vec23 = e;
                                                let len23 = vec23.len() as i32;
                                                let layout23 = alloc::Layout::from_size_align_unchecked(
                                                    vec23.len() * 24,
                                                    8,
                                                );
                                                let result23 = if layout23.size() != 0 {
                                                    let ptr = alloc::alloc(layout23);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout23);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec23.into_iter().enumerate() {
                                                    let base = result23 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t16_0, t16_1) = e;
                                                        let vec17 = (t16_0.into_bytes()).into_boxed_slice();
                                                        let ptr17 = vec17.as_ptr() as i32;
                                                        let len17 = vec17.len() as i32;
                                                        ::core::mem::forget(vec17);
                                                        *((base + 4) as *mut i32) = len17;
                                                        *((base + 0) as *mut i32) = ptr17;
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V22;
                                                        match t16_1 {
                                                            V22::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V22::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V22::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V22::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V22::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V22::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec18 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr18 = vec18.as_ptr() as i32;
                                                                let len18 = vec18.len() as i32;
                                                                ::core::mem::forget(vec18);
                                                                *((base + 20) as *mut i32) = len18;
                                                                *((base + 16) as *mut i32) = ptr18;
                                                            }
                                                            V22::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec19 = (e).into_boxed_slice();
                                                                let ptr19 = vec19.as_ptr() as i32;
                                                                let len19 = vec19.len() as i32;
                                                                ::core::mem::forget(vec19);
                                                                *((base + 20) as *mut i32) = len19;
                                                                *((base + 16) as *mut i32) = ptr19;
                                                            }
                                                            V22::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index20,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                                            }
                                                            V22::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index21,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len23;
                                                *((base + 0) as *mut i32) = result23 as i32;
                                            }
                                        }
                                        *((base + 36) as *mut i32) = len24;
                                        *((base + 32) as *mut i32) = result24 as i32;
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_25,
                                        } = e;
                                        *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(ref_25);
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                        e,
                                    ) => {
                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                        match e {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                e,
                                            ) => {
                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_26,
                                                } = e;
                                                *((base + 12)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                e,
                                            ) => {
                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_27,
                                                } = e;
                                                *((base + 12)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                e,
                                            ) => {
                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_28,
                                                } = e;
                                                *((base + 12)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_29,
                                                } = e;
                                                *((base + 12)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_30,
                                                } = e;
                                                *((base + 12)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_30);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_31,
                                                } = e;
                                                *((base + 12)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_31);
                                            }
                                        };
                                    }
                                };
                            }
                        }
                        *((ptr2 + 4) as *mut i32) = len32;
                        *((ptr2 + 0) as *mut i32) = result32 as i32;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-array-values"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_array_values(arg0: i32) {
                            let l33 = *((arg0 + 0) as *const i32);
                            let l34 = *((arg0 + 4) as *const i32);
                            let base35 = l33;
                            let len35 = l34;
                            for i in 0..len35 {
                                let base = base35 + i * 40;
                                {
                                    let l0 = i32::from(*((base + 0) as *const u8));
                                    match l0 {
                                        0 => {
                                            let l1 = i32::from(*((base + 8) as *const u8));
                                            match l1 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l2 = *((base + 16) as *const i32);
                                                    let l3 = *((base + 20) as *const i32);
                                                    wit_bindgen::rt::dealloc(l2, (l3) as usize, 1);
                                                }
                                                6 => {
                                                    let l4 = *((base + 16) as *const i32);
                                                    let l5 = *((base + 20) as *const i32);
                                                    let base6 = l4;
                                                    let len6 = l5;
                                                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                            let l16 = *((base + 24) as *const i32);
                                            let l17 = *((base + 28) as *const i32);
                                            let base18 = l16;
                                            let len18 = l17;
                                            for i in 0..len18 {
                                                let base = base18 + i * 8;
                                                {
                                                    let l13 = *((base + 0) as *const i32);
                                                    let l14 = *((base + 4) as *const i32);
                                                    let base15 = l13;
                                                    let len15 = l14;
                                                    for i in 0..len15 {
                                                        let base = base15 + i * 16;
                                                        {
                                                            let l7 = i32::from(*((base + 0) as *const u8));
                                                            match l7 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l8 = *((base + 8) as *const i32);
                                                                    let l9 = *((base + 12) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l8, (l9) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l10 = *((base + 8) as *const i32);
                                                                    let l11 = *((base + 12) as *const i32);
                                                                    let base12 = l10;
                                                                    let len12 = l11;
                                                                    wit_bindgen::rt::dealloc(base12, (len12 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base15, (len15 as usize) * 16, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base18, (len18 as usize) * 8, 4);
                                            let l30 = *((base + 32) as *const i32);
                                            let l31 = *((base + 36) as *const i32);
                                            let base32 = l30;
                                            let len32 = l31;
                                            for i in 0..len32 {
                                                let base = base32 + i * 8;
                                                {
                                                    let l27 = *((base + 0) as *const i32);
                                                    let l28 = *((base + 4) as *const i32);
                                                    let base29 = l27;
                                                    let len29 = l28;
                                                    for i in 0..len29 {
                                                        let base = base29 + i * 24;
                                                        {
                                                            let l19 = *((base + 0) as *const i32);
                                                            let l20 = *((base + 4) as *const i32);
                                                            wit_bindgen::rt::dealloc(l19, (l20) as usize, 1);
                                                            let l21 = i32::from(*((base + 8) as *const u8));
                                                            match l21 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l22 = *((base + 16) as *const i32);
                                                                    let l23 = *((base + 20) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l22, (l23) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l24 = *((base + 16) as *const i32);
                                                                    let l25 = *((base + 20) as *const i32);
                                                                    let base26 = l24;
                                                                    let len26 = l25;
                                                                    wit_bindgen::rt::dealloc(base26, (len26 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base29, (len29 as usize) * 24, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base32, (len32 as usize) * 8, 4);
                                        }
                                        1 => {}
                                        _ => {}
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base35, (len35 as usize) * 40, 8);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-observe"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_observe(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_array_observe(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-array-observe-deep"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_array_observe_deep(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_array_observe_deep(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-new"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_new(
                        arg0: i32,
                        arg1: i32,
                        arg2: i64,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result40 = <YDocMethodsImpl as YDocMethods>::y_map_new(
                            match arg0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V2;
                                        let v2 = match arg1 {
                                            0 => V2::Null,
                                            1 => V2::Undefined,
                                            2 => {
                                                let e2 = wit_bindgen::rt::bool_lift(arg2 as i32 as u8);
                                                V2::Boolean(e2)
                                            }
                                            3 => {
                                                let e2 = f64::from_bits(arg2 as u64);
                                                V2::Number(e2)
                                            }
                                            4 => {
                                                let e2 = arg2;
                                                V2::BigInt(e2)
                                            }
                                            5 => {
                                                let e2 = {
                                                    let len0 = arg3 as usize;
                                                    let bytes0 = Vec::from_raw_parts(
                                                        arg2 as i32 as *mut _,
                                                        len0,
                                                        len0,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes0)
                                                };
                                                V2::Str(e2)
                                            }
                                            6 => {
                                                let e2 = {
                                                    let len1 = arg3 as usize;
                                                    Vec::from_raw_parts(arg2 as i32 as *mut _, len1, len1)
                                                };
                                                V2::Buffer(e2)
                                            }
                                            7 => {
                                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: arg2 as i32 as u32,
                                                };
                                                V2::Array(e2)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e2 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: arg2 as i32 as u32,
                                                };
                                                V2::Map(e2)
                                            }
                                        };
                                        let base19 = arg4;
                                        let len19 = arg5;
                                        let mut result19 = Vec::with_capacity(len19 as usize);
                                        for i in 0..len19 {
                                            let base = base19 + i * 8;
                                            let e19 = {
                                                let l3 = *((base + 0) as *const i32);
                                                let l4 = *((base + 4) as *const i32);
                                                let base18 = l3;
                                                let len18 = l4;
                                                let mut result18 = Vec::with_capacity(len18 as usize);
                                                for i in 0..len18 {
                                                    let base = base18 + i * 16;
                                                    let e18 = {
                                                        let l5 = i32::from(*((base + 0) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V17;
                                                        let v17 = match l5 {
                                                            0 => V17::Null,
                                                            1 => V17::Undefined,
                                                            2 => {
                                                                let e17 = {
                                                                    let l6 = i32::from(*((base + 8) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l6 as u8)
                                                                };
                                                                V17::Boolean(e17)
                                                            }
                                                            3 => {
                                                                let e17 = {
                                                                    let l7 = *((base + 8) as *const f64);
                                                                    l7
                                                                };
                                                                V17::Number(e17)
                                                            }
                                                            4 => {
                                                                let e17 = {
                                                                    let l8 = *((base + 8) as *const i64);
                                                                    l8
                                                                };
                                                                V17::BigInt(e17)
                                                            }
                                                            5 => {
                                                                let e17 = {
                                                                    let l9 = *((base + 8) as *const i32);
                                                                    let l10 = *((base + 12) as *const i32);
                                                                    let len11 = l10 as usize;
                                                                    let bytes11 = Vec::from_raw_parts(
                                                                        l9 as *mut _,
                                                                        len11,
                                                                        len11,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes11)
                                                                };
                                                                V17::Str(e17)
                                                            }
                                                            6 => {
                                                                let e17 = {
                                                                    let l12 = *((base + 8) as *const i32);
                                                                    let l13 = *((base + 12) as *const i32);
                                                                    let len14 = l13 as usize;
                                                                    Vec::from_raw_parts(l12 as *mut _, len14, len14)
                                                                };
                                                                V17::Buffer(e17)
                                                            }
                                                            7 => {
                                                                let e17 = {
                                                                    let l15 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l15 as u32,
                                                                    }
                                                                };
                                                                V17::Array(e17)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e17 = {
                                                                    let l16 = *((base + 8) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l16 as u32,
                                                                    }
                                                                };
                                                                V17::Map(e17)
                                                            }
                                                        };
                                                        v17
                                                    };
                                                    result18.push(e18);
                                                }
                                                wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                                                result18
                                            };
                                            result19.push(e19);
                                        }
                                        wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                                        let base39 = arg6;
                                        let len39 = arg7;
                                        let mut result39 = Vec::with_capacity(len39 as usize);
                                        for i in 0..len39 {
                                            let base = base39 + i * 8;
                                            let e39 = {
                                                let l20 = *((base + 0) as *const i32);
                                                let l21 = *((base + 4) as *const i32);
                                                let base38 = l20;
                                                let len38 = l21;
                                                let mut result38 = Vec::with_capacity(len38 as usize);
                                                for i in 0..len38 {
                                                    let base = base38 + i * 24;
                                                    let e38 = {
                                                        let l22 = *((base + 0) as *const i32);
                                                        let l23 = *((base + 4) as *const i32);
                                                        let len24 = l23 as usize;
                                                        let bytes24 = Vec::from_raw_parts(
                                                            l22 as *mut _,
                                                            len24,
                                                            len24,
                                                        );
                                                        let l25 = i32::from(*((base + 8) as *const u8));
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V37;
                                                        let v37 = match l25 {
                                                            0 => V37::Null,
                                                            1 => V37::Undefined,
                                                            2 => {
                                                                let e37 = {
                                                                    let l26 = i32::from(*((base + 16) as *const u8));
                                                                    wit_bindgen::rt::bool_lift(l26 as u8)
                                                                };
                                                                V37::Boolean(e37)
                                                            }
                                                            3 => {
                                                                let e37 = {
                                                                    let l27 = *((base + 16) as *const f64);
                                                                    l27
                                                                };
                                                                V37::Number(e37)
                                                            }
                                                            4 => {
                                                                let e37 = {
                                                                    let l28 = *((base + 16) as *const i64);
                                                                    l28
                                                                };
                                                                V37::BigInt(e37)
                                                            }
                                                            5 => {
                                                                let e37 = {
                                                                    let l29 = *((base + 16) as *const i32);
                                                                    let l30 = *((base + 20) as *const i32);
                                                                    let len31 = l30 as usize;
                                                                    let bytes31 = Vec::from_raw_parts(
                                                                        l29 as *mut _,
                                                                        len31,
                                                                        len31,
                                                                    );
                                                                    wit_bindgen::rt::string_lift(bytes31)
                                                                };
                                                                V37::Str(e37)
                                                            }
                                                            6 => {
                                                                let e37 = {
                                                                    let l32 = *((base + 16) as *const i32);
                                                                    let l33 = *((base + 20) as *const i32);
                                                                    let len34 = l33 as usize;
                                                                    Vec::from_raw_parts(l32 as *mut _, len34, len34)
                                                                };
                                                                V37::Buffer(e37)
                                                            }
                                                            7 => {
                                                                let e37 = {
                                                                    let l35 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                        index: l35 as u32,
                                                                    }
                                                                };
                                                                V37::Array(e37)
                                                            }
                                                            n => {
                                                                if true {
                                                                    match (&n, &8) {
                                                                        (left_val, right_val) => {
                                                                            if !(*left_val == *right_val) {
                                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                                ::core::panicking::assert_failed(
                                                                                    kind,
                                                                                    &*left_val,
                                                                                    &*right_val,
                                                                                    ::core::option::Option::Some(
                                                                                        format_args!("invalid enum discriminant"),
                                                                                    ),
                                                                                );
                                                                            }
                                                                        }
                                                                    };
                                                                }
                                                                let e37 = {
                                                                    let l36 = *((base + 16) as *const i32);
                                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                        index: l36 as u32,
                                                                    }
                                                                };
                                                                V37::Map(e37)
                                                            }
                                                        };
                                                        (wit_bindgen::rt::string_lift(bytes24), v37)
                                                    };
                                                    result38.push(e38);
                                                }
                                                wit_bindgen::rt::dealloc(base38, (len38 as usize) * 24, 8);
                                                result38
                                            };
                                            result39.push(e39);
                                        }
                                        wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                                        super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: v2,
                                            array_references: result19,
                                            map_references: result39,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: ref_41,
                        } = result40;
                        wit_bindgen::rt::as_i32(ref_41)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-prelim"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_prelim(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_map_prelim(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-length"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_length(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_map_length(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::as_i32(result1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-to-json"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_to_json(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_map_to_json(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                            item: item3,
                            array_references: array_references3,
                            map_references: map_references3,
                        } = result1;
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V8;
                        match item3 {
                            V8::Null => {
                                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                            }
                            V8::Undefined => {
                                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                            }
                            V8::Boolean(e) => {
                                *((ptr2 + 0) as *mut u8) = (2i32) as u8;
                                *((ptr2 + 8)
                                    as *mut u8) = (match e {
                                    true => 1,
                                    false => 0,
                                }) as u8;
                            }
                            V8::Number(e) => {
                                *((ptr2 + 0) as *mut u8) = (3i32) as u8;
                                *((ptr2 + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                            }
                            V8::BigInt(e) => {
                                *((ptr2 + 0) as *mut u8) = (4i32) as u8;
                                *((ptr2 + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            }
                            V8::Str(e) => {
                                *((ptr2 + 0) as *mut u8) = (5i32) as u8;
                                let vec4 = (e.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((ptr2 + 12) as *mut i32) = len4;
                                *((ptr2 + 8) as *mut i32) = ptr4;
                            }
                            V8::Buffer(e) => {
                                *((ptr2 + 0) as *mut u8) = (6i32) as u8;
                                let vec5 = (e).into_boxed_slice();
                                let ptr5 = vec5.as_ptr() as i32;
                                let len5 = vec5.len() as i32;
                                ::core::mem::forget(vec5);
                                *((ptr2 + 12) as *mut i32) = len5;
                                *((ptr2 + 8) as *mut i32) = ptr5;
                            }
                            V8::Array(e) => {
                                *((ptr2 + 0) as *mut u8) = (7i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                    index: index6,
                                } = e;
                                *((ptr2 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index6);
                            }
                            V8::Map(e) => {
                                *((ptr2 + 0) as *mut u8) = (8i32) as u8;
                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                    index: index7,
                                } = e;
                                *((ptr2 + 8) as *mut i32) = wit_bindgen::rt::as_i32(index7);
                            }
                        }
                        let vec15 = array_references3;
                        let len15 = vec15.len() as i32;
                        let layout15 = alloc::Layout::from_size_align_unchecked(
                            vec15.len() * 8,
                            4,
                        );
                        let result15 = if layout15.size() != 0 {
                            let ptr = alloc::alloc(layout15);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout15);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec15.into_iter().enumerate() {
                            let base = result15 as i32 + (i as i32) * 8;
                            {
                                let vec14 = e;
                                let len14 = vec14.len() as i32;
                                let layout14 = alloc::Layout::from_size_align_unchecked(
                                    vec14.len() * 16,
                                    8,
                                );
                                let result14 = if layout14.size() != 0 {
                                    let ptr = alloc::alloc(layout14);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout14);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec14.into_iter().enumerate() {
                                    let base = result14 as i32 + (i as i32) * 16;
                                    {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V13;
                                        match e {
                                            V13::Null => {
                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                            }
                                            V13::Undefined => {
                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                            }
                                            V13::Boolean(e) => {
                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                *((base + 8)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V13::Number(e) => {
                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V13::BigInt(e) => {
                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V13::Str(e) => {
                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                let vec9 = (e.into_bytes()).into_boxed_slice();
                                                let ptr9 = vec9.as_ptr() as i32;
                                                let len9 = vec9.len() as i32;
                                                ::core::mem::forget(vec9);
                                                *((base + 12) as *mut i32) = len9;
                                                *((base + 8) as *mut i32) = ptr9;
                                            }
                                            V13::Buffer(e) => {
                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                let vec10 = (e).into_boxed_slice();
                                                let ptr10 = vec10.as_ptr() as i32;
                                                let len10 = vec10.len() as i32;
                                                ::core::mem::forget(vec10);
                                                *((base + 12) as *mut i32) = len10;
                                                *((base + 8) as *mut i32) = ptr10;
                                            }
                                            V13::Array(e) => {
                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index11,
                                                } = e;
                                                *((base + 8)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index11);
                                            }
                                            V13::Map(e) => {
                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index12,
                                                } = e;
                                                *((base + 8)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                            }
                                        }
                                    }
                                }
                                *((base + 4) as *mut i32) = len14;
                                *((base + 0) as *mut i32) = result14 as i32;
                            }
                        }
                        *((ptr2 + 20) as *mut i32) = len15;
                        *((ptr2 + 16) as *mut i32) = result15 as i32;
                        let vec24 = map_references3;
                        let len24 = vec24.len() as i32;
                        let layout24 = alloc::Layout::from_size_align_unchecked(
                            vec24.len() * 8,
                            4,
                        );
                        let result24 = if layout24.size() != 0 {
                            let ptr = alloc::alloc(layout24);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout24);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec24.into_iter().enumerate() {
                            let base = result24 as i32 + (i as i32) * 8;
                            {
                                let vec23 = e;
                                let len23 = vec23.len() as i32;
                                let layout23 = alloc::Layout::from_size_align_unchecked(
                                    vec23.len() * 24,
                                    8,
                                );
                                let result23 = if layout23.size() != 0 {
                                    let ptr = alloc::alloc(layout23);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout23);
                                    }
                                    ptr
                                } else {
                                    ::core::ptr::null_mut()
                                };
                                for (i, e) in vec23.into_iter().enumerate() {
                                    let base = result23 as i32 + (i as i32) * 24;
                                    {
                                        let (t16_0, t16_1) = e;
                                        let vec17 = (t16_0.into_bytes()).into_boxed_slice();
                                        let ptr17 = vec17.as_ptr() as i32;
                                        let len17 = vec17.len() as i32;
                                        ::core::mem::forget(vec17);
                                        *((base + 4) as *mut i32) = len17;
                                        *((base + 0) as *mut i32) = ptr17;
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V22;
                                        match t16_1 {
                                            V22::Null => {
                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                            }
                                            V22::Undefined => {
                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                            }
                                            V22::Boolean(e) => {
                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                *((base + 16)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V22::Number(e) => {
                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V22::BigInt(e) => {
                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V22::Str(e) => {
                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                let vec18 = (e.into_bytes()).into_boxed_slice();
                                                let ptr18 = vec18.as_ptr() as i32;
                                                let len18 = vec18.len() as i32;
                                                ::core::mem::forget(vec18);
                                                *((base + 20) as *mut i32) = len18;
                                                *((base + 16) as *mut i32) = ptr18;
                                            }
                                            V22::Buffer(e) => {
                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                let vec19 = (e).into_boxed_slice();
                                                let ptr19 = vec19.as_ptr() as i32;
                                                let len19 = vec19.len() as i32;
                                                ::core::mem::forget(vec19);
                                                *((base + 20) as *mut i32) = len19;
                                                *((base + 16) as *mut i32) = ptr19;
                                            }
                                            V22::Array(e) => {
                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index20,
                                                } = e;
                                                *((base + 16)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index20);
                                            }
                                            V22::Map(e) => {
                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index21,
                                                } = e;
                                                *((base + 16)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                            }
                                        }
                                    }
                                }
                                *((base + 4) as *mut i32) = len23;
                                *((base + 0) as *mut i32) = result23 as i32;
                            }
                        }
                        *((ptr2 + 28) as *mut i32) = len24;
                        *((ptr2 + 24) as *mut i32) = result24 as i32;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-map-to-json"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_map_to_json(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                1 => {}
                                2 => {}
                                3 => {}
                                4 => {}
                                5 => {
                                    let l1 = *((arg0 + 8) as *const i32);
                                    let l2 = *((arg0 + 12) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                                6 => {
                                    let l3 = *((arg0 + 8) as *const i32);
                                    let l4 = *((arg0 + 12) as *const i32);
                                    let base5 = l3;
                                    let len5 = l4;
                                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 1, 1);
                                }
                                7 => {}
                                _ => {}
                            }
                            let l15 = *((arg0 + 16) as *const i32);
                            let l16 = *((arg0 + 20) as *const i32);
                            let base17 = l15;
                            let len17 = l16;
                            for i in 0..len17 {
                                let base = base17 + i * 8;
                                {
                                    let l12 = *((base + 0) as *const i32);
                                    let l13 = *((base + 4) as *const i32);
                                    let base14 = l12;
                                    let len14 = l13;
                                    for i in 0..len14 {
                                        let base = base14 + i * 16;
                                        {
                                            let l6 = i32::from(*((base + 0) as *const u8));
                                            match l6 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l7 = *((base + 8) as *const i32);
                                                    let l8 = *((base + 12) as *const i32);
                                                    wit_bindgen::rt::dealloc(l7, (l8) as usize, 1);
                                                }
                                                6 => {
                                                    let l9 = *((base + 8) as *const i32);
                                                    let l10 = *((base + 12) as *const i32);
                                                    let base11 = l9;
                                                    let len11 = l10;
                                                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base14, (len14 as usize) * 16, 8);
                                }
                            }
                            wit_bindgen::rt::dealloc(base17, (len17 as usize) * 8, 4);
                            let l29 = *((arg0 + 24) as *const i32);
                            let l30 = *((arg0 + 28) as *const i32);
                            let base31 = l29;
                            let len31 = l30;
                            for i in 0..len31 {
                                let base = base31 + i * 8;
                                {
                                    let l26 = *((base + 0) as *const i32);
                                    let l27 = *((base + 4) as *const i32);
                                    let base28 = l26;
                                    let len28 = l27;
                                    for i in 0..len28 {
                                        let base = base28 + i * 24;
                                        {
                                            let l18 = *((base + 0) as *const i32);
                                            let l19 = *((base + 4) as *const i32);
                                            wit_bindgen::rt::dealloc(l18, (l19) as usize, 1);
                                            let l20 = i32::from(*((base + 8) as *const u8));
                                            match l20 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l21 = *((base + 16) as *const i32);
                                                    let l22 = *((base + 20) as *const i32);
                                                    wit_bindgen::rt::dealloc(l21, (l22) as usize, 1);
                                                }
                                                6 => {
                                                    let l23 = *((base + 16) as *const i32);
                                                    let l24 = *((base + 20) as *const i32);
                                                    let base25 = l23;
                                                    let len25 = l24;
                                                    wit_bindgen::rt::dealloc(base25, (len25 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                        }
                                    }
                                    wit_bindgen::rt::dealloc(base28, (len28 as usize) * 24, 8);
                                }
                            }
                            wit_bindgen::rt::dealloc(base31, (len31 as usize) * 8, 4);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-set"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_set(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i64,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                        arg10: i32,
                        arg11: i32,
                        arg12: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V3;
                        let v3 = match arg3 {
                            0 => V3::Null,
                            1 => V3::Undefined,
                            2 => {
                                let e3 = wit_bindgen::rt::bool_lift(arg4 as i32 as u8);
                                V3::Boolean(e3)
                            }
                            3 => {
                                let e3 = f64::from_bits(arg4 as u64);
                                V3::Number(e3)
                            }
                            4 => {
                                let e3 = arg4;
                                V3::BigInt(e3)
                            }
                            5 => {
                                let e3 = {
                                    let len1 = arg5 as usize;
                                    let bytes1 = Vec::from_raw_parts(
                                        arg4 as i32 as *mut _,
                                        len1,
                                        len1,
                                    );
                                    wit_bindgen::rt::string_lift(bytes1)
                                };
                                V3::Str(e3)
                            }
                            6 => {
                                let e3 = {
                                    let len2 = arg5 as usize;
                                    Vec::from_raw_parts(arg4 as i32 as *mut _, len2, len2)
                                };
                                V3::Buffer(e3)
                            }
                            7 => {
                                let e3 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                    index: arg4 as i32 as u32,
                                };
                                V3::Array(e3)
                            }
                            n => {
                                if true {
                                    match (&n, &8) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e3 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                    index: arg4 as i32 as u32,
                                };
                                V3::Map(e3)
                            }
                        };
                        let base20 = arg6;
                        let len20 = arg7;
                        let mut result20 = Vec::with_capacity(len20 as usize);
                        for i in 0..len20 {
                            let base = base20 + i * 8;
                            let e20 = {
                                let l4 = *((base + 0) as *const i32);
                                let l5 = *((base + 4) as *const i32);
                                let base19 = l4;
                                let len19 = l5;
                                let mut result19 = Vec::with_capacity(len19 as usize);
                                for i in 0..len19 {
                                    let base = base19 + i * 16;
                                    let e19 = {
                                        let l6 = i32::from(*((base + 0) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V18;
                                        let v18 = match l6 {
                                            0 => V18::Null,
                                            1 => V18::Undefined,
                                            2 => {
                                                let e18 = {
                                                    let l7 = i32::from(*((base + 8) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l7 as u8)
                                                };
                                                V18::Boolean(e18)
                                            }
                                            3 => {
                                                let e18 = {
                                                    let l8 = *((base + 8) as *const f64);
                                                    l8
                                                };
                                                V18::Number(e18)
                                            }
                                            4 => {
                                                let e18 = {
                                                    let l9 = *((base + 8) as *const i64);
                                                    l9
                                                };
                                                V18::BigInt(e18)
                                            }
                                            5 => {
                                                let e18 = {
                                                    let l10 = *((base + 8) as *const i32);
                                                    let l11 = *((base + 12) as *const i32);
                                                    let len12 = l11 as usize;
                                                    let bytes12 = Vec::from_raw_parts(
                                                        l10 as *mut _,
                                                        len12,
                                                        len12,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes12)
                                                };
                                                V18::Str(e18)
                                            }
                                            6 => {
                                                let e18 = {
                                                    let l13 = *((base + 8) as *const i32);
                                                    let l14 = *((base + 12) as *const i32);
                                                    let len15 = l14 as usize;
                                                    Vec::from_raw_parts(l13 as *mut _, len15, len15)
                                                };
                                                V18::Buffer(e18)
                                            }
                                            7 => {
                                                let e18 = {
                                                    let l16 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l16 as u32,
                                                    }
                                                };
                                                V18::Array(e18)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e18 = {
                                                    let l17 = *((base + 8) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l17 as u32,
                                                    }
                                                };
                                                V18::Map(e18)
                                            }
                                        };
                                        v18
                                    };
                                    result19.push(e19);
                                }
                                wit_bindgen::rt::dealloc(base19, (len19 as usize) * 16, 8);
                                result19
                            };
                            result20.push(e20);
                        }
                        wit_bindgen::rt::dealloc(base20, (len20 as usize) * 8, 4);
                        let base40 = arg8;
                        let len40 = arg9;
                        let mut result40 = Vec::with_capacity(len40 as usize);
                        for i in 0..len40 {
                            let base = base40 + i * 8;
                            let e40 = {
                                let l21 = *((base + 0) as *const i32);
                                let l22 = *((base + 4) as *const i32);
                                let base39 = l21;
                                let len39 = l22;
                                let mut result39 = Vec::with_capacity(len39 as usize);
                                for i in 0..len39 {
                                    let base = base39 + i * 24;
                                    let e39 = {
                                        let l23 = *((base + 0) as *const i32);
                                        let l24 = *((base + 4) as *const i32);
                                        let len25 = l24 as usize;
                                        let bytes25 = Vec::from_raw_parts(
                                            l23 as *mut _,
                                            len25,
                                            len25,
                                        );
                                        let l26 = i32::from(*((base + 8) as *const u8));
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V38;
                                        let v38 = match l26 {
                                            0 => V38::Null,
                                            1 => V38::Undefined,
                                            2 => {
                                                let e38 = {
                                                    let l27 = i32::from(*((base + 16) as *const u8));
                                                    wit_bindgen::rt::bool_lift(l27 as u8)
                                                };
                                                V38::Boolean(e38)
                                            }
                                            3 => {
                                                let e38 = {
                                                    let l28 = *((base + 16) as *const f64);
                                                    l28
                                                };
                                                V38::Number(e38)
                                            }
                                            4 => {
                                                let e38 = {
                                                    let l29 = *((base + 16) as *const i64);
                                                    l29
                                                };
                                                V38::BigInt(e38)
                                            }
                                            5 => {
                                                let e38 = {
                                                    let l30 = *((base + 16) as *const i32);
                                                    let l31 = *((base + 20) as *const i32);
                                                    let len32 = l31 as usize;
                                                    let bytes32 = Vec::from_raw_parts(
                                                        l30 as *mut _,
                                                        len32,
                                                        len32,
                                                    );
                                                    wit_bindgen::rt::string_lift(bytes32)
                                                };
                                                V38::Str(e38)
                                            }
                                            6 => {
                                                let e38 = {
                                                    let l33 = *((base + 16) as *const i32);
                                                    let l34 = *((base + 20) as *const i32);
                                                    let len35 = l34 as usize;
                                                    Vec::from_raw_parts(l33 as *mut _, len35, len35)
                                                };
                                                V38::Buffer(e38)
                                            }
                                            7 => {
                                                let e38 = {
                                                    let l36 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                        index: l36 as u32,
                                                    }
                                                };
                                                V38::Array(e38)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &8) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e38 = {
                                                    let l37 = *((base + 16) as *const i32);
                                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                        index: l37 as u32,
                                                    }
                                                };
                                                V38::Map(e38)
                                            }
                                        };
                                        (wit_bindgen::rt::string_lift(bytes25), v38)
                                    };
                                    result39.push(e39);
                                }
                                wit_bindgen::rt::dealloc(base39, (len39 as usize) * 24, 8);
                                result39
                            };
                            result40.push(e40);
                        }
                        wit_bindgen::rt::dealloc(base40, (len40 as usize) * 8, 4);
                        <YDocMethodsImpl as YDocMethods>::y_map_set(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                item: v3,
                                array_references: result20,
                                map_references: result40,
                            },
                            match arg10 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V41;
                                        let v41 = match arg11 {
                                            0 => {
                                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg12 as u32,
                                                };
                                                V41::ReadTransaction(e41)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e41 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg12 as u32,
                                                };
                                                V41::WriteTransaction(e41)
                                            }
                                        };
                                        v41
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-delete"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_delete(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        <YDocMethodsImpl as YDocMethods>::y_map_delete(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V1;
                                        let v1 = match arg4 {
                                            0 => {
                                                let e1 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V1::ReadTransaction(e1)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e1 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V1::WriteTransaction(e1)
                                            }
                                        };
                                        v1
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-get"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_get(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
                        let result2 = <YDocMethodsImpl as YDocMethods>::y_map_get(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            wit_bindgen::rt::string_lift(bytes0),
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V1;
                                        let v1 = match arg4 {
                                            0 => {
                                                let e1 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V1::ReadTransaction(e1)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e1 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V1::WriteTransaction(e1)
                                            }
                                        };
                                        v1
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result2 {
                            Some(e) => {
                                *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                                match e {
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((ptr3 + 8) as *mut u8) = (0i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item4,
                                            array_references: array_references4,
                                            map_references: map_references4,
                                        } = e;
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V9;
                                        match item4 {
                                            V9::Null => {
                                                *((ptr3 + 16) as *mut u8) = (0i32) as u8;
                                            }
                                            V9::Undefined => {
                                                *((ptr3 + 16) as *mut u8) = (1i32) as u8;
                                            }
                                            V9::Boolean(e) => {
                                                *((ptr3 + 16) as *mut u8) = (2i32) as u8;
                                                *((ptr3 + 24)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V9::Number(e) => {
                                                *((ptr3 + 16) as *mut u8) = (3i32) as u8;
                                                *((ptr3 + 24) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V9::BigInt(e) => {
                                                *((ptr3 + 16) as *mut u8) = (4i32) as u8;
                                                *((ptr3 + 24) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V9::Str(e) => {
                                                *((ptr3 + 16) as *mut u8) = (5i32) as u8;
                                                let vec5 = (e.into_bytes()).into_boxed_slice();
                                                let ptr5 = vec5.as_ptr() as i32;
                                                let len5 = vec5.len() as i32;
                                                ::core::mem::forget(vec5);
                                                *((ptr3 + 28) as *mut i32) = len5;
                                                *((ptr3 + 24) as *mut i32) = ptr5;
                                            }
                                            V9::Buffer(e) => {
                                                *((ptr3 + 16) as *mut u8) = (6i32) as u8;
                                                let vec6 = (e).into_boxed_slice();
                                                let ptr6 = vec6.as_ptr() as i32;
                                                let len6 = vec6.len() as i32;
                                                ::core::mem::forget(vec6);
                                                *((ptr3 + 28) as *mut i32) = len6;
                                                *((ptr3 + 24) as *mut i32) = ptr6;
                                            }
                                            V9::Array(e) => {
                                                *((ptr3 + 16) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index7,
                                                } = e;
                                                *((ptr3 + 24)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index7);
                                            }
                                            V9::Map(e) => {
                                                *((ptr3 + 16) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index8,
                                                } = e;
                                                *((ptr3 + 24)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index8);
                                            }
                                        }
                                        let vec16 = array_references4;
                                        let len16 = vec16.len() as i32;
                                        let layout16 = alloc::Layout::from_size_align_unchecked(
                                            vec16.len() * 8,
                                            4,
                                        );
                                        let result16 = if layout16.size() != 0 {
                                            let ptr = alloc::alloc(layout16);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout16);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec16.into_iter().enumerate() {
                                            let base = result16 as i32 + (i as i32) * 8;
                                            {
                                                let vec15 = e;
                                                let len15 = vec15.len() as i32;
                                                let layout15 = alloc::Layout::from_size_align_unchecked(
                                                    vec15.len() * 16,
                                                    8,
                                                );
                                                let result15 = if layout15.size() != 0 {
                                                    let ptr = alloc::alloc(layout15);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout15);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec15.into_iter().enumerate() {
                                                    let base = result15 as i32 + (i as i32) * 16;
                                                    {
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V14;
                                                        match e {
                                                            V14::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V14::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V14::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V14::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V14::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V14::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec10 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr10 = vec10.as_ptr() as i32;
                                                                let len10 = vec10.len() as i32;
                                                                ::core::mem::forget(vec10);
                                                                *((base + 12) as *mut i32) = len10;
                                                                *((base + 8) as *mut i32) = ptr10;
                                                            }
                                                            V14::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec11 = (e).into_boxed_slice();
                                                                let ptr11 = vec11.as_ptr() as i32;
                                                                let len11 = vec11.len() as i32;
                                                                ::core::mem::forget(vec11);
                                                                *((base + 12) as *mut i32) = len11;
                                                                *((base + 8) as *mut i32) = ptr11;
                                                            }
                                                            V14::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index12,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index12);
                                                            }
                                                            V14::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index13,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index13);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len15;
                                                *((base + 0) as *mut i32) = result15 as i32;
                                            }
                                        }
                                        *((ptr3 + 36) as *mut i32) = len16;
                                        *((ptr3 + 32) as *mut i32) = result16 as i32;
                                        let vec25 = map_references4;
                                        let len25 = vec25.len() as i32;
                                        let layout25 = alloc::Layout::from_size_align_unchecked(
                                            vec25.len() * 8,
                                            4,
                                        );
                                        let result25 = if layout25.size() != 0 {
                                            let ptr = alloc::alloc(layout25);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout25);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec25.into_iter().enumerate() {
                                            let base = result25 as i32 + (i as i32) * 8;
                                            {
                                                let vec24 = e;
                                                let len24 = vec24.len() as i32;
                                                let layout24 = alloc::Layout::from_size_align_unchecked(
                                                    vec24.len() * 24,
                                                    8,
                                                );
                                                let result24 = if layout24.size() != 0 {
                                                    let ptr = alloc::alloc(layout24);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout24);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec24.into_iter().enumerate() {
                                                    let base = result24 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t17_0, t17_1) = e;
                                                        let vec18 = (t17_0.into_bytes()).into_boxed_slice();
                                                        let ptr18 = vec18.as_ptr() as i32;
                                                        let len18 = vec18.len() as i32;
                                                        ::core::mem::forget(vec18);
                                                        *((base + 4) as *mut i32) = len18;
                                                        *((base + 0) as *mut i32) = ptr18;
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V23;
                                                        match t17_1 {
                                                            V23::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V23::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V23::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V23::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V23::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V23::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec19 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr19 = vec19.as_ptr() as i32;
                                                                let len19 = vec19.len() as i32;
                                                                ::core::mem::forget(vec19);
                                                                *((base + 20) as *mut i32) = len19;
                                                                *((base + 16) as *mut i32) = ptr19;
                                                            }
                                                            V23::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec20 = (e).into_boxed_slice();
                                                                let ptr20 = vec20.as_ptr() as i32;
                                                                let len20 = vec20.len() as i32;
                                                                ::core::mem::forget(vec20);
                                                                *((base + 20) as *mut i32) = len20;
                                                                *((base + 16) as *mut i32) = ptr20;
                                                            }
                                                            V23::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index21,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index21);
                                                            }
                                                            V23::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index22,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index22);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len24;
                                                *((base + 0) as *mut i32) = result24 as i32;
                                            }
                                        }
                                        *((ptr3 + 44) as *mut i32) = len25;
                                        *((ptr3 + 40) as *mut i32) = result25 as i32;
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((ptr3 + 8) as *mut u8) = (1i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_26,
                                        } = e;
                                        *((ptr3 + 16)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_26);
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                        e,
                                    ) => {
                                        *((ptr3 + 8) as *mut u8) = (2i32) as u8;
                                        match e {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                e,
                                            ) => {
                                                *((ptr3 + 16) as *mut u8) = (0i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_27,
                                                } = e;
                                                *((ptr3 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                e,
                                            ) => {
                                                *((ptr3 + 16) as *mut u8) = (1i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_28,
                                                } = e;
                                                *((ptr3 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                e,
                                            ) => {
                                                *((ptr3 + 16) as *mut u8) = (2i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_29,
                                                } = e;
                                                *((ptr3 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                e,
                                            ) => {
                                                *((ptr3 + 16) as *mut u8) = (3i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_30,
                                                } = e;
                                                *((ptr3 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_30);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                e,
                                            ) => {
                                                *((ptr3 + 16) as *mut u8) = (4i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_31,
                                                } = e;
                                                *((ptr3 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_31);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                e,
                                            ) => {
                                                *((ptr3 + 16) as *mut u8) = (5i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_32,
                                                } = e;
                                                *((ptr3 + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_32);
                                            }
                                        };
                                    }
                                };
                            }
                            None => {
                                *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                            }
                        };
                        ptr3
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-map-get"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_map_get(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = i32::from(*((arg0 + 8) as *const u8));
                                    match l1 {
                                        0 => {
                                            let l2 = i32::from(*((arg0 + 16) as *const u8));
                                            match l2 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l3 = *((arg0 + 24) as *const i32);
                                                    let l4 = *((arg0 + 28) as *const i32);
                                                    wit_bindgen::rt::dealloc(l3, (l4) as usize, 1);
                                                }
                                                6 => {
                                                    let l5 = *((arg0 + 24) as *const i32);
                                                    let l6 = *((arg0 + 28) as *const i32);
                                                    let base7 = l5;
                                                    let len7 = l6;
                                                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                            let l17 = *((arg0 + 32) as *const i32);
                                            let l18 = *((arg0 + 36) as *const i32);
                                            let base19 = l17;
                                            let len19 = l18;
                                            for i in 0..len19 {
                                                let base = base19 + i * 8;
                                                {
                                                    let l14 = *((base + 0) as *const i32);
                                                    let l15 = *((base + 4) as *const i32);
                                                    let base16 = l14;
                                                    let len16 = l15;
                                                    for i in 0..len16 {
                                                        let base = base16 + i * 16;
                                                        {
                                                            let l8 = i32::from(*((base + 0) as *const u8));
                                                            match l8 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l9 = *((base + 8) as *const i32);
                                                                    let l10 = *((base + 12) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l9, (l10) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l11 = *((base + 8) as *const i32);
                                                                    let l12 = *((base + 12) as *const i32);
                                                                    let base13 = l11;
                                                                    let len13 = l12;
                                                                    wit_bindgen::rt::dealloc(base13, (len13 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base16, (len16 as usize) * 16, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base19, (len19 as usize) * 8, 4);
                                            let l31 = *((arg0 + 40) as *const i32);
                                            let l32 = *((arg0 + 44) as *const i32);
                                            let base33 = l31;
                                            let len33 = l32;
                                            for i in 0..len33 {
                                                let base = base33 + i * 8;
                                                {
                                                    let l28 = *((base + 0) as *const i32);
                                                    let l29 = *((base + 4) as *const i32);
                                                    let base30 = l28;
                                                    let len30 = l29;
                                                    for i in 0..len30 {
                                                        let base = base30 + i * 24;
                                                        {
                                                            let l20 = *((base + 0) as *const i32);
                                                            let l21 = *((base + 4) as *const i32);
                                                            wit_bindgen::rt::dealloc(l20, (l21) as usize, 1);
                                                            let l22 = i32::from(*((base + 8) as *const u8));
                                                            match l22 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l23 = *((base + 16) as *const i32);
                                                                    let l24 = *((base + 20) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l23, (l24) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l25 = *((base + 16) as *const i32);
                                                                    let l26 = *((base + 20) as *const i32);
                                                                    let base27 = l25;
                                                                    let len27 = l26;
                                                                    wit_bindgen::rt::dealloc(base27, (len27 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base30, (len30 as usize) * 24, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base33, (len33 as usize) * 8, 4);
                                        }
                                        1 => {}
                                        _ => {}
                                    }
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-entries"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_entries(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_map_entries(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                        let vec34 = result1;
                        let len34 = vec34.len() as i32;
                        let layout34 = alloc::Layout::from_size_align_unchecked(
                            vec34.len() * 48,
                            8,
                        );
                        let result34 = if layout34.size() != 0 {
                            let ptr = alloc::alloc(layout34);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout34);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec34.into_iter().enumerate() {
                            let base = result34 as i32 + (i as i32) * 48;
                            {
                                let (t3_0, t3_1) = e;
                                let vec4 = (t3_0.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                ::core::mem::forget(vec4);
                                *((base + 4) as *mut i32) = len4;
                                *((base + 0) as *mut i32) = ptr4;
                                match t3_1 {
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::JsonValueItem(
                                        e,
                                    ) => {
                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValueItem {
                                            item: item5,
                                            array_references: array_references5,
                                            map_references: map_references5,
                                        } = e;
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V10;
                                        match item5 {
                                            V10::Null => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                            }
                                            V10::Undefined => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                            }
                                            V10::Boolean(e) => {
                                                *((base + 16) as *mut u8) = (2i32) as u8;
                                                *((base + 24)
                                                    as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                }) as u8;
                                            }
                                            V10::Number(e) => {
                                                *((base + 16) as *mut u8) = (3i32) as u8;
                                                *((base + 24) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            }
                                            V10::BigInt(e) => {
                                                *((base + 16) as *mut u8) = (4i32) as u8;
                                                *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            }
                                            V10::Str(e) => {
                                                *((base + 16) as *mut u8) = (5i32) as u8;
                                                let vec6 = (e.into_bytes()).into_boxed_slice();
                                                let ptr6 = vec6.as_ptr() as i32;
                                                let len6 = vec6.len() as i32;
                                                ::core::mem::forget(vec6);
                                                *((base + 28) as *mut i32) = len6;
                                                *((base + 24) as *mut i32) = ptr6;
                                            }
                                            V10::Buffer(e) => {
                                                *((base + 16) as *mut u8) = (6i32) as u8;
                                                let vec7 = (e).into_boxed_slice();
                                                let ptr7 = vec7.as_ptr() as i32;
                                                let len7 = vec7.len() as i32;
                                                ::core::mem::forget(vec7);
                                                *((base + 28) as *mut i32) = len7;
                                                *((base + 24) as *mut i32) = ptr7;
                                            }
                                            V10::Array(e) => {
                                                *((base + 16) as *mut u8) = (7i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                    index: index8,
                                                } = e;
                                                *((base + 24)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index8);
                                            }
                                            V10::Map(e) => {
                                                *((base + 16) as *mut u8) = (8i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                    index: index9,
                                                } = e;
                                                *((base + 24)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(index9);
                                            }
                                        }
                                        let vec17 = array_references5;
                                        let len17 = vec17.len() as i32;
                                        let layout17 = alloc::Layout::from_size_align_unchecked(
                                            vec17.len() * 8,
                                            4,
                                        );
                                        let result17 = if layout17.size() != 0 {
                                            let ptr = alloc::alloc(layout17);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout17);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec17.into_iter().enumerate() {
                                            let base = result17 as i32 + (i as i32) * 8;
                                            {
                                                let vec16 = e;
                                                let len16 = vec16.len() as i32;
                                                let layout16 = alloc::Layout::from_size_align_unchecked(
                                                    vec16.len() * 16,
                                                    8,
                                                );
                                                let result16 = if layout16.size() != 0 {
                                                    let ptr = alloc::alloc(layout16);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout16);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec16.into_iter().enumerate() {
                                                    let base = result16 as i32 + (i as i32) * 16;
                                                    {
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V15;
                                                        match e {
                                                            V15::Null => {
                                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V15::Undefined => {
                                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V15::Boolean(e) => {
                                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                                *((base + 8)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V15::Number(e) => {
                                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                                *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V15::BigInt(e) => {
                                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                                *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V15::Str(e) => {
                                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                                let vec11 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr11 = vec11.as_ptr() as i32;
                                                                let len11 = vec11.len() as i32;
                                                                ::core::mem::forget(vec11);
                                                                *((base + 12) as *mut i32) = len11;
                                                                *((base + 8) as *mut i32) = ptr11;
                                                            }
                                                            V15::Buffer(e) => {
                                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                                let vec12 = (e).into_boxed_slice();
                                                                let ptr12 = vec12.as_ptr() as i32;
                                                                let len12 = vec12.len() as i32;
                                                                ::core::mem::forget(vec12);
                                                                *((base + 12) as *mut i32) = len12;
                                                                *((base + 8) as *mut i32) = ptr12;
                                                            }
                                                            V15::Array(e) => {
                                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index13,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index13);
                                                            }
                                                            V15::Map(e) => {
                                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index14,
                                                                } = e;
                                                                *((base + 8)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index14);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len16;
                                                *((base + 0) as *mut i32) = result16 as i32;
                                            }
                                        }
                                        *((base + 36) as *mut i32) = len17;
                                        *((base + 32) as *mut i32) = result17 as i32;
                                        let vec26 = map_references5;
                                        let len26 = vec26.len() as i32;
                                        let layout26 = alloc::Layout::from_size_align_unchecked(
                                            vec26.len() * 8,
                                            4,
                                        );
                                        let result26 = if layout26.size() != 0 {
                                            let ptr = alloc::alloc(layout26);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout26);
                                            }
                                            ptr
                                        } else {
                                            ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec26.into_iter().enumerate() {
                                            let base = result26 as i32 + (i as i32) * 8;
                                            {
                                                let vec25 = e;
                                                let len25 = vec25.len() as i32;
                                                let layout25 = alloc::Layout::from_size_align_unchecked(
                                                    vec25.len() * 24,
                                                    8,
                                                );
                                                let result25 = if layout25.size() != 0 {
                                                    let ptr = alloc::alloc(layout25);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout25);
                                                    }
                                                    ptr
                                                } else {
                                                    ::core::ptr::null_mut()
                                                };
                                                for (i, e) in vec25.into_iter().enumerate() {
                                                    let base = result25 as i32 + (i as i32) * 24;
                                                    {
                                                        let (t18_0, t18_1) = e;
                                                        let vec19 = (t18_0.into_bytes()).into_boxed_slice();
                                                        let ptr19 = vec19.as_ptr() as i32;
                                                        let len19 = vec19.len() as i32;
                                                        ::core::mem::forget(vec19);
                                                        *((base + 4) as *mut i32) = len19;
                                                        *((base + 0) as *mut i32) = ptr19;
                                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonValue as V24;
                                                        match t18_1 {
                                                            V24::Null => {
                                                                *((base + 8) as *mut u8) = (0i32) as u8;
                                                            }
                                                            V24::Undefined => {
                                                                *((base + 8) as *mut u8) = (1i32) as u8;
                                                            }
                                                            V24::Boolean(e) => {
                                                                *((base + 8) as *mut u8) = (2i32) as u8;
                                                                *((base + 16)
                                                                    as *mut u8) = (match e {
                                                                    true => 1,
                                                                    false => 0,
                                                                }) as u8;
                                                            }
                                                            V24::Number(e) => {
                                                                *((base + 8) as *mut u8) = (3i32) as u8;
                                                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                            }
                                                            V24::BigInt(e) => {
                                                                *((base + 8) as *mut u8) = (4i32) as u8;
                                                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                            }
                                                            V24::Str(e) => {
                                                                *((base + 8) as *mut u8) = (5i32) as u8;
                                                                let vec20 = (e.into_bytes()).into_boxed_slice();
                                                                let ptr20 = vec20.as_ptr() as i32;
                                                                let len20 = vec20.len() as i32;
                                                                ::core::mem::forget(vec20);
                                                                *((base + 20) as *mut i32) = len20;
                                                                *((base + 16) as *mut i32) = ptr20;
                                                            }
                                                            V24::Buffer(e) => {
                                                                *((base + 8) as *mut u8) = (6i32) as u8;
                                                                let vec21 = (e).into_boxed_slice();
                                                                let ptr21 = vec21.as_ptr() as i32;
                                                                let len21 = vec21.len() as i32;
                                                                ::core::mem::forget(vec21);
                                                                *((base + 20) as *mut i32) = len21;
                                                                *((base + 16) as *mut i32) = ptr21;
                                                            }
                                                            V24::Array(e) => {
                                                                *((base + 8) as *mut u8) = (7i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonArrayRef {
                                                                    index: index22,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index22);
                                                            }
                                                            V24::Map(e) => {
                                                                *((base + 8) as *mut u8) = (8i32) as u8;
                                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::JsonMapRef {
                                                                    index: index23,
                                                                } = e;
                                                                *((base + 16)
                                                                    as *mut i32) = wit_bindgen::rt::as_i32(index23);
                                                            }
                                                        }
                                                    }
                                                }
                                                *((base + 4) as *mut i32) = len25;
                                                *((base + 0) as *mut i32) = result25 as i32;
                                            }
                                        }
                                        *((base + 44) as *mut i32) = len26;
                                        *((base + 40) as *mut i32) = result26 as i32;
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YDoc(
                                        e,
                                    ) => {
                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                            ref_: ref_27,
                                        } = e;
                                        *((base + 16)
                                            as *mut i32) = wit_bindgen::rt::as_i32(ref_27);
                                    }
                                    super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YValue::YType(
                                        e,
                                    ) => {
                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                        match e {
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YText(
                                                e,
                                            ) => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                    ref_: ref_28,
                                                } = e;
                                                *((base + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_28);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YArray(
                                                e,
                                            ) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                    ref_: ref_29,
                                                } = e;
                                                *((base + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_29);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YMap(
                                                e,
                                            ) => {
                                                *((base + 16) as *mut u8) = (2i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                    ref_: ref_30,
                                                } = e;
                                                *((base + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_30);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlFragment(
                                                e,
                                            ) => {
                                                *((base + 16) as *mut u8) = (3i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                    ref_: ref_31,
                                                } = e;
                                                *((base + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_31);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlElement(
                                                e,
                                            ) => {
                                                *((base + 16) as *mut u8) = (4i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                    ref_: ref_32,
                                                } = e;
                                                *((base + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_32);
                                            }
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType::YXmlText(
                                                e,
                                            ) => {
                                                *((base + 16) as *mut u8) = (5i32) as u8;
                                                let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                    ref_: ref_33,
                                                } = e;
                                                *((base + 20)
                                                    as *mut i32) = wit_bindgen::rt::as_i32(ref_33);
                                            }
                                        };
                                    }
                                };
                            }
                        }
                        *((ptr2 + 4) as *mut i32) = len34;
                        *((ptr2 + 0) as *mut i32) = result34 as i32;
                        ptr2
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-map-entries"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_map_entries(arg0: i32) {
                            let l35 = *((arg0 + 0) as *const i32);
                            let l36 = *((arg0 + 4) as *const i32);
                            let base37 = l35;
                            let len37 = l36;
                            for i in 0..len37 {
                                let base = base37 + i * 48;
                                {
                                    let l0 = *((base + 0) as *const i32);
                                    let l1 = *((base + 4) as *const i32);
                                    wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
                                    let l2 = i32::from(*((base + 8) as *const u8));
                                    match l2 {
                                        0 => {
                                            let l3 = i32::from(*((base + 16) as *const u8));
                                            match l3 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                3 => {}
                                                4 => {}
                                                5 => {
                                                    let l4 = *((base + 24) as *const i32);
                                                    let l5 = *((base + 28) as *const i32);
                                                    wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                                                }
                                                6 => {
                                                    let l6 = *((base + 24) as *const i32);
                                                    let l7 = *((base + 28) as *const i32);
                                                    let base8 = l6;
                                                    let len8 = l7;
                                                    wit_bindgen::rt::dealloc(base8, (len8 as usize) * 1, 1);
                                                }
                                                7 => {}
                                                _ => {}
                                            }
                                            let l18 = *((base + 32) as *const i32);
                                            let l19 = *((base + 36) as *const i32);
                                            let base20 = l18;
                                            let len20 = l19;
                                            for i in 0..len20 {
                                                let base = base20 + i * 8;
                                                {
                                                    let l15 = *((base + 0) as *const i32);
                                                    let l16 = *((base + 4) as *const i32);
                                                    let base17 = l15;
                                                    let len17 = l16;
                                                    for i in 0..len17 {
                                                        let base = base17 + i * 16;
                                                        {
                                                            let l9 = i32::from(*((base + 0) as *const u8));
                                                            match l9 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l10 = *((base + 8) as *const i32);
                                                                    let l11 = *((base + 12) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l10, (l11) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l12 = *((base + 8) as *const i32);
                                                                    let l13 = *((base + 12) as *const i32);
                                                                    let base14 = l12;
                                                                    let len14 = l13;
                                                                    wit_bindgen::rt::dealloc(base14, (len14 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base17, (len17 as usize) * 16, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base20, (len20 as usize) * 8, 4);
                                            let l32 = *((base + 40) as *const i32);
                                            let l33 = *((base + 44) as *const i32);
                                            let base34 = l32;
                                            let len34 = l33;
                                            for i in 0..len34 {
                                                let base = base34 + i * 8;
                                                {
                                                    let l29 = *((base + 0) as *const i32);
                                                    let l30 = *((base + 4) as *const i32);
                                                    let base31 = l29;
                                                    let len31 = l30;
                                                    for i in 0..len31 {
                                                        let base = base31 + i * 24;
                                                        {
                                                            let l21 = *((base + 0) as *const i32);
                                                            let l22 = *((base + 4) as *const i32);
                                                            wit_bindgen::rt::dealloc(l21, (l22) as usize, 1);
                                                            let l23 = i32::from(*((base + 8) as *const u8));
                                                            match l23 {
                                                                0 => {}
                                                                1 => {}
                                                                2 => {}
                                                                3 => {}
                                                                4 => {}
                                                                5 => {
                                                                    let l24 = *((base + 16) as *const i32);
                                                                    let l25 = *((base + 20) as *const i32);
                                                                    wit_bindgen::rt::dealloc(l24, (l25) as usize, 1);
                                                                }
                                                                6 => {
                                                                    let l26 = *((base + 16) as *const i32);
                                                                    let l27 = *((base + 20) as *const i32);
                                                                    let base28 = l26;
                                                                    let len28 = l27;
                                                                    wit_bindgen::rt::dealloc(base28, (len28 as usize) * 1, 1);
                                                                }
                                                                7 => {}
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                    wit_bindgen::rt::dealloc(base31, (len31 as usize) * 24, 8);
                                                }
                                            }
                                            wit_bindgen::rt::dealloc(base34, (len34 as usize) * 8, 4);
                                        }
                                        1 => {}
                                        _ => {}
                                    }
                                }
                            }
                            wit_bindgen::rt::dealloc(base37, (len37 as usize) * 48, 8);
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-observe"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_observe(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_map_observe(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-map-observe-deep"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_map_observe_deep(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_map_observe_deep(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-name"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_element_name(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_xml_element_name(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Some(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec2 = (e.into_bytes()).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                            None => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-name"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_xml_element_name(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-length"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_element_length(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_xml_element_length(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::as_i32(result1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-insert-xml-element"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_element_insert_xml_element(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                        arg6: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg3 as usize;
                        let bytes0 = Vec::from_raw_parts(arg2 as *mut _, len0, len0);
                        let result2 = <YDocMethodsImpl as YDocMethods>::y_xml_element_insert_xml_element(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            wit_bindgen::rt::string_lift(bytes0),
                            match arg4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V1;
                                        let v1 = match arg5 {
                                            0 => {
                                                let e1 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg6 as u32,
                                                };
                                                V1::ReadTransaction(e1)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e1 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg6 as u32,
                                                };
                                                V1::WriteTransaction(e1)
                                            }
                                        };
                                        v1
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                            ref_: ref_3,
                        } = result2;
                        wit_bindgen::rt::as_i32(ref_3)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-insert-xml-text"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_element_insert_xml_text(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_xml_element_insert_xml_text(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            match arg2 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg3 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg4 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg4 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                            ref_: ref_2,
                        } = result1;
                        wit_bindgen::rt::as_i32(ref_2)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-element-delete"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_element_delete(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i32,
                        arg5: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::y_xml_element_delete(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                            arg2 as u32,
                            match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg4 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg5 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-name"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_fragment_name(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::y_xml_fragment_name(super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Some(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec2 = (e.into_bytes()).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                            None => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-name"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_y_xml_fragment_name(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-fragment-length"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_fragment_length(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_xml_fragment_length(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::as_i32(result1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#y-xml-text-length"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_y_xml_text_length(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result1 = <YDocMethodsImpl as YDocMethods>::y_xml_text_length(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                ref_: arg0 as u32,
                            },
                            match arg1 {
                                0 => None,
                                1 => {
                                    let e = {
                                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YTransaction as V0;
                                        let v0 = match arg2 {
                                            0 => {
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::ReadTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::ReadTransaction(e0)
                                            }
                                            n => {
                                                if true {
                                                    match (&n, &1) {
                                                        (left_val, right_val) => {
                                                            if !(*left_val == *right_val) {
                                                                let kind = ::core::panicking::AssertKind::Eq;
                                                                ::core::panicking::assert_failed(
                                                                    kind,
                                                                    &*left_val,
                                                                    &*right_val,
                                                                    ::core::option::Option::Some(
                                                                        format_args!("invalid enum discriminant"),
                                                                    ),
                                                                );
                                                            }
                                                        }
                                                    };
                                                }
                                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::WriteTransaction {
                                                    ref_: arg3 as u32,
                                                };
                                                V0::WriteTransaction(e0)
                                            }
                                        };
                                        v0
                                    };
                                    Some(e)
                                }
                                _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                        );
                        wit_bindgen::rt::as_i32(result1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-new"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_new(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                        arg3: i32,
                        arg4: i64,
                        arg5: i32,
                        arg6: i32,
                        arg7: i32,
                        arg8: i32,
                        arg9: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType as V0;
                        let v0 = match arg1 {
                            0 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                    ref_: arg2 as u32,
                                };
                                V0::YText(e0)
                            }
                            1 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                    ref_: arg2 as u32,
                                };
                                V0::YArray(e0)
                            }
                            2 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                    ref_: arg2 as u32,
                                };
                                V0::YMap(e0)
                            }
                            3 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                    ref_: arg2 as u32,
                                };
                                V0::YXmlFragment(e0)
                            }
                            4 => {
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                    ref_: arg2 as u32,
                                };
                                V0::YXmlElement(e0)
                            }
                            n => {
                                if true {
                                    match (&n, &5) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("invalid enum discriminant"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                                let e0 = super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                    ref_: arg2 as u32,
                                };
                                V0::YXmlText(e0)
                            }
                        };
                        let result5 = <YDocMethodsImpl as YDocMethods>::undo_manager_new(
                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YDoc {
                                ref_: arg0 as u32,
                            },
                            v0,
                            UndoManagerOptions {
                                capture_timeout_millis: match arg3 {
                                    0 => None,
                                    1 => {
                                        let e = arg4 as u64;
                                        Some(e)
                                    }
                                    _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                },
                                tracked_origins: match arg5 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let base4 = arg6;
                                            let len4 = arg7;
                                            let mut result4 = Vec::with_capacity(len4 as usize);
                                            for i in 0..len4 {
                                                let base = base4 + i * 8;
                                                let e4 = {
                                                    let l1 = *((base + 0) as *const i32);
                                                    let l2 = *((base + 4) as *const i32);
                                                    let len3 = l2 as usize;
                                                    Vec::from_raw_parts(l1 as *mut _, len3, len3)
                                                };
                                                result4.push(e4);
                                            }
                                            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
                                            result4
                                        };
                                        Some(e)
                                    }
                                    _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                },
                                capture_transaction: match arg8 {
                                    0 => None,
                                    1 => {
                                        let e = wit_bindgen::rt::bool_lift(arg9 as u8);
                                        Some(e)
                                    }
                                    _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                },
                            },
                        );
                        let UndoManagerRef { ref_: ref_6 } = result5;
                        wit_bindgen::rt::as_i32(ref_6)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-add-to-scope"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_add_to_scope(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let base8 = arg1;
                        let len8 = arg2;
                        let mut result8 = Vec::with_capacity(len8 as usize);
                        for i in 0..len8 {
                            let base = base8 + i * 8;
                            let e8 = {
                                let l0 = i32::from(*((base + 0) as *const u8));
                                use super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YType as V7;
                                let v7 = match l0 {
                                    0 => {
                                        let e7 = {
                                            let l1 = *((base + 4) as *const i32);
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YText {
                                                ref_: l1 as u32,
                                            }
                                        };
                                        V7::YText(e7)
                                    }
                                    1 => {
                                        let e7 = {
                                            let l2 = *((base + 4) as *const i32);
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YArray {
                                                ref_: l2 as u32,
                                            }
                                        };
                                        V7::YArray(e7)
                                    }
                                    2 => {
                                        let e7 = {
                                            let l3 = *((base + 4) as *const i32);
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YMap {
                                                ref_: l3 as u32,
                                            }
                                        };
                                        V7::YMap(e7)
                                    }
                                    3 => {
                                        let e7 = {
                                            let l4 = *((base + 4) as *const i32);
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlFragment {
                                                ref_: l4 as u32,
                                            }
                                        };
                                        V7::YXmlFragment(e7)
                                    }
                                    4 => {
                                        let e7 = {
                                            let l5 = *((base + 4) as *const i32);
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlElement {
                                                ref_: l5 as u32,
                                            }
                                        };
                                        V7::YXmlElement(e7)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &5) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e7 = {
                                            let l6 = *((base + 4) as *const i32);
                                            super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::YXmlText {
                                                ref_: l6 as u32,
                                            }
                                        };
                                        V7::YXmlText(e7)
                                    }
                                };
                                v7
                            };
                            result8.push(e8);
                        }
                        wit_bindgen::rt::dealloc(base8, (len8 as usize) * 8, 4);
                        <YDocMethodsImpl as YDocMethods>::undo_manager_add_to_scope(
                            UndoManagerRef {
                                ref_: arg0 as u32,
                            },
                            result8,
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-add-tracked-origin"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_add_tracked_origin(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        <YDocMethodsImpl as YDocMethods>::undo_manager_add_tracked_origin(
                            UndoManagerRef {
                                ref_: arg0 as u32,
                            },
                            Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-remove-tracked-origin"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_remove_tracked_origin(
                        arg0: i32,
                        arg1: i32,
                        arg2: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let len0 = arg2 as usize;
                        <YDocMethodsImpl as YDocMethods>::undo_manager_remove_tracked_origin(
                            UndoManagerRef {
                                ref_: arg0 as u32,
                            },
                            Vec::from_raw_parts(arg1 as *mut _, len0, len0),
                        );
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-clear"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_clear(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_clear(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Ok(_) => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                            }
                            Err(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec2 = (e.into_bytes()).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-clear"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_undo_manager_clear(
                            arg0: i32,
                        ) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-stop-capturing"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_stop_capturing(
                        arg0: i32,
                    ) {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        <YDocMethodsImpl as YDocMethods>::undo_manager_stop_capturing(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-undo"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_undo(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_undo(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Ok(e) => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                                *((ptr1 + 4)
                                    as *mut u8) = (match e {
                                    true => 1,
                                    false => 0,
                                }) as u8;
                            }
                            Err(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec2 = (e.into_bytes()).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-undo"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_undo_manager_undo(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-redo"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_redo(arg0: i32) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_redo(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                        let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                        match result0 {
                            Ok(e) => {
                                *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                                *((ptr1 + 4)
                                    as *mut u8) = (match e {
                                    true => 1,
                                    false => 0,
                                }) as u8;
                            }
                            Err(e) => {
                                *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                                let vec2 = (e.into_bytes()).into_boxed_slice();
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                ::core::mem::forget(vec2);
                                *((ptr1 + 8) as *mut i32) = len2;
                                *((ptr1 + 4) as *mut i32) = ptr2;
                            }
                        };
                        ptr1
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[export_name = "cabi_post_y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-redo"]
                        #[allow(non_snake_case)]
                        unsafe extern "C" fn __post_return_undo_manager_redo(arg0: i32) {
                            let l0 = i32::from(*((arg0 + 0) as *const u8));
                            match l0 {
                                0 => {}
                                _ => {
                                    let l1 = *((arg0 + 4) as *const i32);
                                    let l2 = *((arg0 + 8) as *const i32);
                                    wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                                }
                            }
                        }
                    };
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-can-undo"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_can_undo(
                        arg0: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_can_undo(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-can-redo"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_can_redo(
                        arg0: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_can_redo(UndoManagerRef {
                            ref_: arg0 as u32,
                        });
                        match result0 {
                            true => 1,
                            false => 0,
                        }
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-on-item-added"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_on_item_added(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_on_item_added(
                            UndoManagerRef {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                    #[doc(hidden)]
                    #[export_name = "y-crdt-namespace:y-crdt/y-doc-methods#undo-manager-on-item-popped"]
                    #[allow(non_snake_case)]
                    unsafe extern "C" fn __export_undo_manager_on_item_popped(
                        arg0: i32,
                        arg1: i32,
                    ) -> i32 {
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        let result0 = <YDocMethodsImpl as YDocMethods>::undo_manager_on_item_popped(
                            UndoManagerRef {
                                ref_: arg0 as u32,
                            },
                            arg1 as u32,
                        );
                        let super::super::super::super::y_crdt_namespace::y_crdt::y_doc_methods_types::EventObserver {
                            ref_: ref_1,
                        } = result0;
                        wit_bindgen::rt::as_i32(ref_1)
                    }
                };
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                #[repr(align(8))]
                struct _RetArea([u8; 48]);
                static mut _RET_AREA: _RetArea = _RetArea([0; 48]);
            }
        }
    }
}
const _: &str = "package y-crdt-namespace:y-crdt\n\nworld y-crdt {\n    use y-doc-methods-types.{y-event, y-undo-event}\n\n    import event-callback: func(function-id: u32, event: y-event)\n    import event-deep-callback: func(function-id: u32, event: list<y-event>)\n    import undo-event-callback: func(function-id: u32, event: y-undo-event)\n\n    // TODO: should_load auto_load\n\n    export y-doc-methods\n}\n\ninterface y-doc-methods-types {\n\n    union y-event {\n      y-array-event,\n      y-map-event,\n      y-text-event,\n    }\n\n    record event-observer {\n      ref: u32,\n    }\n\n    union y-value {\n      json-value-item,\n      y-doc,\n      y-type,\n    }\n\n    union y-type {\n      y-text,\n      y-array,\n      y-map,\n      y-xml-fragment,\n      y-xml-element,\n      y-xml-text,\n    }\n\n    record y-doc {\n      ref: u32,\n    }\n    union y-transaction {\n      read-transaction,\n      write-transaction,\n    }\n    record read-transaction {\n      ref: u32,\n    }\n    record write-transaction {\n      ref: u32,\n    }\n\n    record y-text {\n      ref: u32,\n    }\n    record y-array {\n      ref: u32,\n    }\n    record y-map {\n      ref: u32,\n    }\n    record y-xml-fragment {\n      ref: u32,\n    }\n    record y-xml-element {\n      ref: u32,\n    }\n    record y-xml-text {\n      ref: u32,\n    }\n\n    type event-path = list<event-path-item>\n    union event-path-item {\n      string,\n      u32,\n    }\n\n    record y-array-event {\n      target: y-array,\n      delta: list<y-array-delta>,\n      path: event-path,\n    }\n\n    union y-array-delta {\n      y-array-delta-insert,\n      y-array-delta-delete,\n      y-array-delta-retain,\n    }\n\n    record y-array-delta-insert {\n      insert: list<y-value>,\n    }\n    record y-array-delta-delete {\n      delete: u32,\n    }\n    record y-array-delta-retain {\n      retain: u32,\n    }\n\n    record y-map-event {\n      // txn: write-transaction,\n      // target: y-value,\n      target: y-map,\n      keys: list<tuple<string, y-map-delta>>,\n      path: event-path,\n    }\n\n    record y-map-delta {\n      action: y-map-delta-action,\n      old-value: option<y-value>,\n      new-value: option<y-value>,\n    }\n\n    enum y-map-delta-action {\n      insert,\n      update,\n      delete,\n    }\n\n    record y-text-event {\n      // txn: write-transaction,\n      // target: y-value,\n      target: y-text,\n      delta: list<y-text-delta>,\n      path: event-path,\n    }\n    \n    /// https://quilljs.com/docs/delta/\n    union y-text-delta {\n      y-text-delta-insert,\n      y-text-delta-delete,\n      y-text-delta-retain,\n    }\n    record y-text-delta-insert {\n      // TODO: could be an Embeds object\n      insert: string,\n      attributes: option<text-attrs>,\n    }\n    record y-text-delta-delete {\n      delete: u32,\n    }\n    record y-text-delta-retain {\n      retain: u32,\n      attributes: option<text-attrs>,\n    }\n\n    // TODO: should we add fields/methods from Snapshot?\n    record y-snapshot {\n      ref: u32,\n    }\n\n    type json-object = json-value-item\n    type json-array = json-value-item\n    type text-attrs = json-object\n\n    record json-value-item {\n      item: json-value,\n      array-references: list<list<json-value>>,\n      map-references: list<list<tuple<string, json-value>>>,\n    }\n\n    // record json-value-item {\n    //   item: json-value,\n    //   references: list<json-value>,\n    // }\n\n    record json-value-ref {\n      index: u32,\n    }\n\n    record json-array-ref {\n      index: u32,\n    }\n\n    record json-map-ref {\n      index: u32,\n    }\n\n    variant json-value {\n      null,\n      undefined,\n      boolean(bool),\n      number(float64),\n      big-int(s64),\n      str(string),\n      buffer(list<u8>),\n      array(json-array-ref),\n      map(json-map-ref),\n    }\n\n    record y-undo-event {\n      origin: option<list<u8>>,\n      kind: y-undo-kind,\n      stack-item: stack-item-sets,\n    }\n\n    enum y-undo-kind {\n      undo,\n      redo,\n    }\n\n    record stack-item-sets {\n      insertions: list<tuple<u64, list<start-length>>>,\n      deletions: list<tuple<u64, list<start-length>>>,\n    }\n\n    record start-length {\n      start: u32,\n      length: u32,\n    }\n}\n\ninterface y-doc-methods {\n    use y-doc-methods-types.{\n      y-event,\n      event-observer,\n      y-value,\n      y-doc,\n      y-transaction,\n      read-transaction,\n      write-transaction,\n      y-text,\n      y-array,\n      y-map,\n      y-xml-fragment,\n      y-xml-element,\n      y-xml-text,\n      event-path,\n      event-path-item,\n      y-array-event,\n      y-array-delta,\n      y-array-delta-insert,\n      y-array-delta-delete,\n      y-array-delta-retain,\n      y-map-event,\n      y-map-delta,\n      y-map-delta-action,\n      y-text-event,\n      y-text-delta,\n      y-text-delta-insert,\n      y-text-delta-delete,\n      y-text-delta-retain,\n      y-snapshot,\n      json-object,\n      json-array,\n      json-value-item,\n      json-value-ref,\n      json-array-ref,\n      json-map-ref,\n      json-value,\n      text-attrs,\n      y-type,\n      y-undo-event,\n    }\n\n    type error = string\n    type origin = list<u8>\n    type implicit-transaction = option<y-transaction>\n\n    y-doc-dispose: func(ref: y-doc) -> bool\n    y-text-dispose: func(ref: y-text) -> bool\n    y-array-dispose: func(ref: y-array) -> bool\n    y-map-dispose: func(ref: y-map) -> bool\n    y-xml-element-dispose: func(ref: y-xml-element) -> bool\n    y-xml-fragment-dispose: func(ref: y-xml-fragment) -> bool\n    y-xml-text-dispose: func(ref: y-xml-text) -> bool\n    y-transaction-dispose: func(ref: y-transaction) -> bool\n    y-value-dispose: func(ref: y-value) -> bool\n    y-snapshot-dispose: func(ref: y-snapshot) -> bool\n    undo-manager-dispose: func(ref: undo-manager-ref) -> bool\n    callback-dispose: func(ref: event-observer) -> bool\n\n    enum offset-kind {\n        /// Compute editable strings length and offset using UTF-8 byte count.\n        bytes,\n        /// Compute editable strings length and offset using UTF-16 chars count.\n        utf16,\n        /// Compute editable strings length and offset using Unicode code points number.\n        utf32,\n    }\n\n    record y-doc-options {\n      /// Globally unique client identifier. This value must be unique across all active collaborating\n      /// peers, otherwise a update collisions will happen, causing document store state to be corrupted.\n      ///\n      /// Default value: randomly generated.\n      client-id: option<u64>,\n      /// A globally unique identifier for this document.\n      ///\n      /// Default value: randomly generated UUID v4.\n      guid: option<string>,\n      /// Associate this document with a collection. This only plays a role if your provider has\n      /// a concept of collection.\n      ///\n      /// Default value: `None`.\n      collection-id: option<string>,\n      /// How to we count offsets and lengths used in text operations.\n      ///\n      /// Default value: [OffsetKind::Bytes].\n      offset-kind: option<offset-kind>,\n      /// Determines if transactions commits should try to perform GC-ing of deleted items.\n      ///\n      /// Default value: `false`.\n      skip-gc: option<bool>,\n      /// If a subdocument, automatically load document. If this is a subdocument, remote peers will\n      /// load the document as well automatically.\n      ///\n      /// Default value: `false`.\n      auto-load: option<bool>,\n      /// Whether the document should be synced by the provider now.\n      /// This is toggled to true when you call ydoc.load().\n      ///\n      /// Default value: `true`.\n      should-load: option<bool>,\n    }\n\n    y-doc-new: func(options: option<y-doc-options>) -> y-doc\n    y-doc-parent-doc: func(ref: y-doc) -> option<y-doc>\n    y-doc-id: func(ref: y-doc) -> u64\n    y-doc-guid: func(ref: y-doc) -> string\n    y-doc-read-transaction: func(ref: y-doc) -> read-transaction\n    y-doc-write-transaction: func(ref: y-doc, origin: origin) -> write-transaction\n    y-doc-text: func(ref: y-doc, name: string) -> y-text\n    y-doc-array: func(ref: y-doc, name: string) -> y-array\n    y-doc-map: func(ref: y-doc, name: string) -> y-map\n    y-doc-xml-fragment: func(ref: y-doc, name: string) -> y-xml-fragment\n    y-doc-xml-element: func(ref: y-doc, name: string) -> y-xml-element\n    y-doc-xml-text: func(ref: y-doc, name: string) -> y-xml-text\n    y-doc-on-update-v1: func(ref: y-doc, function-id: u32) -> event-observer\n    // on_after_transaction\n    // on_subdocs\n    // on_destroy\n    y-doc-load: func(ref: y-doc, parent-txn: implicit-transaction)\n    y-doc-destroy: func(ref: y-doc, parent-txn: implicit-transaction)\n    y-doc-subdocs: func(ref: y-doc, txn: implicit-transaction) -> list<y-doc>\n    y-doc-subdoc-guids: func(ref: y-doc, txn: implicit-transaction) -> list<string>\n\n    encode-state-vector: func(ref: y-doc) -> list<u8>\n    // debug_update_v1\n\n\n    encode-state-as-update: func(ref: y-doc, vector: option<list<u8>>) -> result<list<u8>, error>\n    encode-state-as-update-v2: func(ref: y-doc, vector: option<list<u8>>) -> result<list<u8>, error>\n    apply-update: func(ref: y-doc, diff: list<u8>, origin: origin) -> result<_, error>\n    apply-update-v2: func(ref: y-doc, diff: list<u8>, origin: origin) -> result<_, error>\n\n    transaction-origin: func(txn: y-transaction) -> option<origin>\n    transaction-commit: func(txn: y-transaction)\n    transaction-state-vector-v1: func(txn: y-transaction) -> list<u8>\n    transaction-diff-v1: func(txn: y-transaction, vector: option<list<u8>>) -> result<list<u8>, error>\n    transaction-diff-v2: func(txn: y-transaction, vector: option<list<u8>>) -> result<list<u8>, error>\n    transaction-apply-v1: func(txn: y-transaction, diff: list<u8>) -> result<_, error>\n    transaction-apply-v2: func(txn: y-transaction, diff: list<u8>) -> result<_, error>\n\n    transaction-encode-update: func(txn: y-transaction) -> list<u8>\n    transaction-encode-update-v2: func(txn: y-transaction) -> list<u8>\n\n\n    // YMapEvent\n    // YTextEvent\n    // YXmlEvent\n    // YXmlTextEvent\n    // YSubdocsEvent\n    // YSubdocsObserver(SubdocsSubscription)\n    // YDestroyObserver(DestroySubscription)\n    // YAfterTransactionEvent\n    // YAfterTransactionObserver(TransactionCleanupSubscription)\n    // YUpdateObserver(UpdateSubscription)\n\n    // YArrayObserver\n    // YTextObserver\n    // YMapObserver\n    // ... other observers\n    // YEventObserver\n\n\n    y-text-new: func(init: option<string>) -> y-text\n    y-text-prelim: func(ref: y-text) -> bool\n    y-text-length: func(ref: y-text, txn: implicit-transaction) -> u32\n    y-text-to-string: func(ref: y-text, txn: implicit-transaction) -> string\n    y-text-to-json: func(ref: y-text, txn: implicit-transaction) -> string\n    y-text-insert: func(ref: y-text, index: u32, chunk: string, attributes: option<text-attrs>, txn: implicit-transaction)\n    y-text-insert-embed: func(ref: y-text, index: u32, embed: json-value-item, attributes: option<text-attrs>, txn: implicit-transaction)\n    y-text-format: func(ref: y-text, index: u32, length: u32, attributes: text-attrs, txn: implicit-transaction)\n    y-text-push: func(ref: y-text, chunk: string, attributes: option<text-attrs>, txn: implicit-transaction)\n    y-text-delete: func(ref: y-text, index: u32, length: u32, txn: implicit-transaction)\n    /// https://quilljs.com/docs/delta/\n    /// TODO: implement compute_ychange: Option<Function>,\n    y-text-to-delta: func(ref: y-text, snapshot: option<y-snapshot>, prev-snapshot: option<y-snapshot>, txn: implicit-transaction) -> list<y-text-delta>\n    y-text-observe: func(ref: y-text, function-id: u32) -> event-observer\n    y-text-observe-deep: func(ref: y-text, function-id: u32) -> event-observer\n\n    snapshot: func(doc: y-doc) -> y-snapshot\n    equal-snapshot: func(left: y-snapshot, right: y-snapshot) -> bool\n    encode-snapshot-v1: func(snapshot: y-snapshot) -> list<u8>\n    encode-snapshot-v2: func(snapshot: y-snapshot) -> list<u8>\n    decode-snapshot-v1: func(snapshot: list<u8>) -> result<y-snapshot, error>\n    decode-snapshot-v2: func(snapshot: list<u8>) -> result<y-snapshot, error>\n    encode-state-from-snapshot-v1: func(doc: y-doc, snapshot: y-snapshot) -> result<list<u8>, error>\n    encode-state-from-snapshot-v2: func(doc: y-doc, snapshot: y-snapshot) -> result<list<u8>, error>\n\n    y-array-new: func(init: option<json-array>) -> y-array\n    y-array-prelim: func(ref: y-array) -> bool\n    y-array-length: func(ref: y-array, txn: implicit-transaction) -> u32\n    y-array-to-json: func(ref: y-array, txn: implicit-transaction) -> json-value-item\n    y-array-insert: func(ref: y-array, index: u32, items: json-array, txn: implicit-transaction)\n    y-array-push: func(ref: y-array, items: json-array, txn: implicit-transaction)\n    y-array-delete: func(ref: y-array, index: u32, length: u32, txn: implicit-transaction)\n    y-array-move-content: func(ref: y-array, source: u32, target: u32, txn: implicit-transaction)\n    y-array-get: func(ref: y-array, index: u32, txn: implicit-transaction) -> result<y-value, error>\n    y-array-values: func(ref: y-array, txn: implicit-transaction) -> list<y-value>\n    y-array-observe: func(ref: y-array, function-id: u32) -> event-observer\n    y-array-observe-deep: func(ref: y-array, function-id: u32) -> event-observer\n\n\n    y-map-new: func(init: option<json-object>) -> y-map\n    y-map-prelim: func(ref: y-map) -> bool\n    y-map-length: func(ref: y-map, txn: implicit-transaction) -> u32\n    y-map-to-json: func(ref: y-map, txn: implicit-transaction) -> json-value-item // TODO: json-object\n    y-map-set: func(ref: y-map, key: string, value: json-value-item, txn: implicit-transaction)\n    y-map-delete: func(ref: y-map, key: string, txn: implicit-transaction)\n    y-map-get: func(ref: y-map, key: string, txn: implicit-transaction) -> option<y-value>\n    y-map-entries: func(ref: y-map, txn: implicit-transaction) -> list<tuple<string, y-value>>\n    y-map-observe: func(ref: y-map, function-id: u32) -> event-observer\n    y-map-observe-deep: func(ref: y-map, function-id: u32) -> event-observer\n\n\n    y-xml-element-name: func(ref: y-xml-element) -> option<string>\n    y-xml-element-length: func(ref: y-xml-element, txn: implicit-transaction) -> u32\n    y-xml-element-insert-xml-element: func(ref: y-xml-element, index: u32, name: string, txn: implicit-transaction) -> y-xml-element\n    y-xml-element-insert-xml-text: func(ref: y-xml-element, index: u32, txn: implicit-transaction) -> y-xml-text\n    y-xml-element-delete: func(ref: y-xml-element, index: u32, length: u32, txn: implicit-transaction)\n    // fn push_xml_element(&self, name: &str, txn: &ImplicitTransaction) -> YXmlElement\n    // fn push_xml_text(&self, txn: &ImplicitTransaction) -> YXmlText\n    // fn first_child(&self) -> JsValue\n    // fn next_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn prev_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn parent(&self) -> JsValue\n    // fn to_string(&self, txn: &ImplicitTransaction) -> String\n    // fn set_attribute(&self, name: &str, value: &str, txn: &ImplicitTransaction)\n    // fn get_attribute(&self, name: &str, txn: &ImplicitTransaction) -> Option<String>\n    // fn remove_attribute(&self, name: &str, txn: &ImplicitTransaction)\n    // fn attributes(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn tree_walker(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn observe(&mut self, f: js_sys::Function) -> YXmlObserver\n    // fn observe_deep(&mut self, f: js_sys::Function) -> YEventObserver\n\n\n    y-xml-fragment-name: func(ref: y-xml-fragment) -> option<string>\n    y-xml-fragment-length: func(ref: y-xml-fragment, txn: implicit-transaction) -> u32\n\n\n    y-xml-text-length: func(ref: y-xml-text, txn: implicit-transaction) -> u32\n    // fn insert(&self, index: i32, chunk: &str, attrs: JsValue, txn: &ImplicitTransaction)\n    // fn format(&self, index: i32, len: i32, attrs: JsValue, txn: &ImplicitTransaction)\n    // fn push(&self, chunk: &str, attrs: JsValue, txn: &ImplicitTransaction)\n    // fn delete(&self, index: u32, length: u32, txn: &ImplicitTransaction)\n    // fn next_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn prev_sibling(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn parent(&self) -> JsValue\n    // fn to_string(&self, txn: &ImplicitTransaction) -> String\n    // fn set_attribute(&self, name: &str, value: &str, txn: &ImplicitTransaction)\n    // fn get_attribute(&self, name: &str, txn: &ImplicitTransaction) -> Option<String>\n    // fn remove_attribute(&self, name: &str, txn: &ImplicitTransaction)\n    // fn attributes(&self, txn: &ImplicitTransaction) -> JsValue\n    // fn observe(&mut self, f: js_sys::Function) -> YXmlTextObserver\n    // fn observe_deep(&mut self, f: js_sys::Function) -> YEventObserver\n\n    // fn create_sticky_index_from_type(\n    //     ytype: &JsValue,\n    //     index: u32,\n    //     assoc: i32,\n    //     txn: &ImplicitTransaction,\n    // ) -> Result<JsValue, JsValue>\n    // \n    // fn create_offset_from_sticky_index(rpos: &JsValue, doc: &YDoc) -> Result<JsValue, JsValue>\n    // fn encode_sticky_index(rpos: &JsValue) -> Result<Uint8Array, JsValue>\n    // fn decode_sticky_index(bin: Uint8Array) -> Result<JsValue, JsValue>\n\n    record undo-manager-options {\n      /// Undo-/redo-able updates are grouped together in time-constrained snapshots. This field\n      /// determines the period of time, every snapshot will be automatically made in.\n      capture-timeout-millis: option<u64>,\n      /// List of origins tracked by corresponding [UndoManager].\n      /// If provided, it will track only updates made within transactions of specific origin.\n      /// If not provided, it will track only updates made within transaction with no origin defined.\n      tracked-origins: option<list<origin>>,\n      /// Custom logic decider, that along with [tracked-origins] can be used to determine if\n      /// transaction changes should be captured or not.\n      capture-transaction: option<bool>,\n      // /// Custom clock function, that can be used to generate timestamps used by\n      // /// [Options::capture-timeout_millis].\n      // timestamp: Rc<dyn Fn() -> u64>,\n    }\n\n    record undo-manager-ref {\n      ref: u32,\n    }\n\n    undo-manager-new: func(doc: y-doc, scope: y-type, options: undo-manager-options) -> undo-manager-ref\n    undo-manager-add-to-scope: func(ref: undo-manager-ref, ytypes: list<y-type>) \n    undo-manager-add-tracked-origin: func(ref: undo-manager-ref, origin: origin) \n    undo-manager-remove-tracked-origin: func(ref: undo-manager-ref, origin: origin) \n    undo-manager-clear: func(ref: undo-manager-ref) -> result<_, error> \n    undo-manager-stop-capturing: func(ref: undo-manager-ref) \n    undo-manager-undo: func(ref: undo-manager-ref) -> result<bool, error> \n    undo-manager-redo: func(ref: undo-manager-ref) -> result<bool, error> \n    undo-manager-can-undo: func(ref: undo-manager-ref) -> bool \n    undo-manager-can-redo: func(ref: undo-manager-ref) -> bool \n    undo-manager-on-item-added: func(ref: undo-manager-ref, function-id: u32) -> event-observer \n    undo-manager-on-item-popped: func(ref: undo-manager-ref, function-id: u32) -> event-observer \n}\n";
use exports::y_crdt_namespace::y_crdt::y_doc_methods::*;
use lib0::any::Any;
use std::cell::RefCell;
use std::collections::{HashMap, VecDeque};
use std::convert::TryFrom;
use std::mem::ManuallyDrop;
use std::ops::Deref;
use std::rc::Rc;
use std::sync::Arc;
use y_crdt_namespace::y_crdt::y_doc_methods_types::{
    EventPathItem, JsonArrayRef, JsonMapRef, JsonValue, StackItemSets, StartLength,
    YArrayDelta, YArrayDeltaDelete, YArrayDeltaInsert, YArrayDeltaRetain, YArrayEvent,
    YMapDelta, YMapDeltaAction, YMapEvent, YTextDeltaDelete, YTextDeltaInsert,
    YTextDeltaRetain, YTextEvent, YUndoKind,
};
use yrs::block::{ClientID, ItemContent, Prelim, Unused};
use yrs::types::array::ArrayEvent;
use yrs::types::map::MapEvent;
use yrs::types::text::{ChangeKind, Diff, TextEvent, YChange};
use yrs::types::xml::{XmlEvent, XmlTextEvent};
use yrs::types::{
    Attrs, Branch, BranchPtr, Change, DeepEventsSubscription, DeepObservable, Delta,
    EntryChange, Event, Events, Path, PathSegment, ToJson, TypeRef, Value,
};
use yrs::undo::{EventKind, StackItem, UndoEventSubscription};
use yrs::updates::decoder::{Decode, DecoderV1};
use yrs::updates::encoder::{Encode, Encoder, EncoderV1, EncoderV2};
use yrs::{
    Array, ArrayRef, Assoc, DeleteSet, DestroySubscription, Doc, GetString, IndexScope,
    Map, MapRef, Observable, Offset, Options, Origin, ReadTxn, Snapshot, StateVector,
    StickyIndex, Store, SubdocsEvent, SubdocsEventIter, SubdocsSubscription,
    Subscription, Text, TextRef, Transact, Transaction, TransactionCleanupEvent,
    TransactionCleanupSubscription, TransactionMut, UndoManager, Update,
    UpdateSubscription, Xml, XmlElementPrelim, XmlElementRef, XmlFragment,
    XmlFragmentRef, XmlNode, XmlTextPrelim, XmlTextRef, ID,
};
use once_cell::unsync::Lazy;
const IMAGES_MAP: ::std::thread::LocalKey<Lazy<RefCell<GlobalState>>> = {
    #[inline]
    fn __init() -> Lazy<RefCell<GlobalState>> {
        Lazy::new(|| Default::default())
    }
    #[inline]
    unsafe fn __getit(
        init: ::std::option::Option<
            &mut ::std::option::Option<Lazy<RefCell<GlobalState>>>,
        >,
    ) -> ::std::option::Option<&'static Lazy<RefCell<GlobalState>>> {
        #[thread_local]
        static __KEY: ::std::thread::local_impl::Key<Lazy<RefCell<GlobalState>>> = ::std::thread::local_impl::Key::<
            Lazy<RefCell<GlobalState>>,
        >::new();
        #[allow(unused_unsafe)]
        unsafe {
            __KEY
                .get(move || {
                    if let ::std::option::Option::Some(init) = init {
                        if let ::std::option::Option::Some(value) = init.take() {
                            return value;
                        } else if true {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("missing default value")
                                    ),
                                );
                            };
                        }
                    }
                    __init()
                })
        }
    }
    unsafe { ::std::thread::LocalKey::new(__getit) }
};
const TXN_STATE: ::std::thread::LocalKey<Lazy<RefCell<TxnState>>> = {
    #[inline]
    fn __init() -> Lazy<RefCell<TxnState>> {
        Lazy::new(|| Default::default())
    }
    #[inline]
    unsafe fn __getit(
        init: ::std::option::Option<&mut ::std::option::Option<Lazy<RefCell<TxnState>>>>,
    ) -> ::std::option::Option<&'static Lazy<RefCell<TxnState>>> {
        #[thread_local]
        static __KEY: ::std::thread::local_impl::Key<Lazy<RefCell<TxnState>>> = ::std::thread::local_impl::Key::<
            Lazy<RefCell<TxnState>>,
        >::new();
        #[allow(unused_unsafe)]
        unsafe {
            __KEY
                .get(move || {
                    if let ::std::option::Option::Some(init) = init {
                        if let ::std::option::Option::Some(value) = init.take() {
                            return value;
                        } else if true {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("missing default value")
                                    ),
                                );
                            };
                        }
                    }
                    __init()
                })
        }
    }
    unsafe { ::std::thread::LocalKey::new(__getit) }
};
const UNDO_STATE: ::std::thread::LocalKey<Lazy<RefCell<UndoState>>> = {
    #[inline]
    fn __init() -> Lazy<RefCell<UndoState>> {
        Lazy::new(|| Default::default())
    }
    #[inline]
    unsafe fn __getit(
        init: ::std::option::Option<&mut ::std::option::Option<Lazy<RefCell<UndoState>>>>,
    ) -> ::std::option::Option<&'static Lazy<RefCell<UndoState>>> {
        #[thread_local]
        static __KEY: ::std::thread::local_impl::Key<Lazy<RefCell<UndoState>>> = ::std::thread::local_impl::Key::<
            Lazy<RefCell<UndoState>>,
        >::new();
        #[allow(unused_unsafe)]
        unsafe {
            __KEY
                .get(move || {
                    if let ::std::option::Option::Some(init) = init {
                        if let ::std::option::Option::Some(value) = init.take() {
                            return value;
                        } else if true {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("missing default value")
                                    ),
                                );
                            };
                        }
                    }
                    __init()
                })
        }
    }
    unsafe { ::std::thread::LocalKey::new(__getit) }
};
pub struct GlobalState {
    pub last_id: u32,
    pub docs: HashMap<u32, Doc>,
    pub texts: HashMap<u32, TextRef>,
    pub arrays: HashMap<u32, ArrayRef>,
    pub maps: HashMap<u32, MapRef>,
    pub xml_elements: HashMap<u32, XmlElementRef>,
    pub xml_fragments: HashMap<u32, XmlFragmentRef>,
    pub xml_texts: HashMap<u32, XmlTextRef>,
    pub snapshots: HashMap<u32, Snapshot>,
    pub callbacks: HashMap<u32, Subscription<Arc<dyn std::any::Any>>>,
}
#[automatically_derived]
impl ::core::default::Default for GlobalState {
    #[inline]
    fn default() -> GlobalState {
        GlobalState {
            last_id: ::core::default::Default::default(),
            docs: ::core::default::Default::default(),
            texts: ::core::default::Default::default(),
            arrays: ::core::default::Default::default(),
            maps: ::core::default::Default::default(),
            xml_elements: ::core::default::Default::default(),
            xml_fragments: ::core::default::Default::default(),
            xml_texts: ::core::default::Default::default(),
            snapshots: ::core::default::Default::default(),
            callbacks: ::core::default::Default::default(),
        }
    }
}
impl GlobalState {
    fn save_doc(&mut self, image: Doc) -> YDoc {
        let id = self.last_id;
        self.last_id += 1;
        let image_ref = YDoc { ref_: id };
        self.docs.insert(id, image);
        image_ref
    }
    fn save_text(&mut self, t: TextRef) -> YText {
        let id = self.last_id;
        self.last_id += 1;
        let v = YText { ref_: id };
        self.texts.insert(id, t);
        v
    }
    fn save_array(&mut self, t: ArrayRef) -> YArray {
        let id = self.last_id;
        self.last_id += 1;
        let v = YArray { ref_: id };
        self.arrays.insert(id, t);
        v
    }
    fn save_map(&mut self, t: MapRef) -> YMap {
        let id = self.last_id;
        self.last_id += 1;
        let v = YMap { ref_: id };
        self.maps.insert(id, t);
        v
    }
    fn save_xml_element(&mut self, t: XmlElementRef) -> YXmlElement {
        let id = self.last_id;
        self.last_id += 1;
        let v = YXmlElement { ref_: id };
        self.xml_elements.insert(id, t);
        v
    }
    fn save_xml_fragment(&mut self, t: XmlFragmentRef) -> YXmlFragment {
        let id = self.last_id;
        self.last_id += 1;
        let v = YXmlFragment { ref_: id };
        self.xml_fragments.insert(id, t);
        v
    }
    fn save_xml_text(&mut self, t: XmlTextRef) -> YXmlText {
        let id = self.last_id;
        self.last_id += 1;
        let v = YXmlText { ref_: id };
        self.xml_texts.insert(id, t);
        v
    }
    fn save_snapshot(&mut self, t: Snapshot) -> YSnapshot {
        let id = self.last_id;
        self.last_id += 1;
        let v = YSnapshot { ref_: id };
        self.snapshots.insert(id, t);
        v
    }
    fn save_callback(
        &mut self,
        subs: Subscription<Arc<dyn std::any::Any>>,
    ) -> EventObserver {
        self.last_id += 1;
        let id = self.last_id;
        self.callbacks.insert(id, subs);
        EventObserver { ref_: id }
    }
}
pub struct TxnState {
    pub last_id: u32,
    pub transactions: HashMap<u32, Rc<Transaction<'static>>>,
    pub transactions_mut: HashMap<u32, TransactionMut<'static>>,
}
#[automatically_derived]
impl ::core::default::Default for TxnState {
    #[inline]
    fn default() -> TxnState {
        TxnState {
            last_id: ::core::default::Default::default(),
            transactions: ::core::default::Default::default(),
            transactions_mut: ::core::default::Default::default(),
        }
    }
}
impl TxnState {
    fn save_transaction(&mut self, t: Transaction<'static>) -> ReadTransaction {
        let id = self.last_id;
        self.last_id += 1;
        let v = ReadTransaction { ref_: id };
        self.transactions.insert(id, Rc::new(t));
        v
    }
    fn save_transaction_mut(&mut self, t: TransactionMut<'static>) -> WriteTransaction {
        let id = self.last_id;
        self.last_id += 1;
        let v = WriteTransaction { ref_: id };
        self.transactions_mut.insert(id, t);
        v
    }
}
pub struct UndoState {
    pub last_id: u32,
    pub undo_managers: HashMap<u32, UndoManager>,
}
#[automatically_derived]
impl ::core::default::Default for UndoState {
    #[inline]
    fn default() -> UndoState {
        UndoState {
            last_id: ::core::default::Default::default(),
            undo_managers: ::core::default::Default::default(),
        }
    }
}
impl UndoState {
    fn save_undo_manager(&mut self, um: UndoManager) -> UndoManagerRef {
        self.last_id += 1;
        let id = self.last_id;
        self.undo_managers.insert(id, um);
        UndoManagerRef { ref_: id }
    }
}
fn with_mut<T>(f: impl FnOnce(&mut GlobalState) -> T) -> T {
    IMAGES_MAP.with(|v| f(&mut v.borrow_mut()))
}
fn with<T>(f: impl FnOnce(&GlobalState) -> T) -> T {
    IMAGES_MAP.with(|v| f(&v.borrow()))
}
fn with_txn_state<T>(f: impl FnOnce(&mut TxnState) -> T) -> T {
    TXN_STATE.with(|v| f(&mut v.borrow_mut()))
}
fn operation<T>(image_ref: YDoc, f: impl FnOnce(&Doc) -> T) -> T {
    with(|state| {
        let img = &state.docs[&image_ref.ref_];
        f(img)
    })
}
fn with_undo_state<T>(f: impl FnOnce(&mut GlobalState, &mut UndoState) -> T) -> T {
    IMAGES_MAP
        .with(|v| {
            UNDO_STATE.with(|state| f(&mut v.borrow_mut(), &mut state.borrow_mut()))
        })
}
fn with_undo_manager<T>(um: UndoManagerRef, f: impl FnOnce(&mut UndoManager) -> T) -> T {
    UNDO_STATE
        .with(|v| {
            let v = &mut v.borrow_mut();
            let um = v.undo_managers.get_mut(&um.ref_).unwrap();
            f(um)
        })
}
fn with_mut_all<T>(f: impl FnOnce(&mut GlobalState, &mut TxnState) -> T) -> T {
    IMAGES_MAP
        .with(|v| {
            TXN_STATE.with(|state| f(&mut v.borrow_mut(), &mut state.borrow_mut()))
        })
}
fn with_txn<T>(t: YTransaction, f: impl FnOnce(&YTransactionInner) -> T) -> T {
    TXN_STATE
        .with(|state| {
            let mut m = state.borrow_mut();
            let t = YTransactionInner::from_ref(t, &mut m);
            f(&t)
        })
}
fn with_text<T>(
    text: YText,
    txn: ImplicitTransaction,
    f: impl FnOnce(&TextRef, &mut TransactionMut<'static>) -> T,
) -> T {
    IMAGES_MAP
        .with(|state| {
            TXN_STATE
                .with(|txs| {
                    let v = &state.borrow_mut().texts[&text.ref_];
                    YTransactionInner::from_transact_mut_f(
                        txn,
                        v,
                        &mut txs.borrow_mut(),
                        |txn| f(v, txn),
                    )
                })
        })
}
fn with_array<T>(
    array: YArray,
    txn: ImplicitTransaction,
    f: impl FnOnce(&ArrayRef, &mut TransactionMut<'static>) -> T,
) -> T {
    IMAGES_MAP
        .with(|state| {
            TXN_STATE
                .with(|txs| {
                    let v = &state.borrow_mut().arrays[&array.ref_];
                    YTransactionInner::from_transact_mut_f(
                        txn,
                        v,
                        &mut txs.borrow_mut(),
                        |txn| f(v, txn),
                    )
                })
        })
}
fn with_map<T>(
    map: YMap,
    txn: ImplicitTransaction,
    f: impl FnOnce(&MapRef, &mut TransactionMut<'static>) -> T,
) -> T {
    IMAGES_MAP
        .with(|state| {
            TXN_STATE
                .with(|txs| {
                    let v = &state.borrow_mut().maps[&map.ref_];
                    YTransactionInner::from_transact_mut_f(
                        txn,
                        v,
                        &mut txs.borrow_mut(),
                        |txn| f(v, txn),
                    )
                })
        })
}
struct YTransactionInner<'a>(InnerTxn<'a>);
enum InnerTxn<'a> {
    ReadOnly(Rc<Transaction<'static>>),
    ReadWrite(&'a mut TransactionMut<'static>),
}
impl<'a> YTransactionInner<'a> {
    fn from_ref(txn: YTransaction, state: &'a mut TxnState) -> Self {
        match txn {
            YTransaction::ReadTransaction(t) => {
                let txn = &state.transactions[&t.ref_];
                YTransactionInner(InnerTxn::ReadOnly(txn.clone()))
            }
            YTransaction::WriteTransaction(t) => {
                let txn = state.transactions_mut.get_mut(&t.ref_).unwrap();
                YTransactionInner(InnerTxn::ReadWrite(txn))
            }
        }
    }
    fn from_transact<T: Transact>(
        txn: ImplicitTransaction,
        transact: &'a T,
        state: &'a mut TxnState,
    ) -> Self {
        txn.map(|t| YTransactionInner::from_ref(t, state))
            .unwrap_or_else(|| {
                YTransactionInner(
                    InnerTxn::ReadOnly(
                        Rc::new(unsafe { std::mem::transmute(transact.transact()) }),
                    ),
                )
            })
    }
    fn from_transact_mut_f<T: Transact, P>(
        txn: ImplicitTransaction,
        transact: T,
        state: &mut TxnState,
        f: impl FnOnce(&mut TransactionMut<'static>) -> P,
    ) -> P {
        match txn {
            Some(YTransaction::WriteTransaction(txn)) => {
                f(state.transactions_mut.get_mut(&txn.ref_).unwrap())
            }
            _ => {
                let mut a = transact.transact_mut();
                f(unsafe { std::mem::transmute(&mut a) })
            }
        }
    }
    fn from_transact_mut_none<T: Transact>(
        txn: ImplicitTransaction,
        transact: T,
        state: &mut TxnState,
    ) -> Option<&mut TransactionMut<'static>> {
        match txn {
            Some(YTransaction::WriteTransaction(txn)) => {
                Some(state.transactions_mut.get_mut(&txn.ref_).unwrap())
            }
            _ => None,
        }
    }
    fn try_mut(&mut self) -> Option<&mut TransactionMut<'static>> {
        match &mut self.0 {
            InnerTxn::ReadOnly(_) => None,
            InnerTxn::ReadWrite(txn) => Some(txn),
        }
    }
    fn try_apply(&mut self, update: Update) -> Result<(), String> {
        if let Some(txn) = self.try_mut() {
            txn.apply_update(update);
            Ok(())
        } else {
            Err("cannot apply an update using a read-only transaction".to_string())
        }
    }
}
impl<'a> ReadTxn for YTransactionInner<'a> {
    fn store(&self) -> &Store {
        match &self.0 {
            InnerTxn::ReadOnly(txn) => txn.store(),
            InnerTxn::ReadWrite(txn) => txn.store(),
        }
    }
}
enum SharedType<T, P> {
    Integrated(T),
    Prelim(P),
}
impl<T, P> SharedType<T, P> {
    #[inline(always)]
    fn new(value: T) -> RefCell<Self> {
        RefCell::new(SharedType::Integrated(value))
    }
    #[inline(always)]
    fn prelim(prelim: P) -> RefCell<Self> {
        RefCell::new(SharedType::Prelim(prelim))
    }
    fn as_integrated(&self) -> Option<&T> {
        if let SharedType::Integrated(value) = self { Some(value) } else { None }
    }
}
struct YTextInner(RefCell<SharedType<TextRef, String>>);
struct WitImplementation;
fn parse_options(options: YDocOptions) -> Options {
    let mut opts = Options::default();
    options.client_id.map(|v| opts.client_id = v);
    options.guid.map(|v| opts.guid = v.into());
    opts.collection_id = options.collection_id;
    options
        .offset_kind
        .map(|v| {
            opts
                .offset_kind = match v {
                OffsetKind::Utf16 => yrs::OffsetKind::Utf16,
                OffsetKind::Utf32 => yrs::OffsetKind::Utf32,
                OffsetKind::Bytes => yrs::OffsetKind::Bytes,
            }
        });
    options.skip_gc.map(|v| opts.skip_gc = v);
    options.auto_load.map(|v| opts.auto_load = v);
    options.should_load.map(|v| opts.should_load = v);
    opts
}
impl YDocMethods for WitImplementation {
    fn y_doc_dispose(doc: YDoc) -> bool {
        with_mut(|state| state.docs.remove(&doc.ref_).is_some())
    }
    fn y_text_dispose(text: YText) -> bool {
        with_mut(|state| state.texts.remove(&text.ref_).is_some())
    }
    fn y_array_dispose(array: YArray) -> bool {
        with_mut(|state| state.arrays.remove(&array.ref_).is_some())
    }
    fn y_map_dispose(map: YMap) -> bool {
        with_mut(|state| state.maps.remove(&map.ref_).is_some())
    }
    fn y_xml_element_dispose(xml_element: YXmlElement) -> bool {
        with_mut(|state| state.xml_elements.remove(&xml_element.ref_).is_some())
    }
    fn y_xml_fragment_dispose(xml_fragment: YXmlFragment) -> bool {
        with_mut(|state| state.xml_fragments.remove(&xml_fragment.ref_).is_some())
    }
    fn y_xml_text_dispose(xml_text: YXmlText) -> bool {
        with_mut(|state| state.xml_texts.remove(&xml_text.ref_).is_some())
    }
    fn y_transaction_dispose(transaction: YTransaction) -> bool {
        with_txn_state(|state| match transaction {
            YTransaction::ReadTransaction(a) => {
                state.transactions.remove(&a.ref_).is_some()
            }
            YTransaction::WriteTransaction(a) => {
                state.transactions.remove(&a.ref_).is_some()
            }
        })
    }
    fn y_value_dispose(value: YValue) -> bool {
        match value {
            YValue::JsonValueItem(_) => false,
            YValue::YType(YType::YText(a)) => Self::y_text_dispose(a),
            YValue::YType(YType::YArray(a)) => Self::y_array_dispose(a),
            YValue::YType(YType::YMap(a)) => Self::y_map_dispose(a),
            YValue::YType(YType::YXmlElement(a)) => Self::y_xml_element_dispose(a),
            YValue::YType(YType::YXmlFragment(a)) => Self::y_xml_fragment_dispose(a),
            YValue::YType(YType::YXmlText(a)) => Self::y_xml_text_dispose(a),
            YValue::YDoc(a) => Self::y_doc_dispose(a),
        }
    }
    fn y_snapshot_dispose(snapshot: YSnapshot) -> bool {
        with_mut(|state: &mut GlobalState| {
            state.snapshots.remove(&snapshot.ref_).is_some()
        })
    }
    fn callback_dispose(obs: EventObserver) -> bool {
        with_mut(|state| state.callbacks.remove(&obs.ref_).is_some())
    }
    fn undo_manager_dispose(obs: UndoManagerRef) -> bool {
        UNDO_STATE
            .with(|state| state.borrow_mut().undo_managers.remove(&obs.ref_).is_some())
    }
    fn y_doc_new(options: Option<YDocOptions>) -> YDoc {
        let options = options.map(parse_options).unwrap_or_default();
        with_mut(|m| m.save_doc(Doc::with_options(options)))
    }
    fn y_doc_parent_doc(doc: YDoc) -> Option<YDoc> {
        with_mut(|state| {
            let img = &state.docs[&doc.ref_];
            img.parent_doc().map(|d| state.save_doc(d))
        })
    }
    fn y_doc_id(doc: YDoc) -> u64 {
        operation(doc, |doc| doc.client_id())
    }
    fn y_doc_guid(doc: YDoc) -> String {
        operation(doc, |doc| doc.guid().to_string())
    }
    fn y_doc_read_transaction(doc: YDoc) -> ReadTransaction {
        with_mut_all(|state, txs| {
            let d = unsafe { std::mem::transmute(state.docs[&doc.ref_].transact()) };
            txs.save_transaction(d)
        })
    }
    fn y_doc_write_transaction(doc: YDoc, origin: Vec<u8>) -> WriteTransaction {
        with_mut_all(|state, txs| {
            let d = unsafe { std::mem::transmute(state.docs[&doc.ref_].transact_mut()) };
            txs.save_transaction_mut(d)
        })
    }
    fn y_doc_text(doc: YDoc, name: String) -> YText {
        with_mut(|state| {
            let d = &state.docs[&doc.ref_];
            state.save_text(d.get_or_insert_text(&name))
        })
    }
    fn y_doc_array(doc: YDoc, name: String) -> YArray {
        with_mut(|state| {
            let d = &state.docs[&doc.ref_];
            state.save_array(d.get_or_insert_array(&name))
        })
    }
    fn y_doc_map(doc: YDoc, name: String) -> YMap {
        with_mut(|state| {
            let d = &state.docs[&doc.ref_];
            state.save_map(d.get_or_insert_map(&name))
        })
    }
    fn y_doc_xml_fragment(doc: YDoc, _: String) -> YXmlFragment {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_xml_element(doc: YDoc, _: String) -> YXmlElement {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_xml_text(doc: YDoc, _: String) -> YXmlText {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_on_update_v1(doc: YDoc, _: u32) -> EventObserver {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_doc_subdocs(doc: YDoc, txn: ImplicitTransaction) -> Vec<YDoc> {
        with_mut_all(|state, txs| {
            let doc = &state.docs[&doc.ref_];
            let list: Vec<_> = YTransactionInner::from_transact(txn, doc, txs)
                .subdocs()
                .into_iter()
                .map(|d| d.clone())
                .collect();
            list.into_iter().map(|d| state.save_doc(d.clone())).collect()
        })
    }
    fn y_doc_subdoc_guids(doc: YDoc, txn: ImplicitTransaction) -> Vec<String> {
        with_mut_all(|state, txs| {
            let doc = &state.docs[&doc.ref_];
            YTransactionInner::from_transact(txn, doc, txs)
                .subdoc_guids()
                .into_iter()
                .map(|d| d.to_string())
                .collect()
        })
    }
    fn y_doc_load(doc: YDoc, txn: ImplicitTransaction) {
        with_mut_all(|state, txs| {
            let d = &state.docs[&doc.ref_];
            if let Some(YTransaction::WriteTransaction(txn)) = txn {
                let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                d.load(txn)
            } else {
                if let Some(parent) = d.parent_doc() {
                    let mut txn = parent.transact_mut();
                    d.load(&mut txn)
                }
            }
        })
    }
    fn y_doc_destroy(doc: YDoc, txn: ImplicitTransaction) {
        with_mut_all(|state, txs| {
            let d = state.docs.get_mut(&doc.ref_).unwrap();
            if let Some(YTransaction::WriteTransaction(txn)) = txn {
                let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                d.destroy(txn)
            } else {
                if let Some(parent) = d.parent_doc() {
                    let mut txn = parent.transact_mut();
                    d.destroy(&mut txn)
                }
            }
        })
    }
    fn y_text_to_delta(
        text: YText,
        snapshot: Option<YSnapshot>,
        prev_snapshot: Option<YSnapshot>,
        txn: ImplicitTransaction,
    ) -> Vec<YTextDelta> {
        with_mut_all(|state, txs| {
            let v = &state.texts[&text.ref_];
            YTransactionInner::from_transact_mut_f(
                txn,
                v,
                txs,
                |txn| {
                    let hi = snapshot.map(|s| state.snapshots.get(&s.ref_)).flatten();
                    let lo = prev_snapshot
                        .map(|s| state.snapshots.get(&s.ref_))
                        .flatten();
                    v.diff_range(txn, hi, lo, |change| change)
                        .into_iter()
                        .map(ytext_change_into_delta)
                        .collect()
                },
            )
        })
    }
    fn snapshot(doc: YDoc) -> YSnapshot {
        with_mut(|state| {
            let d = state.docs.get_mut(&doc.ref_).unwrap().transact().snapshot();
            state.save_snapshot(d)
        })
    }
    fn equal_snapshot(left: YSnapshot, right: YSnapshot) -> bool {
        with(|state| {
            let left = &state.snapshots[&left.ref_];
            let right = &state.snapshots[&right.ref_];
            left == right
        })
    }
    fn encode_snapshot_v1(snapshot: YSnapshot) -> Vec<u8> {
        with(|state| {
            let snapshot = &state.snapshots[&snapshot.ref_];
            snapshot.encode_v1()
        })
    }
    fn encode_snapshot_v2(snapshot: YSnapshot) -> Vec<u8> {
        with(|state| {
            let snapshot = &state.snapshots[&snapshot.ref_];
            snapshot.encode_v2()
        })
    }
    fn decode_snapshot_v1(snapshot: Vec<u8>) -> Result<YSnapshot, Error> {
        with_mut(|state| {
            let s = Snapshot::decode_v1(&snapshot)
                .map_err(|e| {
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "failed to deserialize snapshot using lib0 v1 decoding. {0}",
                                e
                            ),
                        );
                        res
                    }
                })?;
            Ok(state.save_snapshot(s))
        })
    }
    fn decode_snapshot_v2(snapshot: Vec<u8>) -> Result<YSnapshot, Error> {
        with_mut(|state| {
            let s = Snapshot::decode_v2(&snapshot)
                .map_err(|e| {
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "failed to deserialize snapshot using lib0 v2 decoding. {0}",
                                e
                            ),
                        );
                        res
                    }
                })?;
            Ok(state.save_snapshot(s))
        })
    }
    fn encode_state_from_snapshot_v1(
        doc: YDoc,
        snapshot: YSnapshot,
    ) -> Result<Vec<u8>, Error> {
        with_mut(|state| {
            let mut encoder = EncoderV1::new();
            let snapshot = &state.snapshots[&snapshot.ref_];
            match state
                .docs[&doc.ref_]
                .transact()
                .encode_state_from_snapshot(snapshot, &mut encoder)
            {
                Ok(_) => Ok(encoder.to_vec()),
                Err(e) => Err(e.to_string()),
            }
        })
    }
    fn encode_state_from_snapshot_v2(
        doc: YDoc,
        snapshot: YSnapshot,
    ) -> Result<Vec<u8>, Error> {
        with_mut(|state| {
            let mut encoder = EncoderV2::new();
            let snapshot = &state.snapshots[&snapshot.ref_];
            match state
                .docs[&doc.ref_]
                .transact()
                .encode_state_from_snapshot(snapshot, &mut encoder)
            {
                Ok(_) => Ok(encoder.to_vec()),
                Err(e) => Err(e.to_string()),
            }
        })
    }
    fn encode_state_vector(doc: YDoc) -> Vec<u8> {
        operation(doc, |doc| doc.transact().state_vector().encode_v1())
    }
    fn encode_state_as_update(
        doc: YDoc,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        operation(
            doc,
            |doc| {
                let s = doc.transact();
                diff_v1(&s, vector)
            },
        )
    }
    fn encode_state_as_update_v2(
        doc: YDoc,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        operation(
            doc,
            |doc| {
                let s = doc.transact();
                diff_v2(&s, vector)
            },
        )
    }
    fn apply_update(doc: YDoc, diff: Vec<u8>, origin: Vec<u8>) -> Result<(), String> {
        operation(
            doc,
            |doc| {
                let mut txn = doc.transact_mut();
                let mut decoder = DecoderV1::from(diff.as_slice());
                match Update::decode(&mut decoder) {
                    Ok(update) => Ok(txn.apply_update(update)),
                    Err(e) => Err(e.to_string()),
                }
            },
        )
    }
    fn apply_update_v2(doc: YDoc, diff: Vec<u8>, origin: Vec<u8>) -> Result<(), String> {
        operation(
            doc,
            |doc| {
                let mut txn = doc.transact_mut();
                match Update::decode_v2(&diff) {
                    Ok(update) => Ok(txn.apply_update(update)),
                    Err(e) => Err(e.to_string()),
                }
            },
        )
    }
    fn transaction_origin(t: YTransaction) -> Option<Vec<u8>> {
        with_txn_state(|state| match t {
            YTransaction::ReadTransaction(t) => None,
            YTransaction::WriteTransaction(t) => {
                state.transactions_mut[&t.ref_].origin().map(|r| r.as_ref().to_vec())
            }
        })
    }
    fn transaction_commit(t: YTransaction) {
        with_txn_state(|state| match &t {
            YTransaction::ReadTransaction(t) => {
                state.transactions.remove(&t.ref_);
            }
            YTransaction::WriteTransaction(t) => {
                state.transactions_mut.remove(&t.ref_).unwrap().commit()
            }
        })
    }
    fn transaction_state_vector_v1(t: YTransaction) -> Vec<u8> {
        with_txn(t, |t| t.state_vector().encode_v1().to_vec())
    }
    fn transaction_diff_v1(
        t: YTransaction,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        with_txn(t, |t| diff_v1(t, vector))
    }
    fn transaction_diff_v2(
        txn: YTransaction,
        vector: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        with_txn(txn, |txn| diff_v2(txn, vector))
    }
    fn transaction_apply_v1(txn: YTransaction, diff: Vec<u8>) -> Result<(), Error> {
        match txn {
            YTransaction::ReadTransaction(_) => {
                Err("Cannot apply update to read transaction".to_string())
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|txs| {
                    let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                    let mut decoder = DecoderV1::from(diff.as_slice());
                    match Update::decode(&mut decoder) {
                        Ok(update) => Ok(txn.apply_update(update)),
                        Err(e) => Err(e.to_string()),
                    }
                })
            }
        }
    }
    fn transaction_apply_v2(txn: YTransaction, diff: Vec<u8>) -> Result<(), String> {
        match txn {
            YTransaction::ReadTransaction(_) => {
                Err("Cannot apply update to read transaction".to_string())
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|txs| {
                    let txn = txs.transactions_mut.get_mut(&txn.ref_).unwrap();
                    match Update::decode_v2(diff.as_slice()) {
                        Ok(update) => Ok(txn.apply_update(update)),
                        Err(e) => Err(e.to_string()),
                    }
                })
            }
        }
    }
    fn transaction_encode_update(t: YTransaction) -> Vec<u8> {
        match t {
            YTransaction::ReadTransaction(_) => {
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0u8, 0u8]))
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|state| {
                    state.transactions_mut[&txn.ref_].encode_update_v1()
                })
            }
        }
    }
    fn transaction_encode_update_v2(t: YTransaction) -> Vec<u8> {
        match t {
            YTransaction::ReadTransaction(_) => {
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0u8, 0u8]))
            }
            YTransaction::WriteTransaction(txn) => {
                with_txn_state(|state| {
                    state.transactions_mut[&txn.ref_].encode_update_v2()
                })
            }
        }
    }
    fn y_text_new(init: Option<String>) -> YText {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_text_prelim(text: YText) -> bool {
        false
    }
    fn y_text_length(text: YText, txn: ImplicitTransaction) -> u32 {
        with_mut_all(|state, txs| {
            let text = &state.texts[&text.ref_];
            let txn = YTransactionInner::from_transact(txn, text, txs);
            text.len(&txn) as u32
        })
    }
    fn y_text_to_string(text: YText, txn: ImplicitTransaction) -> String {
        with_mut_all(|state, txs| {
            let text = &state.texts[&text.ref_];
            let txn = YTransactionInner::from_transact(txn, text, txs);
            text.get_string(&txn)
        })
    }
    fn y_text_to_json(text: YText, txn: ImplicitTransaction) -> String {
        Self::y_text_to_string(text, txn)
    }
    fn y_text_insert(
        text: YText,
        index: u32,
        chunk: String,
        attributes: Option<JsonObject>,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let chunk = &chunk;
                if let Some(attrs) = attributes.map(parse_attrs) {
                    v.insert_with_attributes(txn, index, chunk, attrs)
                } else {
                    v.insert(txn, index, chunk)
                }
            },
        )
    }
    fn y_text_insert_embed(
        text: YText,
        index: u32,
        embed: JsonValueItem,
        attributes: Option<JsonObject>,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let embed = map_json_value_any(embed);
                if let Some(attrs) = attributes.map(parse_attrs) {
                    v.insert_embed_with_attributes(txn, index, embed, attrs);
                } else {
                    v.insert_embed(txn, index, embed);
                }
            },
        )
    }
    fn y_text_format(
        text: YText,
        index: u32,
        length: u32,
        attributes: JsonObject,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let attrs = parse_attrs(attributes);
                v.format(txn, index, length, attrs);
            },
        )
    }
    fn y_text_push(
        text: YText,
        chunk: String,
        attributes: Option<JsonObject>,
        txn: ImplicitTransaction,
    ) {
        with_text(
            text,
            txn,
            |v, txn| {
                let chunk = &chunk;
                if let Some(attrs) = attributes.map(parse_attrs) {
                    let index = v.len(txn);
                    v.insert_with_attributes(txn, index, chunk, attrs)
                } else {
                    v.push(txn, chunk)
                }
            },
        )
    }
    fn y_text_delete(text: YText, index: u32, length: u32, txn: ImplicitTransaction) {
        with_text(
            text,
            txn,
            |v, txn| {
                v.remove_range(txn, index, length);
            },
        )
    }
    fn y_text_observe(text: YText, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.texts.get_mut(&text.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(
                    v
                        .observe(move |e_txn, e| {
                            let event = map_text_event(text.clone(), e_txn, e);
                            event_callback(function_id, &event)
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
    fn y_text_observe_deep(text: YText, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.texts.get_mut(&text.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(v.observe_deep(observer_deep(function_id)))
            };
            state.save_callback(subs)
        })
    }
    fn y_array_new(_: Option<JsonArray>) -> YArray {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_array_prelim(array: YArray) -> bool {
        false
    }
    fn y_array_length(array: YArray, txn: ImplicitTransaction) -> u32 {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.len(&txn)
        })
    }
    fn y_array_to_json(array: YArray, txn: ImplicitTransaction) -> JsonValueItem {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            map_any_json_value(v.to_json(&txn))
        })
    }
    fn y_array_insert(
        array: YArray,
        index: u32,
        items: JsonArray,
        txn: ImplicitTransaction,
    ) {
        with_array(
            array,
            txn,
            |v, txn| {
                let items = match map_json_value_any(items) {
                    Any::Array(items) => items,
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("expected array"));
                    }
                };
                insert_at(v, txn, index, items);
            },
        )
    }
    fn y_array_push(array: YArray, items: JsonArray, txn: ImplicitTransaction) {
        with_array(
            array,
            txn,
            |v, txn| {
                let index = v.len(txn);
                let items = match map_json_value_any(items) {
                    Any::Array(items) => items,
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("expected array"));
                    }
                };
                insert_at(v, txn, index, items);
            },
        )
    }
    fn y_array_delete(array: YArray, index: u32, length: u32, txn: ImplicitTransaction) {
        with_array(
            array,
            txn,
            |v, txn| {
                v.remove_range(txn, index, length);
            },
        )
    }
    fn y_array_move_content(
        array: YArray,
        source: u32,
        target: u32,
        txn: ImplicitTransaction,
    ) {
        with_array(array, txn, |v, txn| v.move_to(txn, source, target))
    }
    fn y_array_get(
        array: YArray,
        index: u32,
        txn: ImplicitTransaction,
    ) -> Result<YValue, String> {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            if let Some(value) = v.get(&txn, index) {
                Ok(map_y_value(value))
            } else {
                Err("Index outside the bounds of an YArray".to_string())
            }
        })
    }
    fn y_array_values(array: YArray, txn: ImplicitTransaction) -> Vec<YValue> {
        with_mut_all(|state, txs| {
            let v = &state.arrays[&array.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.iter(&txn).map(map_y_value).collect()
        })
    }
    fn y_array_observe(array: YArray, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.arrays.get_mut(&array.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(
                    v
                        .observe(move |e_txn, e| {
                            let event = map_array_event(array.clone(), e_txn, e);
                            event_callback(function_id, &event)
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
    fn y_array_observe_deep(array: YArray, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.arrays.get_mut(&array.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(v.observe_deep(observer_deep(function_id)))
            };
            state.save_callback(subs)
        })
    }
    fn y_map_new(_: Option<JsonObject>) -> YMap {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_map_prelim(map: YMap) -> bool {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_map_length(map: YMap, txn: ImplicitTransaction) -> u32 {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.len(&txn)
        })
    }
    fn y_map_to_json(map: YMap, txn: ImplicitTransaction) -> JsonValueItem {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            map_any_json_value(v.to_json(&txn))
        })
    }
    fn y_map_set(
        map: YMap,
        key: String,
        value: JsonValueItem,
        txn: ImplicitTransaction,
    ) {
        with_map(
            map,
            txn,
            |v, txn| {
                v.insert(txn, key, map_json_value_any(value));
            },
        )
    }
    fn y_map_delete(map: YMap, key: String, txn: ImplicitTransaction) {
        with_map(
            map,
            txn,
            |v, txn| {
                v.remove(txn, &key);
            },
        )
    }
    fn y_map_get(map: YMap, key: String, txn: ImplicitTransaction) -> Option<YValue> {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.get(&txn, &key).map(map_y_value)
        })
    }
    fn y_map_entries(map: YMap, txn: ImplicitTransaction) -> Vec<(String, YValue)> {
        with_mut_all(|state, txs| {
            let v = &state.maps[&map.ref_];
            let txn = YTransactionInner::from_transact(txn, v, txs);
            v.iter(&txn).map(|(k, v)| (k.to_string(), map_y_value(v))).collect()
        })
    }
    fn y_map_observe(map: YMap, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.maps.get_mut(&map.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(
                    v
                        .observe(move |e_txn, e| {
                            let event = map_map_event(map.clone(), e_txn, e);
                            event_callback(function_id, &event)
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
    fn y_map_observe_deep(map: YMap, function_id: u32) -> EventObserver {
        with_mut(|state| {
            let v = state.maps.get_mut(&map.ref_).unwrap();
            let subs = unsafe {
                std::mem::transmute(v.observe_deep(observer_deep(function_id)))
            };
            state.save_callback(subs)
        })
    }
    fn y_xml_element_name(_: YXmlElement) -> Option<String> {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_length(_: YXmlElement, txn: ImplicitTransaction) -> u32 {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_insert_xml_element(
        _: YXmlElement,
        _: u32,
        _: String,
        txn: ImplicitTransaction,
    ) -> YXmlElement {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_insert_xml_text(
        _: YXmlElement,
        _: u32,
        txn: ImplicitTransaction,
    ) -> YXmlText {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_element_delete(_: YXmlElement, _: u32, _: u32, txn: ImplicitTransaction) {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_fragment_name(_: YXmlFragment) -> Option<String> {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_fragment_length(_: YXmlFragment, txn: ImplicitTransaction) -> u32 {
        ::core::panicking::panic("not yet implemented")
    }
    fn y_xml_text_length(_: YXmlText, txn: ImplicitTransaction) -> u32 {
        ::core::panicking::panic("not yet implemented")
    }
    fn undo_manager_new(
        doc: YDoc,
        scope: YType,
        options: UndoManagerOptions,
    ) -> UndoManagerRef {
        with_undo_state(|state, undo_state| {
            let doc = &state.docs[&doc.ref_];
            let mut o = yrs::undo::Options::default();
            if let Some(millis) = options.capture_timeout_millis {
                o.capture_timeout_millis = millis as u64;
            }
            if let Some(array) = options.tracked_origins {
                for v in array.iter() {
                    o.tracked_origins.insert(v.as_slice().into());
                }
            }
            let scope = branch_from_type(state, &scope);
            undo_state.save_undo_manager(UndoManager::with_options(&doc, &scope, o))
        })
    }
    fn undo_manager_add_to_scope(um: UndoManagerRef, ytypes: Vec<YType>) {
        with_undo_state(|state, undo_state| {
            let um = undo_state.undo_managers.get_mut(&um.ref_).unwrap();
            for scope in ytypes.iter() {
                let scope = branch_from_type(state, scope);
                um.expand_scope(&scope);
            }
        })
    }
    fn undo_manager_add_tracked_origin(um: UndoManagerRef, origin: Vec<u8>) {
        with_undo_manager(um, |um| um.include_origin(origin.as_slice()))
    }
    fn undo_manager_remove_tracked_origin(um: UndoManagerRef, origin: Vec<u8>) {
        with_undo_manager(um, |um| um.exclude_origin(origin.as_slice()))
    }
    fn undo_manager_clear(um: UndoManagerRef) -> Result<(), String> {
        with_undo_manager(um, |um| um.clear().map_err(|err| err.to_string()))
    }
    fn undo_manager_stop_capturing(um: UndoManagerRef) {
        with_undo_manager(um, |um| um.reset())
    }
    fn undo_manager_undo(um: UndoManagerRef) -> Result<bool, String> {
        with_undo_manager(um, |um| um.undo().map_err(|err| err.to_string()))
    }
    fn undo_manager_redo(um: UndoManagerRef) -> Result<bool, String> {
        with_undo_manager(um, |um| um.redo().map_err(|err| err.to_string()))
    }
    fn undo_manager_can_undo(um: UndoManagerRef) -> bool {
        with_undo_manager(um, |um| um.can_undo())
    }
    fn undo_manager_can_redo(um: UndoManagerRef) -> bool {
        with_undo_manager(um, |um| um.can_redo())
    }
    fn undo_manager_on_item_added(
        um: UndoManagerRef,
        function_id: u32,
    ) -> EventObserver {
        with_undo_state(|state, undo_state| {
            let subs = unsafe {
                std::mem::transmute(
                    undo_state
                        .undo_managers
                        .get_mut(&um.ref_)
                        .unwrap()
                        .observe_item_added(move |_, e| {
                            let event = map_undo_event(e);
                            undo_event_callback(function_id, &event)
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
    fn undo_manager_on_item_popped(
        um: UndoManagerRef,
        function_id: u32,
    ) -> EventObserver {
        with_undo_state(|state, undo_state| {
            let subs = unsafe {
                std::mem::transmute(
                    undo_state
                        .undo_managers
                        .get_mut(&um.ref_)
                        .unwrap()
                        .observe_item_popped(move |_, e| {
                            let event = map_undo_event(e);
                            undo_event_callback(function_id, &event)
                        }),
                )
            };
            state.save_callback(subs)
        })
    }
}
fn map_undo_event(e: &yrs::undo::Event) -> YUndoEvent {
    YUndoEvent {
        kind: match e.kind {
            EventKind::Undo => YUndoKind::Undo,
            EventKind::Redo => YUndoKind::Redo,
        },
        origin: e.origin.as_ref().map(|v| v.as_ref().to_vec()),
        stack_item: StackItemSets {
            deletions: delete_set_into_map(e.item.deletions()),
            insertions: delete_set_into_map(e.item.insertions()),
        },
    }
}
fn delete_set_into_map(ds: &DeleteSet) -> Vec<(u64, Vec<StartLength>)> {
    ds.iter()
        .map(|(&k, v)| {
            let value = v
                .iter()
                .map(|r| {
                    let start = r.start;
                    let length = r.end - r.start;
                    StartLength { start, length }
                })
                .collect();
            (k, value)
        })
        .collect()
}
fn branch_from_type<'a>(state: &'a GlobalState, scope: &YType) -> &'a dyn AsRef<Branch> {
    match scope {
        YType::YArray(a) => &state.arrays[&a.ref_],
        YType::YMap(m) => &state.maps[&m.ref_],
        YType::YText(t) => &state.texts[&t.ref_],
        YType::YXmlElement(e) => &state.xml_elements[&e.ref_],
        YType::YXmlText(e) => &state.xml_texts[&e.ref_],
        YType::YXmlFragment(f) => &state.xml_fragments[&f.ref_],
    }
}
fn map_text_delta(d: &Delta) -> YTextDelta {
    match d {
        Delta::Inserted(v, attrs) => {
            YTextDelta::YTextDeltaInsert(YTextDeltaInsert {
                insert: string_from_value(v),
                attributes: map_attributes(attrs.clone()),
            })
        }
        Delta::Deleted(c) => {
            YTextDelta::YTextDeltaDelete(YTextDeltaDelete { delete: *c })
        }
        Delta::Retain(v, attrs) => {
            YTextDelta::YTextDeltaRetain(YTextDeltaRetain {
                retain: *v,
                attributes: map_attributes(attrs.clone()),
            })
        }
    }
}
fn map_array_delta(d: &Change) -> YArrayDelta {
    match d {
        Change::Added(v) => {
            let insert = v.iter().map(|v| map_y_value(v.clone())).collect::<Vec<_>>();
            YArrayDelta::YArrayDeltaInsert(YArrayDeltaInsert { insert })
        }
        Change::Removed(c) => {
            YArrayDelta::YArrayDeltaDelete(YArrayDeltaDelete { delete: *c })
        }
        Change::Retain(v) => {
            YArrayDelta::YArrayDeltaRetain(YArrayDeltaRetain { retain: *v })
        }
    }
}
fn map_map_delta(d: &EntryChange) -> YMapDelta {
    match d {
        EntryChange::Inserted(v) => {
            YMapDelta {
                action: YMapDeltaAction::Insert,
                old_value: None,
                new_value: Some(map_y_value(v.clone())),
            }
        }
        EntryChange::Removed(c) => {
            YMapDelta {
                action: YMapDeltaAction::Delete,
                old_value: Some(map_y_value(c.clone())),
                new_value: None,
            }
        }
        EntryChange::Updated(v, v2) => {
            YMapDelta {
                action: YMapDeltaAction::Update,
                old_value: Some(map_y_value(v.clone())),
                new_value: Some(map_y_value(v2.clone())),
            }
        }
    }
}
fn ytext_change_into_delta(diff: Diff<YChange>) -> YTextDelta {
    YTextDelta::YTextDeltaInsert(YTextDeltaInsert {
        insert: string_from_value(&diff.insert),
        attributes: map_attributes(diff.attributes),
    })
}
fn map_attributes(m: Option<Box<HashMap<Arc<str>, Any>>>) -> Option<JsonValueItem> {
    m.map(|a| {
        map_any_json_value(
            Any::Map(Box::new(a.into_iter().map(|(k, v)| (k.to_string(), v)).collect())),
        )
    })
}
fn string_from_value(v: &Value) -> String {
    match v {
        Value::YText(t) => t.get_string(&t.transact()),
        Value::Any(Any::String(s)) => s.to_string(),
        _ => "".to_string(),
    }
}
fn parse_attrs(attributes: JsonObject) -> HashMap<Arc<str>, Any> {
    match map_json_value_any(attributes) {
        Any::Map(m) => m.into_iter().map(|(k, v)| (k.into(), v)).collect(),
        _ => {
            ::core::panicking::panic_fmt(format_args!("Expected a map"));
        }
    }
}
fn map_y_value(v: Value) -> YValue {
    match v {
        Value::Any(a) => YValue::JsonValueItem(map_any_json_value(a)),
        Value::YText(a) => {
            YValue::YType(YType::YText(with_mut(|state| state.save_text(a))))
        }
        Value::YArray(a) => {
            YValue::YType(YType::YArray(with_mut(|state| state.save_array(a))))
        }
        Value::YMap(a) => YValue::YType(YType::YMap(with_mut(|state| state.save_map(a)))),
        Value::YXmlElement(a) => {
            YValue::YType(
                YType::YXmlElement(with_mut(|state| { state.save_xml_element(a) })),
            )
        }
        Value::YXmlFragment(a) => {
            YValue::YType(
                YType::YXmlFragment(with_mut(|state| { state.save_xml_fragment(a) })),
            )
        }
        Value::YXmlText(a) => {
            YValue::YType(YType::YXmlText(with_mut(|state| state.save_xml_text(a))))
        }
        Value::YDoc(a) => YValue::YDoc(with_mut(|state| state.save_doc(a))),
    }
}
fn map_value(v: YValue) -> Value {
    match v {
        YValue::JsonValueItem(a) => Value::Any(map_json_value_any(a)),
        YValue::YType(YType::YText(a)) => {
            Value::YText(with_mut(|state| state.texts[&a.ref_].clone()))
        }
        YValue::YType(YType::YArray(a)) => {
            Value::YArray(with_mut(|state| state.arrays[&a.ref_].clone()))
        }
        YValue::YType(YType::YMap(a)) => {
            Value::YMap(with_mut(|state| state.maps[&a.ref_].clone()))
        }
        YValue::YType(YType::YXmlElement(a)) => {
            Value::YXmlElement(with_mut(|state| state.xml_elements[&a.ref_].clone()))
        }
        YValue::YType(YType::YXmlFragment(a)) => {
            Value::YXmlFragment(with_mut(|state| state.xml_fragments[&a.ref_].clone()))
        }
        YValue::YType(YType::YXmlText(a)) => {
            Value::YXmlText(with_mut(|state| state.xml_texts[&a.ref_].clone()))
        }
        YValue::YDoc(a) => Value::YDoc(with_mut(|state| state.docs[&a.ref_].clone())),
    }
}
fn map_json_value_any(v: JsonValueItem) -> Any {
    map_json_value_any_v(&v.item, &v)
}
fn map_json_value_any_v(item: &JsonValue, references: &JsonValueItem) -> Any {
    let map_ref = |a: &JsonValue| -> Any { map_json_value_any_v(a, references) };
    match item {
        JsonValue::Str(s) => Any::String(s.clone().into()),
        JsonValue::Number(n) => Any::Number(*n),
        JsonValue::Undefined => Any::Undefined,
        JsonValue::BigInt(n) => Any::BigInt(*n),
        JsonValue::Boolean(b) => Any::Bool(*b),
        JsonValue::Null => Any::Null,
        JsonValue::Buffer(v) => Any::Buffer(v.clone().into()),
        JsonValue::Array(a) => {
            Any::Array(
                references
                    .array_references[a.index as usize]
                    .iter()
                    .map(map_ref)
                    .collect(),
            )
        }
        JsonValue::Map(o) => {
            Any::Map(
                Box::new(
                    HashMap::from_iter(
                        references
                            .map_references[o.index as usize]
                            .iter()
                            .map(|(k, v)| (k.clone(), map_ref(&v))),
                    ),
                ),
            )
        }
    }
}
fn map_any_json_value(v: Any) -> JsonValueItem {
    let mut references = JsonValueItem {
        item: JsonValue::Undefined,
        map_references: ::alloc::vec::Vec::new(),
        array_references: ::alloc::vec::Vec::new(),
    };
    let item = map_any_json_value_ref(v, &mut references);
    references.item = item;
    references
}
fn map_any_json_value_ref(v: Any, references: &mut JsonValueItem) -> JsonValue {
    match v {
        Any::String(s) => JsonValue::Str(s.to_string()),
        Any::Number(n) => JsonValue::Number(n),
        Any::Undefined => JsonValue::Undefined,
        Any::BigInt(n) => JsonValue::BigInt(n),
        Any::Bool(b) => JsonValue::Boolean(b),
        Any::Null => JsonValue::Null,
        Any::Buffer(v) => JsonValue::Buffer(v.to_vec()),
        Any::Array(a) => {
            let m = Vec::from(a)
                .into_iter()
                .map(|v| map_any_json_value_ref(v, references))
                .collect();
            let index = references.array_references.len() as u32;
            references.array_references.push(m);
            JsonValue::Array(JsonArrayRef { index })
        }
        Any::Map(o) => {
            let m = o
                .into_iter()
                .map(|(k, v)| (k, map_any_json_value_ref(v, references)))
                .collect();
            let index = references.map_references.len() as u32;
            references.map_references.push(m);
            JsonValue::Map(JsonMapRef { index })
        }
    }
}
fn insert_at(dst: &ArrayRef, txn: &mut TransactionMut, index: u32, src: Box<[Any]>) {
    dst.insert_range(txn, index, src.into_vec());
}
fn diff_v1<T: ReadTxn>(txn: &T, vector: Option<Vec<u8>>) -> Result<Vec<u8>, String> {
    let mut encoder = EncoderV1::new();
    let sv = if let Some(vector) = vector {
        match StateVector::decode_v1(vector.to_vec().as_slice()) {
            Ok(sv) => sv,
            Err(e) => {
                return Err(e.to_string());
            }
        }
    } else {
        StateVector::default()
    };
    txn.encode_diff(&sv, &mut encoder);
    Ok(encoder.to_vec())
}
fn diff_v2<T: ReadTxn>(txn: &T, vector: Option<Vec<u8>>) -> Result<Vec<u8>, String> {
    let mut encoder = EncoderV2::new();
    let sv = if let Some(vector) = vector {
        match StateVector::decode_v1(vector.to_vec().as_slice()) {
            Ok(sv) => sv,
            Err(e) => {
                return Err(e.to_string());
            }
        }
    } else {
        StateVector::default()
    };
    txn.encode_diff(&sv, &mut encoder);
    Ok(encoder.to_vec())
}
fn map_event<'a>(
    state: &mut GlobalState,
    e_txn: &TransactionMut<'_>,
    e: &Event,
) -> YEvent {
    match e {
        Event::Text(e) => {
            let text = state.save_text(e.target().clone());
            map_text_event(text, e_txn, e)
        }
        Event::Map(e) => {
            let map = state.save_map(e.target().clone());
            map_map_event(map, e_txn, e)
        }
        Event::Array(e) => {
            let array = state.save_array(e.target().clone());
            map_array_event(array, e_txn, e)
        }
        _ => ::core::panicking::panic("not implemented"),
    }
}
fn map_text_event<'a>(text: YText, e_txn: &TransactionMut<'_>, e: &TextEvent) -> YEvent {
    let p = e.path();
    let path = p
        .iter()
        .map(|v| match v {
            PathSegment::Index(i) => EventPathItem::U32(*i),
            PathSegment::Key(k) => EventPathItem::String(k.to_string()),
        })
        .collect::<Vec<EventPathItem>>();
    YEvent::YTextEvent(YTextEvent {
        path,
        delta: e.delta(e_txn).iter().map(map_text_delta).collect::<Vec<_>>(),
        target: text,
    })
}
fn map_path_segment<'a>(p: &VecDeque<PathSegment>) -> Vec<EventPathItem> {
    p.iter()
        .map(|v| match v {
            PathSegment::Index(i) => EventPathItem::U32(*i),
            PathSegment::Key(k) => EventPathItem::String(k.to_string()),
        })
        .collect::<Vec<EventPathItem>>()
}
fn map_array_event<'a>(
    array: YArray,
    e_txn: &TransactionMut<'_>,
    e: &ArrayEvent,
) -> YEvent {
    let p = e.path();
    let path = map_path_segment(&p);
    YEvent::YArrayEvent(YArrayEvent {
        path,
        delta: e.delta(e_txn).iter().map(map_array_delta).collect::<Vec<_>>(),
        target: array,
    })
}
fn map_map_event<'a>(map: YMap, e_txn: &'a TransactionMut<'_>, e: &MapEvent) -> YEvent {
    let p = e.path();
    let path = map_path_segment(&p);
    YEvent::YMapEvent(YMapEvent {
        path,
        keys: e
            .keys(e_txn)
            .iter()
            .map(|(k, v)| (k.to_string(), map_map_delta(v)))
            .collect::<Vec<_>>(),
        target: map,
    })
}
fn observer_deep(function_id: u32) -> impl Fn(&TransactionMut<'_>, &Events) {
    move |e_txn: &TransactionMut<'_>, e: &Events| {
        with_mut(|state| {
            let events = e
                .iter()
                .map(|e| map_event(state, e_txn, e))
                .collect::<Vec<_>>();
            event_deep_callback(function_id, &events)
        })
    }
}
