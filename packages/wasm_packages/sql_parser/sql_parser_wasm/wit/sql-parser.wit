package sql-parser-namespace:sql-parser

world sql-parser {
    /// A record is a class with named fields
    /// There are enum, list, variant, option, result, tuple and union types
    record model {
      /// Comment for a field
      integer: s32,
    }

    /// An import is a function that is provided by the host environment (Dart)
    import map-integer: func(value: s32) -> float64

    /// export
    export run: func(value: model) -> result<float64, string>

    union sql-ast {
      // analyze
      sql-insert,
      sql-update,
      // copy
      sql-delete,
      sql-query,
      sql-create-view,
      sql-create-table,
      sql-create-index,
      alter-table,
      alter-index,
      // drop
      // drop-function
      // fetch
      create-virtual-table,
      sql-declare,
      set-variable,

      start-transaction,
      set-transaction,
      commit,
      savepoint,
      rollback,

      create-function,
      create-procedure,
      create-macro,
      sql-assert,
      sql-execute,
      create-type,
    }

    record sql-ast-ref {
      index: u32,
    }

    record savepoint {
      name: ident,
    }

    record sql-prepare {
      name: ident,
      data-types: list<data-type>,
      statement: sql-ast-ref,
    }

    record create-virtual-table {
      name: object-name,
      if-not-exists: bool,
      module-name: ident,
      module-args: list<ident>,
    }

    record sql-declare {
      name: ident,
      binary: bool,
      sensitive: option<bool>,
      scroll: option<bool>,
      hold: option<bool>,
      query: sql-query,
    }

    record set-variable {
      local: bool,
      hivevar: bool,
      variable: object-name,
      value: list<expr>,
    }

    record start-transaction {
      modes: list<transaction-mode>,
    }

    record set-transaction {
      modes: list<transaction-mode>,
      snapshot: option<sql-value>,
      session: bool,
    }

    record commit {
      chain: bool,
    }

    record rollback {
      chain: bool,
    }

    record create-function {
      or-replace: bool,
      temporary: bool,
      name: object-name,
      args: option<list<operate-function-arg>>,
      return-type: option<data-type>,
      params: create-function-body,
    }

    record create-procedure {
      or-alter: bool,
      name: object-name,
      params: option<list<procedure-param>>,
      body: list<sql-ast-ref>,
    }

    record create-macro {
      or-replace: bool,
      temporary: bool,
      name: object-name,
      args: option<list<macro-arg>>,
      definition: macro-definition,
    }

    record sql-assert {
      condition: expr,
      message: option<expr>,
    }

    record sql-execute {
      name: ident,
      parameters: list<expr>,
    }

    record create-type {
      name: object-name,
      representation: user-defined-type-representation,
    }

    record alter-table {
      name: object-name,
      operation: alter-table-operation,
    }

    union transaction-mode {
      transaction-access-mode,
      transaction-isolation-level,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.TransactionAccessMode.html
    enum transaction-access-mode {
      read-only,
      read-write,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.TransactionIsolationLevel.html
    enum transaction-isolation-level {
      read-uncommitted,
      read-committed,
      repeatable-read,
      serializable,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.OperateFunctionArg.html
    record operate-function-arg {
      mode: option<arg-mode>,
      name: option<ident>,
      data-type: data-type,
      default-expr: option<expr>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.ArgMode.html
    enum arg-mode {
      in,
      out,
      in-out,
    }

    record create-function-body {
      language: option<ident>,
      behavior: option<function-behavior>,
      %as: option<function-definition>,
      return: option<expr>,
      using: option<create-function-using>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.FunctionBehavior.html
    enum function-behavior {
      immutable,
      stable,
      volatile,
    }

    variant function-definition {
      single-quoted-def(string),
      double-dollar-def(string),
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.CreateFunctionUsing.html
    variant create-function-using {
      jar(string),
      file(string),
      archive(string),
    }

    record procedure-param {
      name: ident,
      data-type: data-type,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.MacroArg.html
    record macro-arg {
      name: ident,
      default-expr: option<expr>,
    }

    variant macro-definition {
      expr(expr),
      table(sql-query),
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.UserDefinedTypeRepresentation.html
    union user-defined-type-representation {
      composite-user-defined-type,
    }

    record composite-user-defined-type {
      attributes: list<user-defined-type-composite-attribute-def>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.UserDefinedTypeCompositeAttributeDef.html
    record user-defined-type-composite-attribute-def {
      name: ident,
      data-type: data-type,
      collation: option<object-name>,
    }


    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.AlterTableOperation.html
    union alter-table-operation {
      add-constraint,
      add-column,
      drop-constraint,
      drop-column,
      drop-primary-key,
      rename-partitions,
      add-partitions,
      drop-partitions,
      rename-column,
      rename-table,
      change-column,
      rename-constraint,
      alter-column,
      swap-with,
    }

    record add-constraint {
      constraint: table-constraint,
    }

    record add-column {
      column-keyword: bool,
      if-not-exists: bool,
      column-def: column-def,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.ColumnDef.html
    record column-def {
      name: ident,
      data-type: data-type,
      collation: option<object-name>,
      options: list<column-option-def>,
    }
    
    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.ColumnOptionDef.html
    record column-option-def {
      name: option<ident>,
      %option: column-option,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.ColumnOption.html
    variant column-option {
      null,
      not-null,
      default(expr),
      unique(unique-option),
      // primary-key,
      // collate(object-name),
      foreign-key(foreign-key-option),
      check(expr),
      dialect-specific(string), // TODO: was Vec<Token>/list<token>
      character-set(object-name),
      comment(string),
      on-update(expr),
      generated(generated-option),
    }

    record unique-option {
      is-primary: bool,
    }

    record foreign-key-option {
      foreign-table: object-name,
      referred-columns: list<ident>,
      on-delete: option<referential-action>,
      on-update: option<referential-action>,
    }

    record generated-option {
      generated-as: generated-as,
      sequence-options: option<list<sequence-options>>,
      generation-expr: option<expr>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.SequenceOptions.html
    variant sequence-options {
      increment-by(increment-by),
      min-value(min-max-value),
      max-value(min-max-value),
      start-with(start-with),
      cache(expr),
      cycle(bool),
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.MinMaxValue.html
    variant min-max-value {
      empty,
      none,
      some(expr),
    }

    record increment-by {
      increment: expr,
      by: bool,
    }

    record start-with {
      start: expr,
      with: bool,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.GeneratedAs.html
    enum generated-as {
      always,
      by-default,
      exp-stored,
    }

    record drop-constraint {
      if-exists: bool,
      name: ident,
      cascade: bool,
    }

    record drop-column {
      column-name: ident,
      if-exists: bool,
      cascade: bool,
    }

    record drop-primary-key {}

    record rename-partitions {
      old-partitions: list<expr>,
      new-partitions: list<expr>,
    }

    record add-partitions {
      if-not-exists: bool,
      new-partitions: list<expr>,
    }

    record drop-partitions {
      partitions: list<expr>,
      if-exists: bool,
    }

    record rename-column {
      old-column-name: ident,
      new-column-name: ident,
    }

    record rename-table {
      table-name: object-name,
    }

    record change-column {
      old-name: ident,
      new-name: ident,
      data-type: data-type,
      options: list<column-option>,
    }

    record rename-constraint {
      old-name: ident,
      new-name: ident,
    }

    record alter-column {
      column-name: ident,
      op: alter-column-operation,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.AlterColumnOperation.html
    variant alter-column-operation {
      set-not-null,
      drop-not-null,
      drop-default,
      set-data-type(set-data-type),
      set-default(set-default),
      // AddForeignKey(ForeignKeyClause),
      // DropForeignKey {
      //     foreign_key_name: Option<Ident>,
      // },
      // AddConstraint(TableConstraint),
      // DropConstraint {
      //     constraint_name: Ident,
      // },
      // RenameTo(Ident),
    }

    record set-data-type {
      data-type: data-type,
      using: option<expr>,
    }

    record set-default {
      value: expr,
    }

    record swap-with {
      table-name: object-name,
    }

    record data-type-ref {
      index: u32,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.DataType.html
    variant data-type {
      character(option<character-length>),
      %char(option<character-length>),
      character-varying(option<character-length>),
      char-varying(option<character-length>),
      varchar(option<character-length>),
      nvarchar(option<u64>),
      uuid,
      character-large-object(option<u64>),
      char-large-object(option<u64>),
      clob(option<u64>),
      binary(option<u64>),
      varbinary(option<u64>),
      blob(option<u64>),
      numeric(exact-number-info),
      decimal(exact-number-info),
      big-numeric(exact-number-info),
      big-decimal(exact-number-info),
      dec(exact-number-info),
      float(option<u64>),
      tiny-int(option<u64>),
      unsigned-tiny-int(option<u64>),
      small-int(option<u64>),
      unsigned-small-int(option<u64>),
      medium-int(option<u64>),
      unsigned-medium-int(option<u64>),
      int(option<u64>),
      integer(option<u64>),
      unsigned-int(option<u64>),
      unsigned-integer(option<u64>),
      big-int(option<u64>),
      unsigned-big-int(option<u64>),
      real,
      double,
      double-precision,
      boolean,
      date,
      time(timestamp-type),
      datetime(option<u64>),
      timestamp(timestamp-type),
      interval,
      json,
      regclass,
      text,
      %string,
      bytea,
      custom(custom-data-type),
      array(option<data-type-ref>),
      %enum(list<string>),
      set(list<string>),
    }
    
    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.CharacterLength.html
    record character-length {
      length: u64,
      unit: option<char-length-units>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.CharLengthUnits.html
    enum char-length-units {
      octets,
      characters,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.ExactNumberInfo.html
    record exact-number-info {
      precision: option<u64>,
      scale: option<u64>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.TimezoneInfo.html
    enum timezone-info {
      none,
      with-timezone,
      without-timezone,
      tz,
    }

    record custom-data-type {
      name: object-name,
      arguments: list<string>,
    }

    record timestamp-type {
      value: option<u64>,
      timezone-info: timezone-info,
    }

    record alter-index {
      name: object-name,
      operation: alter-index-operation,
    }

    union alter-index-operation {
      rename-index,
    }

    record rename-index {
      index-name: object-name,
    }

    type object-name = list<ident>

    record ident {
      value: string,
      quote-style: option<char>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.Statement.html#variant.Insert
    record sql-insert {
      or: option<sqlite-on-conflict>,
      into: bool,
      table-name: object-name,
      columns: list<ident>,
      overwrite: bool,
      // TODO: boxed
      source: sql-query,
      partitioned: option<list<expr>>,
      after-columns: list<ident>,
      table: bool,
      on: option<on-insert>,
      returning: option<list<select-item>>,
    }

    enum sqlite-on-conflict {
      rollback,
      abort,
      fail,
      ignore,
      replace,
    }

    record sql-update {
      table: table-with-joins,
      assignments: list<assignment>,
      %from: option<table-with-joins>,
      selection: option<expr>,
      returning: option<list<select-item>>,
    }

    record sql-delete {
      tables: list<object-name>,
      %from: list<table-with-joins>,
      using: option<list<table-with-joins>>,
      selection: option<expr>,
      returning: option<list<select-item>>,
    }

    record sql-create-table {
      or-replace: bool,
      temporary: bool,
      external: bool,
      global: option<bool>,
      if-not-exists: bool,
      transient: bool,
      name: object-name,
      columns: list<column-def>,
      constraints: list<table-constraint>,
      // TODO: hive-distribution: HiveDistributionStyle,
      // hive-formats: option<HiveFormat>,
      table-properties: list<sql-option>,
      with-options: list<sql-option>,
      file-format: option<file-format>,
      location: option<string>,
      query: option<sql-query>,
      without-rowid: bool,
      like: option<object-name>,
      clone: option<object-name>,
      engine: option<string>,
      default-charset: option<string>,
      collation: option<string>,
      on-commit: option<on-commit>,
      on-cluster: option<string>,
      order-by: option<list<ident>>,
      strict: bool,
    }

    record sql-create-index {
      name: object-name,
      table-name: object-name,
      using: option<ident>,
      columns: list<order-by-expr>,
      unique: bool,
      if-not-exists: bool,
    }

    record sql-create-view {
      or-replace: bool,
      materialized: bool,
      name: object-name,
      columns: list<ident>,
      query: sql-query,
      // temporary: bool,
      // with-check-option: bool,
      with-options: list<sql-option>,
      cluster-by: list<ident>,
      // check-option: option<check-option>,
      // security: option<security>,
      // owner: option<object-name>,
      // comment: option<string>,
    }

    record sql-option {
      name: ident,
      value: sql-value,
    } 
    
    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.Value.html
    variant sql-value {
      number(number-value),
      single-quoted-string(string),
      dollar-quoted-string(dollar-quoted-string),
      escaped-string-literal(string),
      single-quoted-byte-string-literal(string),
      double-quoted-byte-string-literal(string),
      raw-string-literal(string),
      national-string-literal(string),
      hex-string-literal(string),
      double-quoted-string(string),
      boolean(bool),
      null,
      placeholder(string),
      un-quoted-string(string),
    }

    record number-value {
      value: string,
      long: bool,
    }

    record dollar-quoted-string {
      value: string,
      tag: option<string>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.TableConstraint.html
    union table-constraint {
      unique-constraint,
      foreign-key-constraint,
      check-constraint,
      index-constraint,
      full-text-or-spatial-constraint,
    }

    record unique-constraint {
      name: option<ident>,
      columns: list<ident>,
      is-primary: bool,
    }

    record foreign-key-constraint {
      name: option<ident>,
      columns: list<ident>,
      foreign-table: object-name,
      referred-columns: list<ident>,
      on-delete: option<referential-action>,
      on-update: option<referential-action>,
    }

    record check-constraint {
      name: option<ident>,
      expr: expr,
    }

    record index-constraint {
      display-as-key: bool,
      name: option<ident>,
      index-type: option<index-type>,
      columns: list<ident>,
    }

    record full-text-or-spatial-constraint {
      fulltext: bool,
      index-type-display: key-or-index-display,
      opt-index-name: option<ident>,
      columns: list<ident>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.ReferentialAction.html
    enum referential-action {
      restrict,
      cascade,
      set-null,
      no-action,
      set-default,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.IndexType.html
    enum index-type {
      b-tree,
      hash,
      // gist,
      // spgist,
      // gin,
      // brin,
    }

    enum key-or-index-display {
      none,
      key,
      index,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.FileFormat.html
    enum file-format {
      textfile,
      sequencefile,
      orc,
      parquet,
      avro,
      rcfile,
      jsonfile,
      // csv,
      // tsv,
      // custom,
    }

    enum on-commit {
      preserve-rows,
      delete-rows,
      drop,
    }

    record sql-query {
      with: option<with>,
      body: set-expr,
      order-by: list<order-by-expr>,
      limit: option<expr>,
      offset: option<offset>,
      fetch: option<fetch>,
      locks: list<lock-clause>,
    }

    // TODO: recursive
    union set-expr {
      sql-select-ref,
      sql-query-ref,
      set-operation,
      values,
      sql-insert-ref,
      sql-update-ref,
      table,
    }

    record set-expr-ref {
      index: u32,
    }

    record sql-select-ref {
      index: u32,
    }

    record sql-query-ref {
      index: u32,
    }

    record sql-update-ref {
      index: u32,
    }

    record sql-insert-ref {
      index: u32,
    }

    record set-operation {
      op: set-operator,
      set-quantifier: set-quantifier,
      // TODO: recursive
      left: set-expr-ref,
      right: set-expr-ref,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.SetOperator.html
    enum set-operator {
      %union,
      except,
      intersect,
    }

    enum set-quantifier {
      all,
      distinct,
      none,
    }

    record values {
      explicit-row: bool,
      rows: list<list<expr>>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.LockClause.html
    record lock-clause {
      lock-type: lock-type,
      of: option<object-name>,
      nonblock: option<non-block>,
    }

    enum non-block {
      nowait,
      skip-locked,
    }
    
    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.LockType.html
    enum lock-type {
      update,
      share,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.Fetch.html
    record fetch {
      with-ties: bool,
      percent: bool,
      quantity: option<expr>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.Offset.html
    record offset {
      value: expr,
      rows: offset-rows,
    }

    enum offset-rows {
      none,
      row,
      rows,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.Select.html
    record sql-select {
      distinct: option<distinct>,
      top: option<top>,
      projection: list<select-item>,
      into: option<select-into>,
      %from: list<table-with-joins>,
      lateral-views: list<lateral-view>,
      selection: option<expr>,
      group-by: list<expr>,
      cluster-by: list<expr>,
      distribute-by: list<expr>,
      sort-by: list<expr>,
      having: option<expr>,
      named-window: list<named-window-definition>,
      qualify: option<expr>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.TableWithJoins.html
    record table-with-joins {
      relation: table-factor,
      joins: list<join>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.TableFactor.html
    union table-factor {
      table-factor-table,
      // TODO: derived
    }

    record table-factor-table {
      name: object-name,
      alias: option<table-alias>,
      args: option<list<function-arg>>,
      with-hints: list<expr>,
    }

    record table {
      table-name: option<string>,
      schema-name: option<string>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.Join.html
    record join {
      relation: table-factor,
      join-operator: join-operator,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.JoinOperator.html
    variant join-operator {
      inner(join-constraint),
      left-outer(join-constraint),
      right-outer(join-constraint),
      full-outer(join-constraint),
      cross-join,
      left-semi(join-constraint),
      right-semi(join-constraint),
      left-anti(join-constraint),
      right-anti(join-constraint),
      cross-apply,
      outer-apply,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.JoinConstraint.html
    variant join-constraint {
      on(expr),
      using(list<ident>),
      natural,
      none,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.LateralView.html
    record lateral-view {
      lateral-view: expr,
      lateral-view-name: object-name,
      lateral-col-alias: list<ident>,
      outer: bool,
    } 

    record named-window-definition {
      name: ident,
      window-spec: window-spec,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.WindowSpec.html
    record window-spec {
      partition-by: list<expr>,
      order-by: list<order-by-expr>,
      window-frame: option<window-frame>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.OrderByExpr.html
    record order-by-expr {
      expr: expr,
      asc: option<bool>,
      nulls-first: option<bool>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.WindowFrame.html
    record window-frame {
      units: window-frame-units,
      start-bound: window-frame-bound,
      end-bound: option<window-frame-bound>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.WindowFrameUnits.html
    enum window-frame-units {
      rows,
      range,
      groups,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.WindowFrameBound.html
    variant window-frame-bound {
      current-row,
      preceding(option<expr>),
      following(option<expr>),
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.FunctionArg.html
    variant function-arg {
      named(function-arg-expr-named),
      unnamed(function-arg-expr),
    }

    record function-arg-expr-named {
      name: ident,
      arg: function-arg-expr,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.FunctionArgExpr.html
    variant function-arg-expr {
      expr(expr),
      qualified-wildcard(object-name),
      wildcard
    }

    variant distinct {
      distinct,
      on(list<expr>)
    }

    record top {
      with-ties: bool,
      percent: bool,
      quantity: option<expr>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/enum.SelectItem.html
    variant select-item {
      unnamed-expr(expr),
      expr-with-alias(expr-with-alias),
      qualified-wildcard(qualified-wildcard),
      wildcard(asterisk),
    }

    record expr-with-alias {
      expr: expr,
      alias: ident,
    }

    record qualified-wildcard {
      qualifier: object-name,
      asterisk: asterisk,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.WildcardAdditionalOptions.html
    record asterisk {
      // TODO: opt-exclude: option<ExcludeSelectItem>,
      // opt-except: option<ExceptSelectItem>,
      // opt-rename: option<RenameSelectItem>,
      // opt-replace: option<ReplaceSelectItem>,
    }

    record select-into {
      temporary: bool,
      unlogged: bool,
      table: bool,
      name: object-name,
    }

    record with {
      recursive: bool,
      cte-tables: list<common-table-expr>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.Cte.html
    record common-table-expr {
      alias: table-alias,
      query: sql-query-ref,
      %from: option<ident>,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.TableAlias.html
    record table-alias {
      name: ident,
      columns: list<ident>,
    }

    variant on-insert {
      duplicate-key-update(list<assignment>),
      on-conflict(on-conflict),
    }

    record on-conflict {
      conflict-target: option<conflict-target>,
      action: on-conflict-action,
    }

    variant conflict-target {
      columns(list<ident>),
      on-constraint(object-name),
    }

    variant on-conflict-action {
      do-nothing,
      do-update(do-update),
    }

    record do-update {
      assignments: list<assignment>,
      selection: option<expr>,
    }

    record assignment {
      id: list<ident>,
      value: expr,
    }

    record expr-ref {
      index: u32,
    }

    union expr {
      ident,
      compound-identifier,
      unary-op,
      bool-unary-op,
      binary-op,
      is-distinct-from,
      is-not-distinct-from,
      any-op,
      all-op,
      exists-expr,
      nested-expr,
      sql-value,
      subquery,

      json-access,
      composite-access,
      in-list,
      in-subquery,
      in-unnest,
      between,
      like,
      ilike,
      similar-to,
      cast,
      try-cast,
      safe-cast,

      at-time-zone,
      extract,
      ceil,
      floor,
      position,
      substring,
      trim,
      overlay,
      collate,
      introduced-string,
      typed-string,
      map-access,
      sql-function-ref,
    }


//     Function(Function),
//     AggregateExpressionWithFilter {
//         expr: Box<expr>,
//         filter: Box<expr>,
//     },
//     Case {
//         operand: Option<Box<expr>>,
//         conditions: Vec<expr>,
//         results: Vec<expr>,
//         else_result: Option<Box<expr>>,
//     },
//     ArraySubquery(Box<Query>),
//     ListAgg(ListAgg),
//     ArrayAgg(ArrayAgg),
//     GroupingSets(Vec<Vec<expr>>),
//     Cube(Vec<Vec<expr>>),
//     Rollup(Vec<Vec<expr>>),
//     Tuple(Vec<expr>),
//     ArrayIndex {
//         obj: Box<expr>,
//         indexes: Vec<expr>,
//     },
//     Array(Array),
//     Interval(Interval),
//     MatchAgainst {
//         columns: Vec<Ident>,
//         match_value: Value,
//         opt_search_modifier: Option<SearchModifier>,
//     },

    record sql-function-ref {
      index: u32,
    }

    /// https://docs.rs/sqlparser/0.35.0/sqlparser/ast/struct.Function.html
    record sql-function {
      name: object-name,
      args: list<function-arg>,
      over: option<window-type>,
      distinct: bool,
      special: bool,
      order-by: list<order-by-expr>,
    }

    variant window-type {
        window-spec(window-spec),
        named-window(ident),
    }

    record at-time-zone {
      timestamp: expr-ref,
      time-zone: string,
    }

    record extract {
      field: date-time-field,
      expr: expr-ref,
    }

    record ceil {
      expr: expr-ref,
      field: date-time-field,
    }

    record floor {
      expr: expr-ref,
      field: date-time-field,
    }

    record position {
      expr: expr-ref,
      in: expr-ref,
    }

    record substring {
      expr: expr-ref,
      substring-from: option<expr-ref>,
      substring-for: option<expr-ref>,
    }

    record trim {
      expr: expr-ref,
      trim-where: option<trim-where-field>,
      trim-what: option<expr-ref>,
    }

    record overlay {
      expr: expr-ref,
      overlay-what: expr-ref,
      overlay-from: expr-ref,
      overlay-for: option<expr-ref>,
    }

    enum date-time-field {
      year,
      month,
      week,
      day,
      date,
      hour,
      minute,
      second,
      century,
      decade,
      dow,
      doy,
      epoch,
      isodow,
      isoyear,
      julian,
      microsecond,
      microseconds,
      millenium,
      millennium,
      millisecond,
      milliseconds,
      nanosecond,
      nanoseconds,
      quarter,
      timezone,
      timezone-hour,
      timezone-minute,
      no-date-time,
    }     

    enum trim-where-field {
      both,
      leading,
      trailing,
    }

    record collate {
      expr: expr-ref,
      collation: object-name,
    }

    record introduced-string {
      introducer: string,
      value: sql-value,
    }

    record typed-string {
      data-type: data-type,
      value: string,
    }

    record map-access {
      column: expr-ref,
      keys: list<expr-ref>,
    }

    record json-access {
      left: expr-ref,
      operator: json-operator,
      right: expr-ref,
    }

    enum json-operator {
      arrow,
      long-arrow,
      hash-arrow,
      hash-long-arrow,
      colon,
      at-arrow,
      arrow-at,
      hash-minus,
      at-question,
      at-at,
    }

    record composite-access {
      expr: expr-ref,
      key: ident,
    }

    record in-list {
      expr: expr-ref,
      %list: list<expr-ref>,
      negated: bool,
    }

    record in-subquery {
      expr: expr-ref,
      subquery: sql-query-ref,
      negated: bool,
    }

    record in-unnest {
      expr: expr-ref,
      array-expr: expr-ref,
      negated: bool,
    }

    record between {
      expr: expr-ref,
      negated: bool,
      low: expr-ref,
      high: expr-ref,
    }

    record like {
      negated: bool,
      expr: expr-ref,
      pattern: expr-ref,
      escape-char: option<char>,
    }

    record ilike {
      negated: bool,
      expr: expr-ref,
      pattern: expr-ref,
      escape-char: option<char>,
    }

    record similar-to {
      negated: bool,
      expr: expr-ref,
      pattern: expr-ref,
      escape-char: option<char>,
    }

    record cast {
      expr: expr-ref,
      data-type: data-type,
    }

    record try-cast {
      expr: expr-ref,
      data-type: data-type,
    }

    record safe-cast {
      expr: expr-ref,
      data-type: data-type,
    }

    record any-op {
      expr: expr-ref,
    }

    record all-op {
      expr: expr-ref,
    }

    record exists-expr {
      subquery: sql-query-ref,
      negated: bool,
    }

    record nested-expr {
      expr: expr-ref,
    }

    record subquery {
      query: sql-query-ref,
    }

    record binary-op {
      left: expr-ref,
      op: binary-operator,
      right: expr-ref,
    }

    variant binary-operator {
      plus,
      minus,
      multiply,
      divide,
      modulo,
      string-concat,
      gt,
      lt,
      gt-eq,
      lt-eq,
      spaceship,
      eq,
      not-eq,
      and,
      or,
      xor,
      bitwise-or,
      bitwise-and,
      bitwise-xor,
      duck-integer-divide,
      my-integer-divide,
      custom(string),
      pg-bitwise-xor,
      pg-bitwise-shift-left,
      pg-bitwise-shift-right,
      pg-exp,
      pg-regex-match,
      pg-regex-i-match,
      pg-regex-not-match,
      pg-regex-not-i-match,
      pg-custom-binary-operator(list<string>),
    }

    record bool-unary-op {
      op: bool-unary-operator,
      expr: expr-ref,
    }

    enum bool-unary-operator {
      is-false,
      is-not-false,
      is-true,
      is-not-true,
      is-null,
      is-not-null,
      is-unknown,
      is-not-unknown,
    }

    record unary-op {
      op: unary-operator,
      expr: expr-ref,
    }

    enum unary-operator {
      plus,
      minus,
      not,
      pg-bitwise-not,
      pg-square-root,
      pg-cube-root,
      pg-postfix-factorial,
      pg-prefix-factorial,
      pg-abs,
    }

    record is-distinct-from {
      left: expr-ref,
      right: expr-ref,
    }

    record is-not-distinct-from {
      left: expr-ref,
      right: expr-ref,
    }

    type compound-identifier = list<ident>

    record parsed-sql {
      statements: list<sql-ast>,
      sql-ast-refs: list<sql-ast>,
      sql-query-refs: list<sql-query>,
      sql-insert-refs: list<sql-insert>,
      sql-update-refs: list<sql-update>,
      sql-select-refs: list<sql-select>,
      set-expr-refs: list<set-expr>,
      expr-refs: list<expr>,
      data-type-refs: list<data-type>,
      warnings: list<string>,
    }

    export parse-sql: func(sql: string) -> result<parsed-sql, string>
}

